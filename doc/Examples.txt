/*----------------------------------------------------------------------------------------------------------------------
	Java ile Nesne Yönelimli Programlama

	Eğitmen: Oğuz KARAN

	C ve Sistem Programcıları Derneği
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	05.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java, hem programlama diline hem de ortamına (platform) verilen bir isimdir. Genel olarak kursumuzda Java dendiğinde
	programlama dili anlaşılacaktır. Ayrıca Java ortamı için JavaSE'de kullanılacaktır. Aslında JavaSE de genel bir
	terimdir.

	Java Ortamının Temel Özellikler:
	- Arakodlu çalışma sistemi: C ve C++ gibi dillerde yazılan programdan üretilen dosya (executable file)
	sistem düzeyinde (donanım, isletim sistemi vs.) çalışabilir. Örneğin, Windows işletim sistemi için üretilmiş
	bir program, Mac OS işletim sisteminde doğrudan çalıştırılamaz. O sistem için çalışabilir dosyanın ayrıca üretilmesi
	gerekir. Java'da yazılan programdan üretilen kod geneldir ve herhangi bir sisteme özgü değildir. Kendine ait
	standart formatı vardır. Bu şekilde üretilen dosyalara genel olarak "ara kod (intermediate code)" denir. Java özelinde
	bu arakoda "byte code" denir. Bu durumda byte code'u işletim sistemi çalıştıramaz. İşte bu durumda bu kodu çalıştıran
	işletim sistemine özgü ayrı bir program kullanılır. Bu programa genel olarak "Java Virtual Machine (JVM)" denir. Aslında
	sistem düzeyinde çalışan program budur. JVM arakodu yorumlayarak makine koduna (machine code) dönüştürür. Bu işleme
	"Just In Time Compilation (JIT)" denir. Böylesi bir tasarımın en büyük avantajı programın taşınabilirliğidir. Yani
	Java programcısı, programını bir kez yazar ve bir kez byte code'unu üretir ve bu byte her sistemde çalıştırılabilir.
	Şüphesiz bu durumun da istisnaları vardır. Ancak unutulmamalıdır ki, arakodlu çalışma sistemi görece yavaştır. Ancak
	bu yavaşlık Java'nın hedeflediği uygulamalar açısından önemsizdir. Geliştirme ve çalıştırma anlamında şu temel kavramlar
	önemlidir:
		- JVM (Java Virtual Machine): Byte code'u yorumlayarak aşağı seviyeli makine koduna dönüştürür. Aslında JVM
		byte code'un nasıl yorumlayanacağına yönelik soyut bir kavramdır.

		- JRE (Java Runtime Environment): genel olarak Java ile yazılmış bir uygulamayı çalıştırmak için gereken araçları ve
		uygulamaları içeren bir pakettir. Yani Java ile yazılmış bir programın çalıştırılabilmesi için JRE gereklidir.

		- JDK (Java Development Kit): Geliştirme (development) için kullanılan araçları barındıran bir pakettir. JDK içerisinde
		geliştirme yaparken kullanılmak üzere çalıştırma araçları da bulunur.

		Ticari kullanımlarda Java 11 ile birlikte bir takım değişiklikler yapılmıştır. Şu şekilde özetlenebilir: Genel olarak geliştirme ortamı
		ücretsizdir, çalıştırma ortamı ücretli olabilir ancak ücretsiz olanları da vardır. Bu konuların detayları vardır. Bu
		bölümde ele alınmayacaktır. Örneğin Oracle firmasının JRE'si ücretlidir ancak Open JRE denilen tamamen ücretsiz bir
		ortam da mevcuttur.

		Arakodlu çalışma sisteminin yukarıda anlatılan avantajına "Write Once Run Anywhere (WORA)" da denilmektedir.

	- Hızlı uygulama geliştirme ortamı: Java hızlı uygulama geliştirme (rapid application development) ortamı sunar. Bu anlamda
	ürün elde edilmesi daha çabuk olabilmektedir ve aynı zamanda öğrenmesi de görece kolay olabilmektedir.

	- Geniş bir sınıf kütüphanesi: Java'da (JavaSE'de) geniş bir sınıf kütüphanesi vardır. Veritabanı işlemleri, web programlama
	vb. için gereken bir çok sınıf hazır olarak bulunmaktadır.

	- Güvenli çalışma ortamı: Java'da yazılan programların, programcının yaptığı hatalardan dolayı sisteme zarar verme olasıkları
	çok çok azdır. Bu da güvenli bir çalışma ortamı sunmasına yol açar.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	06.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Programlama Dillerinin Sınıflandırılması: Programlama dilleri çeşitli şekillerde sınıflandırılabilse de genel olarak
	3 şekilde sınıflandırma eğilimi söz konusudur:
	1. Seviyelerine (level) göre sınıflandırma: Programlama dilinin seviyesi onun insan algısına yakınlığının ölçüsüdür. Yüksek
	seviyeli diller (high level languages) hem dil özellikleri, hem de uygulama geliştirme anlamında insan algısına yakınlıkları
	dolayısıyla daha kolay öğrenebilirler. Düşük seviyeli diller (low level languages) makineye daha yakın dillerdir. Olabilecek
	en düşük seviyeli dil makine dilidir.

	2. Kullanım alanlarına göre sınıflandırma: Dilin hangi alanlarda kullanılabileceğine göre sınıflandırmadır. Bazı diller
	birden fazla alanda kullanılabilirler. Bazı diller ise sadece bir alanda kullanılabilirler. Bu anlamda genel amaçlı diller,
	bilimsel ve mühendislik dilleri, veritabanı dilleri, yapay zeka dilleri, oyun ve animasyon dilleri vb. alanlar için diller
	söz konusu olabilmektedir.

	3. Programlama modeline göre sınıflandırma: Bir programı yazarken kullanılan genel model (paradigm) önemlidir. Bazı dillerde
	sınıf yoktur. Program çeşitli alt programların (function) bir araya getirilmesiyle yazılır. Bu modele "procedurel model"
	denir. Bazı dillerde sınıflar vardır ve programlar sınıflar kullanılarak yazılır. Başka bir çok kavramla birlikte sınıflar
	kullanılarak yazılan programlama modeline "nesne yönelimli model (object oriented model)" denir. Bazı dillerde programlar
	matematiksel formül yazıyormuş gibi yazılmaktadır. Bu tarz programlama modeline "fonksiyonel (functional)" model denir.
	Bazı diller birden fazla modeli desteklerler. Bu tarz dillere "multi paradigm languages" denilmektedir. Birden fazla modeli
	destekleyen diller, modellerin tüm özelliklerini desteklemeyebilir.

	Bu durumda Java, bilimsel ve mühendislik uygulamalarında, web uygulamalarında, yapay zeka uygulamalarında, mobil
	programlamada vb. kullanılabilen genel amaçlı, yüksek seviyeli, nesne yönelimli programlama modeli ile uygulama
	geliştirilebilen ve özellikle Java 8 ile birlike fonksiyonel programlama modelini de belirli ölçüde destekleyen
	"multi paradigm" bir dildir.

	Anahtar Notlar: Bir dilin bir çok alanda kullanılabilmesi, o dilin tüm alanlarında pratikte kullanılacağı anlamına gelmez.
	Bir alanda daha etkin kullanılabilen bir dil varsa o dil daha fazla tercih edilebilir.

	Anahtar Notlar: Yukarıda anlatılan kavramların detayları vardır. Zaman içerisinde anlaşılacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Temel Kavramlar:
	Çevirici Programlar, Derleyiciler ve Yorumlayıcılar: Bir dilde yazılmış programı başka bir dile çeviren programlara
	çevirici programlar (translator) denir. Çevirici programlarda bir kaynak dil (source language) ve bir hedef dil (target/destination language)
	vardır. Kaynak dil yüksek seviyeli, hedef dil düşük seviyeli bir programlama diliyse bu durumda çevirici programa
	derleyici (compiler) denir. Örneğin Java programlama dilinden Kotlin programlama diline dönüştürme yapan program
	bir translator, Java programlama dilinden byte code'a dönüştürme yapan program ise bir compiler'dır. JVM'in byte code'u
	makine kodu makine koduna çevirme faaliyeti de bir derleme işlemidir. Bu sebeple buna JIT compilation denir. Bazı
	dillerde yazılan programlar herhangi bir kod üretilmeden çalıştırılırlar. Bu tarz dillerde yazılmış programları
	herhangi bir kod üretmeden çalıştıran programlara "interpreter" denir. Bazı diller hem derleyici hem yorumlayıcı ile
	kullanılabilirler. Java pratikte derleyici ile kullanılan Java 11 ile birlikte "java" programı yorumlayıcı olarak da
	java kodunu byte code üretilmeden çalıştırabilmektedir. Yorumlayıcı ile kullanılan diller derleyici ile kullanılan dillere
	göre daha yavaş olma eğilimindedir.

	Anahtar Notlar: Bir uygulama tek bir java dosyasından oluşmak zorunda değildir. Hatta bir Java uygulaması yalnızca
	java kodlarından da oluşmak zorunda değildir. Bu durumda farklı java dosyaları ayrı derlenir. Hatta aynı dosyada
	bulunan sınıflar da ayrı derlenir. Bir ürün aslında tüm birimlerinin uygun şekilde derlenmesi ve ele alınmasıyla
	elde edilir. Bu işleme genel olarak "build" terimi kullanılır. Build işlemi yalnızca derleme işlemi değildir. Yani
	bir uygulamanın ürün olarak elde edilmesi süreci "build" işlemidir. Burada anlatılanların da detayları zamanla
	ele alınacaktır.

	İşletim Sistemi (Operating System): Makinenin donanımını yöneten, bilgisayar ile kullanıcı arasında bir köprü oluşturan
	yazılımdır. Br işletim sisteminin pek çok görevi vardır. Programları çalıştırmak, çeşitli cihazları ve aygıtları yönetmek,
	dosyaları ve dizinleri (directory) organize etmek vb. görevler sayılabilir. İşletim sistemleri genel olarak iki gruba
	ayrılabilir: masaüstü işletim sistemleri (desktop operating systems), mobil işletim sistemleri (mobile operating systems).
	Şüphesiz başka çeşit işletim sistemleri de vardır. Popüler masaüstü işletim sistemleri Windows, Mac OS X, Unix ve Linux
	gibi işlemleridir. Popüler mobil işletim sistemleri Android ve IOS'dur.

	Açık kaynak kodlu yazılım, özgür yazılım ve mülkiyete sahip yazılım: Özgür yazılım (free software) ve açık kaynak kodlu
	(open source) yazılımlar arasında farklar olsa genel olarak aşağıdaki ortak özelliklere sahiptirler:
		- Bedavadır. Kullanılabilmesi için herhangi bir lisans gerekmez.
		- Kaynak kodlar sahiplenilemez. Kaynak koda ekleme yapıldığında ya da bir kaynak kod kullanıldığında kodlar kapatılamaz.
		Onların da açılması gerekir.
		- Çoğaltılabilir, izin almadan kullanılabilir.

	Bunun tam tersi olarak mülkiyete sahip (propriatery) yazlımlardır. Bu yazılımlar para verilerek kullanılır ve izin
	almadan çoğaltılamaz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	IDE (Integrated Development Environment): Derleyicler ve yorumlayıcılar komut satırından çalışan ve basit arayüzlere
	sahip programlardır. Aslında teorik olarak bir uygulamadaki tüm Java dosyaları ve diğer dosyalar basit bir editör programla
	yazılıp komut satırından derlenebilir. Ancak bu uygulama büyüdükçe zahmetli olmaya başlar. Bu da programcıya zaman
	kaybettirir. Bu amaçla pratikte yazılm geliştirmeyi kolaylaştırmak için IDE denilen yazılımlar kullanılır. IDE'lerde
	örneğin bir takım yardımlar veren editörler, tasarım araçları, test araçları, debug araçları vb. programcının geliştirme
	sırasında kullandığı araçlar bulunur. Java ile uygulama geliştirmede iki tane IDE yoğun olarak kullanılmaktadır:
	Eclipse, IntelliJIDEA. Biz kursumuzda belirli bir zaman (yaklaşık kursun yarısına kadar) Eclipse, sonrasında IntelliJIDEA
	kullanacağız.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	12.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	JDK'nın kurulumu için işletim sistemine göre aşağıdaki şu link'den ilgili "installer" indirilebilir: 
	https://www.oracle.com/tr/java/technologies/downloads/. Burada LTS olması açısından 17 seçilebilir. Ya da en son
	versiyon seçilebilir. Dersin tarihinde en son versiyon JDK 20 'dir. Kursumuzda Java 17 özellikleri de konular
	içerisinde ele alınacağından en az Java 17 kurulumu önerilir. Java 17 öncesinde en az Java 11 olmalıdır. Kurulum
	aşamasından sonra java ve javac programları -version seçeneği ile çalıştırılarak versiyon kontrolü yapılabilir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki programı çalıştırmak için JDK kurulu olan bir bilgisayarda aşağıdaki işlemlerin yapılması gerekir:
	1. Herhangi bir dizinde (directory/folder) csd isimli bir dizin açılır. Buradaki csd isminin tamamı küçük harf olacak
	şekilde yapılmalıdır.

	2. csd dizini içerisinde App.java isimli bir dosya açılır. Windows sisteminde uzantılar gizlenmişse görünür hale getirilip
	uzantının .java olduğuna dikkat ediniz. Buradaki dosya isminin de büyük küçük harf duyarlı olarak yazılması gerekir

	3. Komut yorumlayıcı program (command prompt or terminal) ile ilgili dizine geçilir. Dizin geçişleri için tüm sistemlerde
	aynı olan cd (change directory) komutu kullanılabilir. Örneğin: cd Dropbox/CSD/Kurslar/Java-Aug-2023/src/src-console

	4. Harhangi bir editör program ile App.java dosyasında aşağıdaki programı yazınız

	5. Komut yorumlayıcı programda, csd'nin bulunduğu dizinde aşağıdaki komutları çalıştırarak derleme işlemi yapılır:
		javac csd/App.java -> Windows dışı sistemler için
		javac csd\App.java -> Windows sistemi için
	Derleme işleminde herhangi bir hata (error) mesajı alınmazsa derleme işlemi başarılıdır ve App.class isminde byte code
	üretilir

	6. Komut yorumlayıcı programda aşağıdaki biçimde byte code çalıştırılır:
		java csd.App

	Anahtar Notlar: Yukarıdaki maddelerdek,i bazı zorunluluklar ilerideki konularda anlaşılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("Hello, World");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Dil Kavramı: İletişimde kullanılan semboller topluluğudur. Bir dilin kurallarına "gramer" denir.  Gramerin pek çok
	bileşeni vardır. Bunlardan en önemlileri "sentaks (syntax) ve semantik (semaintic)" kavramlarıdır. Bir olgunun dil
	olabilmesi için en az sentaks ve semantiğesahip olması gerekir. Tersine sentaks ve semantiğe sahip olan bir olgu dildir. 

	Sentaks (sözdizim) doğru yazılmış ve doğru dizilmiş öğelere ilişkin kurallardır:
		"I am from Turkey"
	cümlesi sentaks olarak doğru yazılmıştır. Burada örneğin cümle "I from am Turkey" olarak yazılsaydı sentaks olarak
	hatalı olurdu. Java olarak bakarsak, örneğin
		System.out.println("Hello, World"); 
	cümlesinde noktalı virgül olmazsa sentaks hatası yapılmış olur. 

	Dildeki doğru yazılmış ve dizilmiş öğelerin ne anlam ifade ettiğine yönelik kurallara semantik kurallar denir. 

	Anahtar Notlar: Gramer'in daha çok doğal dillere özgü morfoloji gib başka bileşenleri de bulunur

	Bilgisayar Dilleri ve Programlama Dilleri: Bilgisayar sistemlerinde kullanılmak üzere tasarlanmış dillere bilgisayar 
	dilleri (computer languages) denir. Bir bilgisayar dilinde akış (flow) öğesi de varsa programlama dili (programming language)
	denir. Her programlama dili bir bilgisayar dilidir, her bilgisayar dili programlama dili değildir. Örneğin HTML, XML
	dilleri bilgisayar dilleridir ancak programlama dilleri değildir. Java'da bir akış olduğundan, programlama dilidir dolayısıyla
	bilgisayar dilidir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Boşluk karakterleri (whitespace characters): Klavyeden basıldığında boşluk hissi veren karakterlerdir. Bu anlamda
	SPACE, ENTER ve TAB karakterleri klavyedeki tipik boşluk karakterleridir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Atom (Token): Programlam dilinin parçalanamayan en küçük birimine denir. Burada parçalama terimi genel olarak boşluk
	karakterleri ile ayırma anlamında düşünülebilir. Java'da atomlar şunlardır:
	1. Anahtar Sözcükler (keywords/reserved words): Dile ait olan, herhangi bir şekilde tanıtılması gerekmeyen ve doğrudan
	değişken ismi olarak kullanılamayan atomlardır. Örneğin package, class, public, static, void.

	2. Değişkenler (variables/identifiers): İsmini programcının belirlediği ve isimlendirmesinde çeşitli kuralların bulunduğu
	atomlardır. Örneğin: csd, App, main, String, args, System, out, println.

	3. Sabitler (literals/constants): Program içerisinde doğrudan yazılan değerlere denir. Örneğin x = 10 ifadesinde 10 
	bir sabittir. 

	4. Operatörler (operators): Belirli işleme yol açan ve bu işlem sonucunda değer üreten atomlardır. 
	Örneğin, nokta (.), metot çağırma (()) operatörleri.

	5. String'ler (string literals/strings): İki tane iki tırnak (double quote) arasındaki yazılara tırnaklarıyla birlikte
	string denir. Örneğin, "Hello, World".

	6. Ayraçlar (delimiters/punctuators): Yukarıdakiler dışında kalan diğer atomlardır. Örneğin:;, {}, (), [].
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da kod yazma kuralları:
	1. Atomlar arasında istenildiği kadar boşluk(whitespace) bırakılabilir
	2. Anahtar sözcükler ve değişken atomlar dışında, atomlar istenildiği kadar bitişik (aralarında boşluk olmayacak şekilde)
	yazılabilir. İki anahtar sözcük, iki değişken atom VEYA bir anahtar sözcük ve bir değişken atom bitişik yazılamaz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	
	Atomlar arasında istenildiği kadar boşluk bırakılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	






public static 









void main(String [






] args)
	{
		System.out





.println("Hello, World");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar sözcükler ve değişken atomlar dışında, atomlar istenildiği kadar bitişik (aralarında boşluk olmayacak şekilde)
	yazılabilir.
----------------------------------------------------------------------------------------------------------------------*/
package csd;class App{public static void main(String[]args){System.out.println("Hello, World");}}

/*----------------------------------------------------------------------------------------------------------------------
	İki anahtar sözcük, iki değişken atom VEYA bir anahtar sözcük ve bir değişken atom bitişik yazılamaz
----------------------------------------------------------------------------------------------------------------------*/
packagecsd;class App{public static void main(String [] args){System.out.println("Hello, World");}} //error

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Yukarıdaki iki kural aslında programcının okunabilir/algılanabilir (readable) kodlar yazabilmesini
	sağlar. Bu anlamda şirketlerin kendilerine özgü yazım stillerini içeren kuralları bulunabilir. Bu kurallara 
	İnglizce olarak "coding convention" ya da "code style guide" gibi terimler kullanılabilir. Buradaki yazım stilleri
	şirketten şirkete farklılıklar ya da benzerlikler içerebilir. Burada C ve Sistem Programcıları Derneği'nin 
	yazım stili ile yazılacaktır. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java'da "derleme zamanı (compile time)" ve "çalışma zamanı (run time)" denilen iki önemli kavram vardır.
	Derleme zamanı, derleme sürecine ilişkin işlemlere denir. Çalışma zamanı ise, byte code'un çalıştırılması sürecine 
	ilişkin işlemlere denir. Bu kavramlar birbirleriyle ilişkili olsalar da, ayrı kavramlardır. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	13.08.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Derleyicinin Teşhis Mesajları (Diagnostics):
	1. Gerçek hatalar (Errors): Dilin sentaks ya da semantik kurallarına uyulmamasından dolayı verilen mesajlardır. Bu durumda
	"byte code" üretilmez. Programcının bu hataları düzeltip kodu derlemesi gerekir.

	2. Uyarılar (Warnings): Byte code'un üretimine engel olmayan, olası programlama ve mantık hatalarının bildirilmesi
	için verilen mesajlardır. Programcı bu uyarıları kesinlikle dikkate almalıdır. Özel bir durum yoksa uyarı mesajlarının
	oluşumuna yol açan kodlar düzeltilmeldir. Bazı durumlarda derleyicinin uyarı mesajı vermediği ancak IDE'nin kullandığı
	bir "static kod analizi aracları" konfigürasyonları gereği uyarı verebilir. Bunlar da dikkate alınmalıdır. Ancak hepsinin
	düzeltilmesi gerekmez. Tipik olarak ürün elde edilmesi aşamasında derleyici anlamında hiç bir uyarı mesajının olmaması gerekir.

	3. Ölümcül hatalar (Fatal errors): Derleme işleminin bile tamamlanmasını engelleyen hatalardır. Bu durumda programcının
	yazdığı kod açısından yapacak birşeyi yoktur. Çünkü kod henüz derlenmemiş bile olabilir. Programcının ölümcül hataya 
	yol açan durumu ortadan kaldırması gerekir. Örneğin diskte yer kalmaması, derlenecek dosyanın bulunamaması gibi durumlar
	ölümcül hatalara yol açar

	Programın çalışma zamanı sırasında oluşan hatalı durumlara genel olarak "exception" denir. Exception işlemleri
	ileride "exception handling" isimli bölümde ele alınacaktır. Bu konu ele alınana kadar exception oluştuğunda
	"program sonlanır" olarak anlaşılacaktır. Exception terimi yerine "run time error" da kullanılmaktadır. "error" dendiğinde
	"compile time error" anlaşılır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Program içerisinde derleyicinin görmezden geleceği yazılara "yorum satırları (comment lines)" denir. Java'da iki
	çeşit yorum satırı kullanılmaktadır. Aşağıda örnekleri gösterilmiştir. İç içe yorum satırlarının kullanımında
	dikkatli olunmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

//App sınıfı
class App {
/*
	Burası da 
	derleyici tarafından dikkate alınmayacak
*/
	public static void main(String [] args) 
	{
		
		System.out.println("Hello, World"); //Burası derleyici tarafından dikkate alınmayacak
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programcı yorum satırlarını gereksiz yere ve karışık olarak yazmamalıdır. Gereksiz ve karışık olarak
	yazılmış yorum satırlarının da okunabilirliği/algılanabilirliği olumsuz etkileyebileceği unutulmamalıdır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java'da birden fazla ".java" dosyası ile çalışmanın bir takım ayrıntıları vardır. Bu sebeple 
	paketler konusuna kadar yalnızca tek bir ".java" dosyası (App.java) ile çalışacağız
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programlama dili gibi formal olarak tasarlanmış kavramlar açıklanırken genel biçimlere ilişkin bir 
	takım yöntemler kullanılır. Özellikle bir takım standartlar BNF (Backus Neuer Form) notasyonu kullanırlar. 
	"Java Language Specification (JLS)" içerisinde de büyük ölçüde BNF kullanılmıiştır. BNF görece karmaşık bir yapıya 
	sahiptir. Özellikle başlangıç düzeyinde öğrenmek için kullanılması çok etkin bir yöntem değildir. Bu sebeple biz 
	kursumuzda BNF notasyonu kullanmayacağız. Biz açısal parantez köşeli parantez tekniğini kullanacağız. Bir genel 
	biçimde açısal parantez içerisine alınan bir bilgi zorunlu bir bilgi anlamına gelir, köşeli parantez içerisine 
	alınan bilgi ise seçenekli bir bilgi yani orada olmaya dabilir anlamına gelir. Şüphesiz olması ile olmaması aynı 
	anlamda olmak zorunda değildir. Açısal parantez veya köşeli parantez içerisine alınmamış her bilgi orda olması 
	gereken şeklinde anlamına gelir. Örneğin:
		package <paket ismi>;
	anlatımında package sözcüğü olması ve onu takip eden bir paket ismi bulunmalı anlamındadır. Ayrıca kodlar
	içerisinde //... biçimindeki gösterim de burada bir takım kodlar olabilir ancak şu durumda bizi ilgilendirmiyor
	anlamındadır. Ayrıca son 15 yıldır kaynaklarda (buna JSL de dahil) bir takım konular anlatılırken herhangi bir 
	senaryodan bağımsız olması anlamında isimlendirmede foo, bar, tar, car, zar gibi uydurma isimler kullanılmaktadır.
	Biz de konularımızda bu isimleri kullanacağız.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bildirim (declaration): Bir ismin derleyiciye tanıtılmasıdır. Yani derleyici bir ismin bildirimini arar 
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Bir Java programı genel olarak paketlerden, paketler sınıflardan, sınıflar da metotlardan oluşur. Paket bildiriminin
	genel biçimi şu şekildedir:
		package <paket ismi>;
	Paket ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Örneğin:
		package csd;
	Paket bildirimi tüm diğer bildirimlerden önce yani tipik olarak kaynak kodun tepesinde bulunmalıdır. Bu sebeple bir 
	".java" dosyasında yalnızca bir tane paket bildirimi bulunabilir. Paketler konusu ayrıntılı bir konudur. İleride detaylı 
	olarak ele alınacaktır. Sınıf bildiriminin genel biçimi şu şekildedir:
		[erişim belirleyici] class <sınıf ismi> {
			//...
		}
	Erişim belirleyici dışında başka sözcükler de olabilir. Erişim belirleyici ve diğerleri konular içerisinde ele
	alınacaktır. Sınıf ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Sınıflar konusu da
	oldukça detaylı bir konudur. Neredeyse her konuda sınıflarla ilgili detaylar ele alınacaktır. Örneğin:
		class Sample {
			//...
		}
		
		class Person {
			//...
		}
		
		class SerialPort {
			//...
		}
	Java'da alt programlara metot (method) denir. Bir metodun ne iş yapacağının yani kodlarının yazılmasına 
	metot bildirimi (method declaration), kodlarının çalıştırılmasına ise metot çağrısı (method call) denir. Java'da
	bir metot bir sınıf içerisinde bildirilmek zorundadır. Metot bildiriminin genel biçimi şu şekildedir:
	  [erişim belirleyici] [static] <geri dönüş değeri> <metot ismi>([parametre değişkenleri])
	  {
	  		//...
	  }
	Erişim belirleyici şunlardan biri olabilir: public, protected, no-modifier, private. Burada no-modifier hiç bir şey
	yazmamak anlamındadır. Bu erişim belirleyicilerin hepsi farklı anlamdadır. İlgili konuya gelene kadar bir tüm
	metotlardaki erişim belirleyicileri public yapacağız. Java'da bir metot static veya non-static olarak bildirilebilir.
	Bir metodun bildiriminde static anahtar sözcüğü yazılırsa metot static olur. İlgili konuya gelene kadar tüm metotlarımızı
	static olarak bildireceğiz. Metodun kodlarının yazıldığı bölüme metodun gövdesi (method body) denir. static bir metodu 
	çağırmanın genel biçimi şu şekildedir:
		[paket ismi].[sınıf ismi].<metot ismi>([argümanlar]);
	Bir metot genel olarak başka bir metot içerisinde çağrılabilir. Akış java programına verilen sınıfın main metodundan
	başlar. main metodu bittiğinde akış sonlanır. Bizim bu kursdaki programlarımızda bir tane akış olduğundan main metodu
	bittiğinde program sonlanır. main metodu JVM tarafından akışı başlatmak üzere çağrılır. Bu anlamda akışı başlatmak
	için çağrılan main metoduna "giriş noktası (entry point)" denir. Bir metot çağrıldığında akış metodun kodlarına 
	dallanır ve metodun kodları çalıştırıldıktan sonra akış çağrılan noktaya geri döner. Metodun geri dönüş değeri
	yoksa void anahtar sözcüğü yazılır. Metodun ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir.
	Metodun parametre değişkenleri olabilir. Metodun geri dönüş değeri ve parametre değişkenleri ileride ele
	alınacaktır. Yani aslında bir program main metodun çağrılmasıyla başlar ve bi rçok metodun çağrılması ile devam eder.
	print ve println'de birer metottur. Ancak bu metotlar static metot değildir. Bu sebeple System.out.print veya
	System.out.println çağrıları yukarıdaki biçimden farklıdır. Burada System bir sınıf, out bir referans, print ve prinln de
	birer metot ismidir. Detaylar şu an önemsizdir. Bu iki metot aldıkları yazıyı basarlar. println son yazdığı 
	karakterden sonra bir sonra satıra geçme karakterini de basar
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello World");
		csd.Sample.foo();
		csd.Sample.bar();
		csd.Mample.tar();
		System.out.println("Goodbye World");
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
		csd.Mample.tar();
	}
	
	public static void bar()
	{
		System.out.println("bar");
	}
}

class Mample {
	public static void tar()
	{
		System.out.println("tar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Çağıran metodun (caller) ait olduğu sınıf ile çağrılan metodun (callee) ait olduğu sınıf aynı pakette ise çağrı
	sırasında paket ismi yazılmayabilir. Çağıran metodun ait olduğu sınıf ile çağrılan metodun ait olduğu sınıf aynı ise
	paket ismi yazılmazsa sınıf ismi de yazılmayabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello World");
		Sample.foo();
		Sample.bar();
		Mample.tar();
		System.out.println("Goodbye World");
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
		Mample.tar();		
	}
	
	public static void bar()
	{
		System.out.println("bar");
		foo();
	}
}

class Mample {
	public static void tar()
	{
		System.out.println("tar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	19.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Sayı sistemleri
	Biz 10'luk sistemi (decimal system) kullanmaktayız. 10'luk sistemde sayıları ifade etmek için 10 sembol vardır:

	0
	1
	2
	3
	4
	5
	6
	7
	8
	9

	10'luk sistemde sayının her bir basamağı 10'nun kuvvetleriyle çarpılıp toplanmaktadır. Örneğin:

	123.25 = 3 * 10^0 + 2 * 10^1 + 1 * 10^2 + 2 * 10^-1 + 5 * 10^-2

	Halbuki bilgisayarlar 'lik sistemi (binary system) kullanmaktadır. 2'lik sistemde sayıları ifade etmek için 2 sembol kullanılmaktadır:

	0 
	1

	2'lik sistemde sayının her bir basamağına "bit (binary digit)" denilmektedir. 2'lik sistemde sayının her basamağı 2'nin kuvvetiyle çarpılarak sayı elde edilir.
	Bit en küçük bellek birimidir. 8 bite 1 byte denilmektedir. Genellikle bitler 4'erli gruplanarak yazılırlar. Örneğin:

	1010 0010

	Burada 1 byte'lık bir bilgi vardır. Byte temel bellek birimidir. 

	Byte da küçük bir birimdir. Kile diğer bilimlerde "1000 katı" anlamına gelmektedir. Ancak bilgisayarlar 2'lik sistemi kullandığj için 1000 katı iyi bir
	kat değildir. Bu nedenle genel olarak Kilo byte için 2'nin 102uncu kuvveti olan 1024 kat kullanılır. Yani 1KB (kısaca 1K) 1024 byte'tır. Mega diğer bilimlerde 
	kilonun 1000 katıdır. Dolayısıyla milyan kat anlamına gelmektedir. Ancak bilgisayar bilimlerinde genel olarak mega kilonun 1024 katı olarak alınır. 
	Bu durumda 1 MB = 1020 * 1024 (2^20) KB'dir. Giga ise meganın 1024 katıdır. Bu durumda 1 GB = 1024 * 1024 * 1024 byte'tır ( 2^30). Giga'dan sonra tera, tera'dan sonra 
	peta, ondan sonra da exa gelmektedir. 

	1 byte içerisinde yazılabilecek en küçük ve en büyük sayılar şöyledir:

	0000 0000 ---> 0
	1111 1111 ---> 255

	1 byte içerisinde 1 ve 0'ların bütün permütasyonları 256 tanedir. 2 byte içerisinde en büyük sayıyı yazacak olsak şöyle olurdu:

	1111 1111 1111 1111 ---> 65535

	Biz burada ikilik sistemde tamsayıları ifade ettik. Ama bütün sayıları pozitif kabul ettik. Pekiyi negatif tamsayılar nasıl ifade edilmektedir?

	Bugün negatif sayıların ifade edilmesi için "ikiye tümleyeb (two's complement)" sistemi denilen bir sistem kullanılmaktadır. Bu sistemde pozitif ve 
	negatif sayılar birbirlerinin ikiye tümleyenidirler. ikiye tümleyen bire tümleyene bir eklenerek bulunmaktadır. Bir sayının bire tümleyeni sayıdaki
	o'ların 1, 1'lerin 0 yapılmasıyla bulunur. Bu durumda ikiye tümleyen şöyle hesaplanır. örneğin aşağıdaki sayının ikiye tümleyenini bulmaya çalışalım:

	0101 0110

	Sayının bire tümleyenine bir ekleyeceğiz:

	1010 1001
    0000 0001
    ---------
    1010 1010

	Aslında ikiye tümleyeni bulmanın kolay bir yolu da vardır: Sayıda sağdan sola ilk 1 görene ilk 1 dahil olmak üzere aynısı yazılarak ilerlenir. 
	Sonra 0'lar 1, 1'ler 0 yapılarak devam edilir. Örneğin:

	0101 0110

	sayının ikiye tümleyenini tek hamlede bulalım:

	10101010

	Negatif sayıları ifade edebilmek için kullanılan ikiye tümleme sisteminde en soldaki bit işaret bitidir. Bu bit 0 ise sayı pozitif, 1 ise negatiftir.
	Negatif ve pozitif sayılar birbirlerinin ikiye tümleyenidir. Örneğin bu sistemde +10 yazmak isteyelim. Bunu işaret 0 yaparak yazabiliriz:

	0 000 1010		---> +10

	Şimdi -10 yazmak isteyelim. Bunun için +10'un ikiye tümleyenini alalım:

	1 111 0110       ---> -10

	Bu sistemde +n ile -n toplandığında 0 elde edilir:

	0 000 1010   ---> +10
	1 111 0110   ---> -10
	---------------------
  1	0 000 0000   ---> 0

  	Bu sistemde tek bir sıfır vardır. O da tüm bitleri 0 olan sıfırdır. Bu sistemde 1 byte içerisinde yazılabilecek en büyük pozitif sayı şöyledir:

	0 111 1111    ---> +127

	Şimdi bunun ikiye tümleyenini alalım:

	1 000 0001    ---> -127

	Pekiyi en küçük negatif sayı nedir? Bu sistemde bir tane sıfır olduğuna göre 255 tane permütasyon eşit bölünemez. Demek ki ya pozitif sayılar ya negatif sayılar 
	bir tane daha fazla olmak zorundadır. Bu sistemde ikiye tümleyeni olmayan iki sayı vardır:

	0000 0000 
	1000 0000

	Birincisi 0'dır. İkinci sayı -127'den bir eksik olan sayıdır. O halde bu sayının -128 kabul edilmesi daha uygundur. 

	Demek ki bu sistemde n byte içerisinde yazılabilecek en büyük pozitif sayı ilk biti 0 olan diğer tüm birleri 1 olan sayıdır. En küçük 
	negatif sayı ise ilk biti 1 olan diğer tüm bitleri 0 olan sayıdır. Örneğin bu sistemde iki byte ile yazabileceğimiz en büyük pozitif sayı
	şöyledir:

	0111 1111 1111 1111		---> +32767

	En küçük negatif sayı ise şöyledir:

	1000 0000 0000 000   	---> -32768

	Bu sisteme ilişkin tipik sorular ve yanıtları şöyledir:

	SORU: Bu sistemde +n sayısını nasıl yazarsınız?
	CEVAP: En soldaki bit 0 yapılıp n sayısı 2'lik sistemde yazılır.

	SORU: Bu sistemde -n nasıl yazarsınız?
	CEVAP: Yazabiliyorsanız doğrudan yazın. Ancak doğrudan yazamıyorsanız önce +n değerini yazın ve ikiye tümleyenini alın. Örneğin bu sistemde -1 
	yazalım. Önce +1 yazalım:

	0000 0001   ---> +1

	Şimdi bunun ikiye tümleyenini alalım:

	1111 1111   ----> -1

	SORU: Bu sistemde bir sayının kaç olduğu bize sorulsa bunu nasıl yanıtlarız?
	CEVAP: Eğer en soldaki bit 0 ise sayının değeri doğrudan hesplanır. Eğer en soldaki bit 1 ise bu sayının negatif olduğunu gösterir. Bu durumda 
	sayının ikiye tümleyeni alınır. Pozitifinden hareketle negatifi bulunur. Örneğin 1110 1110 sayısı kaçtır? Burada işaret biti 1 olduğuna göre sayı negatiftir. 
	Negatif ve pozitif sayılar birbirlerinin ikiye tümleyenidirler. O zaman bu sayının ikiye tümleyenini alıp pozitifinden faydalanarak sayıyı bulalım:

	0001 0010  ---> +18

	o zaman bize sorulan sayı -18'dir.

	Bu sistemde örneğin 1 byte içerisinde yazılabilecek en büyük pozitif sayıya 1 toplayalım:

	0111 1111   ---> +127
	1000 0000   ---> -128

	Demek ki bu sistemde bir sayıyı üst limitten taşırırsak yüksek bir negatif sayıyla karşılaırız. Benzer şekilde alt limitten taşırırsak yüksek bir 
	pozitif sayı ile karşılaşırız	 
----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Tamsayılar ikilik sistemde "işaretsiz (unsigned)" ya da "işaretli (signed)" sistemde yorumlanabilirler. İşaretsiz sistemde sayının en soldaki biti
	olarak yorumlanmaz. Sayı herzaman sıfır ya da pozitiftir. İşaretli sistemde ise sayının en solundaki bit işaret bitidir. Sayı ikiye tümleyen aritmetiğine 
	göre yorumlanır.
	 
	İşlemciler aslında genellikle işaretli ve işaretsiz ayırımını yapmazlar. Çünkü bu tür de aslında aynı biçimde işleme sokulmaktadır. Sonucun yorumu değişmektedir. 
----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Pekiyi noktalı sayılar ikilik sistemde nasıl ifade edilmektedir? İşte insanlar noktalı sayıları ifade etmek için iki format geliştirmişlerdir. Bunlardan birine
	"sabit noktalı formatlar (fixed point formats)" diğerine "kayan noktalı formatlar (floating point formats)" denilmektedir. Sabit noktalı formatlar eski 
	devirlerde basit bir mantıkla tasarlanmıştır. Bu formatlar bugün hala kullanılıyor olsa da büyük ölçüde artık bunların çağı kapanmıştır. Bugün kayan noktalı
	format denilen formatlar kullanılmaktadır. 

	Sabit noktalı formatlarda noktalı sayı için n byte yer ayrılır. Noktanın yeri önceden bellidir. Örneğin sayı 4 byte ile ifade edilsin. 
	Noktanın yeri de tam ortada olsun. Bu durumda syının tam kısmı 2 byte ile noktalı kısmı 2 byte ile ifade edilir. Ancak sayının noktalı kısmı 2'nin
	negatif kuvvetleriyle kodlanmaktadır. VBöylece iki sabit noktalı sayıyı paralel toplayıcılarla kolay bir biçimde toplayabiliriz: Örneğin bu sistemde 
	5.25 ile 6.25 sayılarını ifade edip toplayalım:

	0000 0000 0000 0101 . 0100 0000 0000 0000    ---> 5.25
	0000 0000 0000 0110 . 0100 0000 0000 0000    ---> 6.25
	-------------------------------------------------------
	0000 0000 0000 1011 . 1000 0000 0000 0000    ---> 11.5

	Pekiyi bu yöntemin ne dezavantajı vardır? Yöntemin en önemli dezavantajı dinamik olmamasıdır. 

----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Sabit noktalı formatların dinamik olmaması nedeniyle kayan noktalşı formatlar geliştirilmiştir. Bu formatlarda noktanın yeri sabit değildir. 
	Noktanın yeri format içerisinde ayrıca tutulmaktadır. Noktalı sayının noktası yokmuş gibi ifade edilmesi durumunda sayının bu haline "mantis (mantissa)" 
	denilmektedir. İşte kayan formatlarda sayı için ayrılan alanın bir bölümünde manris bir bölümünde de "noktanın yeri" tutulmaktadır. Noktanın yerini belirleyen
	kısma "üstel kısım (exponential part)" denilmektedir. Tabii bir de sayının başında işaret biti bulunur. Bu durumda kayan noktalı bir sayının format aşağıdakine benzerdir:

	[işaret biti] [mantis] [noktanın yeri (exponential)]

	Bugün ağırlıklı kullanılan kayan noktalı format IEEE 754 denilen formattır. Bu formatın üç farklı genişlikte biçimi vardır:

	IEEE 754 - Short Real Format (4 byte)
	IEEE 754 - Long Real Format (8 byte)
	IEEE 754 - Extended Real Format (10 byte)
	
	Bugün Intel, ARM, MIPS, Alpha, Power PC gibi yaygın işlemciler donanımsal olarak bu formatı desteklemektedir. Aynı zamanda bu format yaygın olarak Reel Sayı Ünitesi
	olmayan mikrodenetleyicilerdeki derleyiciler tarafından da kullanılmaktadır.

	Kayan noktalı formatların (örneğin IEEE 754 formatının) en ilginç ve problemli tarafı "yuvarlama hatası (rounding error)" denilen durumdur. Yuvarlama hatası
	noktalı sayının tam olarak ifade edilemeyip onun yerine ona yakın bir sayının ifade edilmesiyle oluşan hatadır. Yuvarlama hatası sayıyı ilk kez depolarken de 
	oluşabilir, aritmetik işlemlerin sonucunda da oluşabilir. Tabii noktalı sayıların bir bölümü bu formatta hiçbir yuvarlama hatasına maruz kalmadan ifade edilebilmektedir. 
	Ancak bazı sayılarda bu hata oluşabilmektedir. Bu hatayı ortadan kaldırmanın yolu yoktur. Tabii sayı için daha fazla bir ayrılırsa yuvarlama hatasının etkisi de 
	azalacaktır. 

	Yuvarlama hatalarından dolayı programlama dillerinde iki noktalı sayının tam eşitliğinin karşılaştırılması anlamlı değildir. Örneğin aşağıdaki işlemde
	yuvarlama hatasından dolayı sayılar sanki eşit değişmiş gibi ele alınacaktır.  

	0.2 + 0.1 == 0.3 (false)
	
	Pekiyi yuvarlama hatasının önemli olduüu ve bunun istenmediği tarzda uygulamalarda (örneğin finansal uygulamalarda, bilimsel birtakım uygulamalarda)
	ne yapak gerekir? İşte bunun tek yolu noktalı sayıları kayan noktalı formatta tutmamak olabilir. Bazı programlama dillerinde noktalı sayıyı 
	kayan noktalı formatta tutmayan böylece yuvarlama hatalarına maruz bırkmayan özel türler (örneğin C#'taki decimal) vardır. Ancak bu türler işlemciler tarafından 
	desteklenmediği için yapay türlerdir. 

----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Yazılar da aslında bilgisayar belleğinde 2'lik sistemde sayılar biçiminde tutulmaktadır. Bir yazıyı oluşturan elemanlara "karakter" denilmektedir. İşte
	bir yazıda her bir karakter 2'lik sistemde bir sayı ile ifade edilir. Böylece yazı aslında ikilik sistemde bir sayı dizisi gibi tutulmaktadır. İşte
	bir karakter için hangi sayının karşı geldiğini belirten tablolara "karakter tabloları" denilmektedir. Karakter tablosundaki karakter şekillerine "glyph"
	denilmektedir. Her karaktere tabloda bir sıra numarası verilmiştir. Buna da "code point" denilmektedir. Dünyanın ilk standart karakter tablosu "ASCII (American
	Standard Code Information Interchange)" denilen tablodur. ASCII tablosu aslında 7 bit bir tablodur. Dolayısıyla tabloda 128 tane glyph için code point
	bulundurulmuştur. ASCII dışında IBM EBCDIC tablosunu geliştirmiştir. Wang firması WISCII tablosunu kullanmıştır. ASCII tablosu Amerikalılar tarafından yalnızca İngilizce
	karakterleri ifade etmek için oluşturulmuştur. Bilgisayarlar yaygınlaşmaya başladığında farklı karakterlere sahip olan Türkiye gibi, Yunanistan gibi, Almanya gibi
	ülkeler bu ASCII tablosunu 8 bite çıkartıp elde edilen 128'lik yeni alanı kendi karakterlerini ifade etmek için kullanmışlardır. ASCII tablosunun ilk yarısı 
	(yani [0, 128] numaraları karakterleri) standarttır. Ancak ikinci yarısı "code page" adı altında farklı ülkeler tarafından farklı yerleşimler yapılarak kullanılmaktadır. 
	DOS zamanlarında Türkçe karakterler için OEM 857 denilen code page kullanılıyordu. Daha sonra Microsoft Windows sistemlerinde Türkçe karakterler için 1254 code page'i
	düzenledi. ISO, bu code page'leri standart hale getirmiştir. Bugün Türkçe karakterler ISO tarafından ASCII 8859-9 Code page'i ile düzenlenmiştir.

	ASCII tablosu ve onların code page'leri uzun süre kullanılmış ve hala kullanılmakta olsa da maalesef karışıklıklara yol açmaktadır. İşte son 20 yıldır
	artık karakterleri 2 byte içerisinde ifade ederek dünyanın bütün dillerinin ve ortak sembollerinin tek bir tabloya yerleştirilmesi ile ismine UNICODE 
	denilen bir tablo oluşturulmuştur (www-unicode.org). UNICODE tablo ISO tarafından 10646 ismiyle de bazı farklılıklarla standardize edilmiştir. UNICODE tablonun
	ilk 128 karakteri standart ASCII karakterleri, ikinci 128 karakteri ISO 8859-9 code page'indeki karakterlerdir. 

	Bir karakter tablosundaki code point'lerin ikilik sistemde ifade edilme biçimine "encoding" denilmektedir. ASCII code page'lerinde encoding doğrudan 
	code point'in 1 byte'lık sayı karşılığıdır. Ancak UNICODE tablonun değişik encoding'leri kullanılmaktadır. UNICODE tablonun klasik encoding'i UTF-16'dır. 
	Burada code point doğrudan 16 bir bir sayı biçiminde ifade edilir. UTF-32 encoding'inde ise code point 32 bitlik bir sayı biçiminde ifade edilmektedir. 
	Ancak UNICODE tablonun en yaygın kullanılan encoding'i UTF-8 encoding'idir. UTF-8 kodlamasında standart ASCII karakterler 1 byte ile, diğer karakterler 
	2 byte, 3 byte, 4 byte ve 5 byte kodlanabilmekedir. Türkçe karakterler UTF-8 encoding'inde 2 byte yer kaplamaktadr. UTF-8 encoding'i UNICODE bir yazının 
	adeta sıkıştırılmış bir hali gibi düşünülebilir. 

	Bugün pek çok programlama editörleri default durumda dosyayı UNICODE UTF-8 encoding'ine göre saklamaktadır.
----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Bilgisayar dünyasında çok kullanılan diğer bir sayı sistemi de 16'lık sistemdir. 16'lık sisteme İngilizce "hexadecimal system" denilmektedir. 16'lık 
	sistemde syaıları ifade etmek için 16 sembol bulunmaktadır. İlk 10 sembol 10'luk sistemdeki sembollerden alınmıştır. Sonraki 6 sembol alfabetik karakterlerden alınmıştır:

	0
	1
	2
	3
	4
	5
	6
	7
	8
	9
	A
	B
	C
	D
	E
	F

	16'lık sistemdeki her bir basamağa "hex digit" denilmektedir. Örneğin:

	1FC8

	Burada 4 hex digit'lik bir sayı vardır. 16'lık sistemdeki bir sayıyı 10'luk sisteme dönüştürmek için her hex digit 16'lık kuvvetleriyle çarpılıp toplanır. 
	Ancak 16'lık sistemdeki sayı kullanım gereği bakımından aslında 10'lu sisteme pek dönüştürülmez. 16'lık sistemdeki her bir hex digit 4 bit ile ifade edilebilmektedir:

	0		0000
	1		0001
	2		0010
	3		0011
	4		0100
	5		0101
	6		0110
	7		0111
	8		1000
	9		1001
	A		1010
	B 		1011
	C 		1100
	D 		1101
	E 		1110
	F       1111

	16'lık sistemden 2'lik sisteme dönüştürme yapmak çok kolaydır. Tek yapılacak şey bir hex digit'e karşılık yandaki tablodaki 4 biti getirmektir. Örneğin:

	1FC9  =  0001 1111 1100 1001
	FA3D  =  1111 1010 0011 1101

	2'lik sistemdeki bir sayı da 16'lık sisteme çok kolay dönüştürülür. Tek yapılacak şey sayıyı dörderli gruplayıp ona karşı gelen hex digit'i yazmaktır. Örneğin:

	1010 0001 1110 1000 0011 0101 = A1E835

	Bilgisayar dünyasında 162lık sistem aslında 2'lik sistemin yoğun bir gösterimi olarak kullanılmaktadır. Yani 2'lik sistem çok yer kapladığı için kişiler
	2'lik sistem yerine 16'lık sistemi kullanırlar. Bu nedenle belleği, dosyayı gösteren programlar bunları 2'lik sistem yerine 16'lık sistemde gösterirler. 

	1 byte 2 hex digit ile ifade edilmektedir. Örneğin:

	1A 23 5C 78

	Burada 4 byte'lık bir bilgi vardır. Örneğin 2 byte içerisinde yazılabilecek en küçük negatif işaretli sayının hex karşılığı 8000 biçimindedir. Örneğin
	bir byte'lık işaretli sistemde yazılabilecek en büyük pozitif sayı 7F biçimindedir. İşareti tamsayı sisteminde 4 byte içerisinde -1 sayısı FFFFFFFF 
	biçimindedir. 

----------------------------------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------------------------------
	Eskiden daha fazla kullanılıyor olsa da toplamda oldukça seyrek kullanılan diğer bir sayı sistemi de 8'lik sayı sistemidir. Bu sisteme İngilizce 
	"octal system" denilmektedir. 8'lik sayı sistemindeki her bir basamağa "octal digit" denir. Octal digit sembolleri olarak 10'luk sistemin ilk 8 sembolü 
	kullanılmaktadır:

	0
	1
	2
	3
	4
	5
	6
	7

	Her octal digit 3 bir ile ifade edilebilir:

	0	000
	1	001
	2	010
	3	011
	4	100
	5	101
	6	110
	7	111

	Bu durumda bir octal sayı 2'lik sisteme kolay bir biçimde dönüştürülebilir:

	476		100 111 110
	741		111	100	001

	Benzer biçimde 2'lik sistemdeki bir sayı da sağdan sola üçer bir gruplandırılarak 8'lik sisteme dönüştürülebilmektedir. Örneğin:

	1011 1011	=  273
	0111 1110	=  176

	8'lik sistem de 2'lik sistemin yoğun bir gösterimi olarak kullanılmaktadır. Ancak 8'i tam ortalayamadığı için kullanımı seyrektir. 
----------------------------------------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Tür (type): Bir değişkenin içerisindeki değerin hangi formatta tutulduğunu ve bellekte ne kadar uzunlukta (byte) yer
	ayrılacağını belirtir. Java'da türler temel türler (primitive/built-in/predefined types) ve programcının tanımladığı
	türler (user defined types) olmak üzere iki gruba ayrılabilir. Programcının tanımladığı türler ileride ele alınacaktır.
	Temel türler birer anahtar sözcük olarak temsil edilmektedir. Java'nın tamel türleri şunlardır:
	
	   Tür ismi            Uzunluk (byte)            Sınır Değerler
	   short                 2                    	[-32768, +32767]
	   int                   4                    	[-2147483648, +2147483647]  
	   long                  8                    	[-9223372036854775808, +9223372036854775807]
	   byte                  1                    	[-128, +127]
	
	   float                 4                    	[±3.6 * 10-38, ±3.6 * 10+38]
	   double                8                    	[±1.6 * 10-308, ±1.6 * 10+308]
	
	   char                  2                    	[0, 65535]
	   boolean               -                    	true, false
	
	Temel türlere ilişkin özellikler:
	- Temel türler genel olarak tamsayı türleri (integer/integral types), gerçek sayı türleri (real types) ve özel amaçlı
	türler olarak ayrılabilir. 
	
	- Tamsayı türlerinde işaretli (signed) sistemde, 2'ye yöntemi kullanılır.
	
	- Gerçek sayı türleri IEEE 754 formatına göre çalışırlar. Bu formatta yuvarlama hataları (rounding error) oluşabilir. 
	double türü "çift hassasiyetli (double precision)", float türü ise "tek hassasiyetli (single precision)" olarak çalışırlar.
	Bu kavramlar IEEE 754 standardına ilişkindir. Burada bilinmesi gereken yuvarlama hatalarının oluşabileceği ve double
	türünün, float türüne göre daha az yuvarlanacağıdır. Yani float türünün yuvarlamaya karşı direnci, double türüne göre daha
	zayıftır. Yuvarlama hataları, bir işlemin sonucunda oluşabileceği gibi bir değer yerleştirilirken de olabilir.
	
	- Gerçek sayılardaki yuvarlama hatası, IEEE 754 standardının yöntemidir. Hatalı bir çalışma değildir. Programcı 
	bu yuvarlama hatalarının problem oluşturabileceği (örneğin parasal ve finansal uygulamalar) uygulamalarda bu türleri
	kullanmaz. Böyle bir durumda hangi türün kullanılacağı ileride ele alınacaktır. Böylesi bir durum dışında yani yuvarlama
	hatalarının öneminin olmadığı uygulamalarda bu türler kullanılır. Çünkü, yuvarlama hatası yapılmamasını sağlayan
	yöntemlerde yüzlerce makine komutunun kullanıldığı yerde, IEEE 754 ile bu tek bir makine komutuyla yapılabilir.
	
	- char türü Java'da UNICODE tablo dikkate alınarak belirlenmiştir. Bu nedenle char türü 2 byte'dır. char türden 
	bir değişken içerisinde tutulan sayı UNICODE tabloda bir sıra numarası anlamına gelir. Dolayısıyla mantıksal olarak
	char türü içerisinde bir karakter tutulmuş olur.
	
	- boolean türünün alabileceği 2 tane değer vardır: true, false. boolean türünün uzunluğu JLS'de belirtilmemiştir.
	Sistemden sisteme değişebilir. Ancak bunu bir önemi yoktur.
	
	Anahtar Notlar: Java'da boolean türü dışında kalan temel türlerin uzunlukları her sistemde aynıdır.
	
	Anahtar Notlar: int türüne "integer" demek yanlış bir tanım kullanmak demektir. integer kavramı tam sayılara verilen
	genel bir isimdir. int ise 4 byte'lık bir tamsayı türüdür. Ayrıca JavaSE'de Integer isimli önemli bir sınıf da 
	bulunmaktadır
	
	Anahtar Notlar: Java'da en çok kullanılan tamsayı türü int'dir, en çok kullanılan gerçek sayı türü de double'dır. 
	Programcı öncelikle bu türleri düşünmeli. Bu türler gereksinimi karşılamıyorsa (ki karşılamadığı da bir çok senaryo
	mevcuttur) diğer türleri düşünmelidir. Bu anlamda int ve double türüne "default types" da denilmektedir	
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği çalıştırıp yuvarlama hatasını gözlemleyiniz. Kodların detayları şu an önemsizdir. Yalnızca yuvarlama
	hatasına odaklanınız	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		double a = 0.1, b = 0.2;
		double c;
		
		c = a + b;
		
		System.out.printf("a = %.20f%n", a);
		System.out.printf("b = %.20f%n", b);		
		System.out.printf("c = %.20f%n", c);
		
		if (c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği çalıştırıp yuvarlama hatalarını gözlemleyiniz. Kodların detayları şu an önemsizdir. Yalnızca yuvarlama
	hatasına odaklanınız	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 0.1F, b = 0.2F;
		float c;
		
		c = a + b;
		
		System.out.printf("a = %.20f%n", a);
		System.out.printf("b = %.20f%n", b);
		System.out.printf("c = %.20f%n", c);
		
		if (c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	20.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da bir değişken kullanılmadan önce bildirilmelidir. Değişken bildiriminin genel biçimi şu şekildedir:
		<tür> <ismi>;
	Örnek:
		int a;
		double b;
		
	Java'da 3 çeşit değişken vardır:
	1. Yerel değişken (local variable)
	2. Parametre değişkeni (parameter variable)
	3. Sınıf veri elemanı (class member variable)
	
	Değişkene ait için temel kavramlar:
	Tür (type): Bellekte ne kadar ayrılacağını ve o alanda bilginin hangi formatta tutulacağını belirtir.
	
	İsim (name): Belirli kurallara göre yazılabilen karakter topluluğudur.
	
	Faaliyet Alanı (scope): Değişken isminin görülebildiği (bilindiği) kod aralığıdır. Derleme zamanına ilişkin
	bir bilgidir.
	
	Ömür (storage duration): Bir değişkenin bellekte yaratılması ile yok edilmesi arasındaki süredir. Çalışma zamanına
	ilişkin bir bilgidir. İleride ele alınacaktır
	
	Anahtar Notlar: Değişken (variable) terimi değişken atomlar için de kullanılmaktadır. Burada değişken bellekte
	yer ayrılan ve içerisinde değer tutabilen atomlardır. Yani burada ele alından değişken de bir değişken atomdur. Ancak
	her değişken atom burada ele alınan değişken değildir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun içerisinde { ile } arasında kalan bölgeye bu küme parantezleri ile birlikte blok (block) denir. Aslında 
	metodun gövdesi de bir bloktur. Metot içerisinde istenildiği kadar içiçe veya ayrık bloklar olabilir. Bu anlamda 
	örneğin sınıf bildirimindeki {}'leri blok değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		{
			//...
			{
				//...
			}
		}
		
		{
			//...
			{
				//...
				{
					//...
				}
			}
		}
	}
}

class Sample {
	public static void foo() 
	{
		{
			//...			
		}
		
		{
			//...
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir blok içerisinde herhangi bir yerde bildirilen değişkenlere yerel değişkenler (local variables) denir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.println("Hello, World");
		int a;
		double b;
		
		{
			boolean flag;
			//...
		}
	}
}

class Sample {
	public static void foo() 
	{
		int x;
		double y;
		
		{
			float z;
			//...
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yerel bir değişkenin faaliyet alanı (scope), bildirildiği yerden bildirildiği bloğun sonuna kadardır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a;
		
		{
			a = 10;
			int x;
			
			x = 10;
		}
		
		x = 20; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aynı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a;
		boolean a; //error
		
		{			
			float a; //error			
			
		}		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Farklı faaliyet alanlarında aynı isimde yerel değişken bildirimi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		{
			int a;
			
			a = 10;
						
		}	
		
		{
			int a;
			
			a = 20;
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Farklı faaliyet alanlarında aynı isimde yerel değişken bildirimi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		{
			int a;
			
			a = 10;
		}
		
		int a;
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Farklı faaliyet alanlarında aynı isimde yerel değişken bildirimi yapılabilir. Aşağıdaki örnekte her iki metotta da
	count isimde yerel değişken bildirimi olabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo()
	{
		int count;
		
		//...		
	}
	
	
	public static void bar()
	{
		int count;
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Aslında ekrana basmak ve klavyeden okuma kavramları JLS'de doğrudan bu şekilde belirtilmemiştir.
	print ve println metotları aslında "standard output (stdout)" denilen bir dosyaya yazma yaparlar. Bu anlamda klavyeden 
	bilgi okuyan metotlar da "standard input (stdin)" denilen bir dosyadan okuma yaparlar. Ancak, bu dosyalar çeşitli
	sistemlerde belli aygıtlara yönlendirilmiştir. Örneğin klasik masaüstü işletim sistemlerinde tipik olarak stdout ekrana,
	stdin de klavyeye yönlendirilmiştir. Biz kursumuzda ekran ve kalvye terimlerini kullanacağız
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	print ve println metotları bir değişkenin değerini ekrana yazabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a;
		
		a = 10;
		
		System.out.println(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir değişkene bildirim noktasında değer verilmesine "ilkdeğer verme (initialization)" denir. Bir değişkene bildirildikten
	sonra yapılan atama işlemi teknik olarak "initialization" ile aynı anlamda değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{		
		int a = 10; //initialization
		int b;
		
		b = 20; //assignment
		
		System.out.println(a);
		System.out.println(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Programlamda, çeşitli sebeplerden dolayı artık kullanılması önerilmeyen durumlarda "deprecated"
	terimi kullanılır. Deprecated olmanın bir çok sebebi olabilir. Bu, neyin deprecated olduğu ile ilgilidir. Deprecated
	olan durumlar gerelçeleri ve yerine kullanılacakları ile birlikte dokümante edilir. Deprecated durumlarda derleyici
	uyarı mesajı verir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Değişken isimlendirme kuralları:
	Bu kurallar Java'da tüm değişken atomlar için geçerlidir.
	
	- Değişken isimleri sayısal bir karakter ile başlatılamaz. Uygun bir karakter ile başlatılıp istenildiği kadar 
	sayısal karakter kullanılabilir.
	
	- Değişken ismi alfabetik bir karakter ile başlatılabilir.
	
	- Değişken isminde _ karakteri kullanılabilir. Hatta değişken ismi _ karakteri ile başlatılabilir.
	
	- Java 8 ile birlikte _ karakterinin tek başına kullanılması deprecated olmuştur. Java 9 ile birlikte de artık 
	geçersiz duruma gelmiştir.
	
	- Anahtar sözcükler tek başına değişken ismi olarak kullanılamaz. Java'ya daha sonra eklenen ancak kullanımına göre
	anahtar sözcük gibi işlem gören bazı özel atomlar vardır. Bunlar doğrudan değişken ismi olarak kullanılabilirler. Bu
	tarz atomlara programlamada "contextual keyword" de denilmektedir.
	
	- Değişken isimlerinde whitespace karakterler kullanılamaz.
	
	- Değişken isimlendirmede UNICODE karakterler kullanılabilir. Örneğin, Türkçe karakterler geçerlidir. Her ne kadar 
	kullanılabiliyor olsa da, değişken isimlendirmede İngilizce alfabedeki karakter dışında karakter kullanmayacağız. Hatta
	değişken isimlerinde geçen kelimeleri de İngilizce dışında kelimeler olarak kullanmayacağız.
	
	- Değişken isimlendirmede $ karakteri kullanılabilir. Dolar karakteri tek başına kullanılabilir, değişken ismi $
	karakteri ile başlatılabilir. Ancak programcı hiç bir zaman değişken isimlendirmede $ karakterini kullanmamalıdır.
	Derleyici bazı durumlarda bir takım isimler vermek zorunda kalabilir. İşte $ karakteri bu tip durumlarda isim çakışmasını
	engellemek için düşünülmüştür. Programcı bu karakteri kullanmazsa, derleyici de ürettiği isimlerde bu karakteri için
	herhangi bir isim çakışması oluşmaz.
	
	- Değişken isimleri büyük-küçük harf duyarlıdır (case sensitive). Aslında Java case sensitive bir dildir.
	
	- JLS'de değişken isimlerinin uzunluğu (karakter sayısı) konusunda bir üst sınır belirtilmemiştir. Ancak pratikte
	kullanılan uzunluklar açısından bir problem yoktur. 
	
	- Değişken isimlerinde bazı teknikler kullanılabilir. Zaman içerisinde bu teknikler anlatılacak ve hangi durumlarda
	hangisinin kullanıldığı anlaşılacaktır. Örneğin programcı Java'da sınıf isimlerini büyük harf ile başlatır, birden 
	fazla kelimeden oluşuyorsa tüm kelimeler bitişik,  tüm kelimelerin baş harfleri büyük ve geri kalan karakterler
	küçük olacak şekilde isimlendirme yapılır. Bu stile "upper camel case veya pascal case" denilmektedir.
	
	- Değişken isimleri kolay telaffuz edilebilir, yeterince uzunlukta ve anlamlı olmalıdır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Java'da klavyeden (aslında stdin'den değil mi?) değer okumak için pek çok yöntem bulunmaktadır. Burada kullanacağımız
	yöntemde bazı ayrıntılar ileride anlaşılacaktır. Bu sebeple şu an bazı detaylar göz ardı edilmelidir. Bir kalıp
	biçiminde düşünülebilir. Ayrıca bu kalıpta bazı uyarı mesajları oluşabilir. Bunlar da şu aşamada önemsizdir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden int türden değerler okunması. Aşağıdaki kalıpta her bir değer girildiğinde ENTER karakterine basılmaldır.
	Geçersiz bir giriş durumunda exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());
				
		int total;
		
		total = a + b;
		
		
		System.out.println(total);			
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden int türden değerler okunması. Aşağıdaki kalıpta sayılar aralarında herhangi bir whitespace karakter ile
	girilebilir. Yine geçersiz değerler için exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int total;
		
		total = a + b;
		
		
		System.out.println(total);			
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden double türden değerler okunması. Aşağıdaki kalıpta her bir değer girildiğinde ENTER karakterine basılmaldır.
	Geçersiz bir giriş durumunda exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayıyı giriniz:");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		double b = Double.parseDouble(kb.nextLine());
				
		double total;
		
		total = a + b;
		
		System.out.println(total);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden double türden değerler okunması. Aşağıdaki kalıpta sayılar aralarında herhangi bir whitespace karakter ile
	girilebilir. Yine geçersiz değerler için exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();		
		double total;
		
		total = a + b;
		
		System.out.println(total);			
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: double ve float türleri için klavyeden girişleride nokta veya virgül kullanımı sistemden sisteme ve 
	kullanılan kalıba göre değişiklik gösterebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden long türden değerler okunması. Aşağıdaki kalıpta her bir değer girildiğinde ENTER karakterine basılmaldır.
	Geçersiz bir giriş durumunda exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayıyı giriniz:");
		long a = Long.parseLong(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		long b = Long.parseLong(kb.nextLine());
				
		long total;
		
		total = a + b;
		
		
		System.out.println(total);			
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Klavyeden long türden değerler okunması. Aşağıdaki kalıpta sayılar aralarında herhangi bir whitespace karakter ile
	girilebilir. Yine geçersiz değerler için exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		long a = kb.nextLong();
		long b = kb.nextLong();		
		long total;
		
		total = a + b;
		
		System.out.println(total);			
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İfade (expression): Sabitlerden, operatörlerden ve değişkenlerden oluşan herhangi bir geçerli dizilimdir. Değişkenler
	ve sabitler tek başına ifade olabilirken, operatörler tek başına ifade olamazlar. Her ifadenin bir değeri vardır. İfade
	hesaplandığında elde edilir. Bu durumun tek bir istisnası vardır. İleride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri bilgisi yerine bir tür ismi yazıldığında o metot o türe geri dönmüş olur. Bir metodun 
	geri dönüş değeri varsa çağrılan noktaya bir değer ile geri döner. Bu değer bir işleme sokulabilir. Bir metodun
	geri dönüş değeri return deyimi ile oluşturulur. return deyiminin genel biçimi şu şekildedir:
	
		return [ifade];
		
	return deyimi nasıl kullanılırsa kullanılsın temel görevi metodu sonlandırmaktır. Yani akış return deyimine geldiğinde
	metot sonlanır. Eğer return ifade ile kullanılırsa (ki geri dönüş değeri olan metotlarda bu zorunludur) ifadenin değerine
	geri döner
	
	Anahtar Notlar: ** ile belirtilen kodda önce add metodu çağrılır. Bu durum operatör önceliği (operator precedence)
	konusu ile ilgilidir. İleride detaylı olarak ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int result;
		
		result = NumberUtil.add() * 2; //**
		
		System.out.println(result);
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		int total = a + b;
		
		return total;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Akış return deyimine geldiğinde önce return deyimine ilişkin ifade hesaplanır, elde edilen değere geri dönülür
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int result;
		
		result = NumberUtil.add() * 2;
		
		System.out.println(result);
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlarda return tek başına kullanılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		return; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlarda akışın her noktasında geri dönülen bir değer söz konusu olmalıdır. Aksi durumda
	error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlarda akışın her noktasında geri dönülen bir değer söz konusu olmalıdır. Aksi durumda
	error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		if (a > b)
			return a + b;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java derleyicisi akışın herhangi bir noktaya kesinlikle gelemeyeceğini anladığında genel olarak 
	error oluşturur. Bu tip kod parçalarına "unreachable codes" da denilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		return a + b;
		System.out.println("Unreachable code"); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	26.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri geçici değişken (temporary variable) yaratılarak iletilir. Geçici değişken, metodun geri dönüş 
	değerinin türündendir. Aşağıdaki örnekte ** ile belirtilen kod parçasında add metodunun geri dönüş değerinin iletimi 
	ve işleme sokuluşuna ilişkin yaklaşık kodlar şu şekildedir:
		int temp = a + b;
		
		result = temp * 2;
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int result;
		
		result = NumberUtil.add() * 2; //**
		
		System.out.println(result);
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş değeri olan metotlar, geri dönüş değeri yokmuş gibi çağrılabilir. Yani geri dönüş değeri bir işleme sokulmayabilir.
	Şüphesiz metodun da buna uygun olarak yazılmış olması gerekir. Aşağıdaki add metodu toplam değerini ekrana basmasaydı
	örnekteki çağrının bir anlamı olur muydu?
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		NumberUtil.add();
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result = a + b;
		
		System.out.println(result);
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun geri dönüş değeri, başka bir metodun geri dönüş olabilir. Bu durum aslında şu kuralın bir sonucudur:
	akış return deyimine geldiğinde, return deyimine ilişkin ifade önce hesaplanır, elde edilen değere geri dönülür
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int total = Sample.getTotal();
		
		System.out.println(total);
	}
}

class Sample {
	public static int getTotal()
	{
		System.out.println("getTotal");
		
		return NumberUtil.add();
	}
}

class NumberUtil {
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result = a + b;		
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Geri dönüş olmayan metotların, geri dönüş değeri bilgisi void anahtar ile yazılır. Geri dönüş değeri bilgisi yerine
	hiç bir şey yazılmaması error oluşturur. Geri dönüş değeri olmayan metotlarda return deyimi zorunlu değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		NumberUtil.printAdd();
	}
}


class NumberUtil {
	public static void printAdd()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int result = a + b;
		
		System.out.println(result);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Geri dönüş değeri olmayan metotlara "void metot (void method)" da denilmektedir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	void metotlarda return deyimi istenirse metodu sonlandırmak için tek başına (yani ifade olmadan) kullanılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		NumberUtil.printAdd();
	}
}


class NumberUtil {
	public static void printAdd()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int result = a + b;
		
		if (result < 0) {
			System.out.println("Sonuç negatif elde edildi");
			return;
		}
		
		//...
		System.out.println(result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	void metotlarda return deyiminin ifade ile kullanımı error oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class NumberUtil {
	public static void printAdd()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int result = a + b;
		
		if (result < 0) {
			System.out.println("Sonuç negatif elde edildi");
			return a + b; //error
		}
		
		//...
		System.out.println(result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	void metotlar geri dönüş değeri varmış gibi çağrılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		int result = NumberUtil.printAdd() * 2; //error
		
		//...
	}
}


class NumberUtil {
	public static void printAdd()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();		
		int result = a + b;		
		
		//...
		
		System.out.println(result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Anımsanacağı gibi her ifadenin bir türü vardır. Yani her ifade hesaplandıktan sonra bir değer
	üretir. Ancak void bir ifadenin (void expression) değeri olmaz. void ifade, void metot çağrısına ilişkin ifadedir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Metoların parametre değişkenleri: Metot bildiriminde parantezler arasında bildirilen değişkenlere denir. Metot 
	parametre değişkenlerinin faaliyet alanı (scope) metot boyuncadır. Bu anlamda faaliyet alanı bakımından metodun 
	başında bildirilmiş yerel değişkenler gibidir. Metot çağrısında, metodun parametrelerine geçilen ifadelere 
	argüman (argument) denir. Bir metodun kaç tane parametresi varsa o kadar sayıda argüman ile çağrılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		double b = kb.nextDouble();
		
		Sample.foo(a, b);
	}
}


class Sample {	
	public static void foo(int a, double b)
	{		
		System.out.println(a);
		System.out.println(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Parametre değişkenleri aynı türden bile olsa bildirimde tür yazılmalıdır. Aksi durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {	
	public static void foo(int a, b) //error
	{		
		System.out.println(a);
		System.out.println(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metoda geçilen argümanlara ilişkin ifadeler önce hesaplanır, elde edilen değerler ilgili parametre değişkenlerine
	aktarılarak metot çağrılır. Yani aslında aşağıdaki örnekte foo metoduna argüman olarak geçilen değerler ilgili ifadelerin
	değerleridir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		Sample.foo(a + 1, b * 3);		
	}
}


class Sample {	
	public static void foo(int a, int b)
	{		
		System.out.println(a);
		System.out.println(b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte add metodunun geri dönüş değeri println metoduna argüman olarak geçilmiştir. Bu da aslında bir önceki
	kuralın bir sonucudur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	
		System.out.println(NumberUtil.add(a, b));
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {	
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	
		System.out.println(NumberUtil.add(a + 2, b * 3));
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Yukarıdaki gibi ifadelerin yazımında okunabilirlik/algılanabilirlik olumsuz yönde etkileniyorsa,
	compact yazım tercih edilmemelidir. Ya da başka bir deyişle compact ifadeler okunabilir/algılanabilir olması 
	durumunda yazılmalıdır. 	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ** ile *** arasındaki kodlarda a ve b değişkenlerinin değerleri değişmediğinden add metodu iki
	defa gereksiz yere çağrılmıştır. Çünkü her iki durumda da aynı sonuç elde edilecektir. Bu durumda metodun gereksiz
	yere çağrılması maliyeti dışında, kodun okunabilirliği açısından da olumsuz bir durum söz konusudur. Çünkü bu kodu 
	okuyan kişi, add çağrısını iki kere gördüğünde ** ve *** arasındaki kodlarda a ve/veya b değişkenlerinin değerlerinin
	değiştiğini algılar.  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	
		System.out.println(NumberUtil.add(a, b)); //**
		
		//... (a ve b değişkenlerinin değerleri burada değiştirilmiyor)
		
		System.out.println(NumberUtil.add(a, b)); //***
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki demo aşağıdaki gibi daha okunabilir/algılanabilir ve görece daha az maliyetli olarak yazılabilir  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
	
		int result = NumberUtil.add(a, b);
		
		System.out.println(result); //**
		
		//... (a ve b değişkenlerinin değerleri burada değiştirilmiyor)
		
		System.out.println(result); //***
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ** ile belirtilen kod parçasında add metodu yeni a değeri için de çağrılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki tane sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();	
		
		System.out.println(NumberUtil.add(a, b)); //**
		
		//... 
		
		a = a * 2;
		
		System.out.println(NumberUtil.add(a, b)); //***
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bir metodun parametre değişkenleri aslında o metodun girdileridi (input). Bu anlamda metot parametre
	değişkenleri ile aldığı girdilerin nasıl elde edildiğinden bağımsız çalışır. Örneğin,
	
		public static int add(int a, int b)
		{
			return a + b;
		} 
		
	ve
		public static int add()
		{
			java.util.Scanner kb = new java.util.Scanner(System.in);
			System.out.println("İki sayı giriniz:");
			int a = kb.nextInt();
			int b = kb.nextInt();
			int result = a + b;		
			
			return result;
		}
	metotları için parametreli add metodu toplayacağı değerlerin nereden geldiğini ve nasıl elde edildiğini bilmez.
	parametresiz add metodu ise değerleri klavyeden elde eder. Bu anlamda parametreli add metodu daha genel yazılmıştır. 
	Bir metodun geri dönüş değeri de o metodun çıktısıdır (output). Örneğin,
	
		public static int add(int a, int b)
		{
			return a + b;
		} 
	ve
		public static void printTotal(int a, int b)
		{
			System.out.println(a + b);
		} 
		
	metotları için add metodu elde edilen değeri çıktı olarak verdiğinden toplam değerinin kullanılması anlamında genel
	yazılmıştır. Buradaki örnekler karşılaştırma amaçlı yazılmıştır. Bir metot diğerinden daha iyidir anlamı çıkartılmamalıdır.
	Hangisinin gerekeceği yazılan uygulamaya göre şüphesiz değişebilir.
	
	Anahtar Notlar: Bir metodun geri dönüş değeri olması ya da olmaması ve parametre değişkeni olması ya da olmaması
	birbiriyle doğrundan doğrudan ilişkili değildir. Şüphesiz dolaylı bir ilişki vardır. Bu anlamda geri dönüş değeri ve 
	parametre değişkenleri anlamında bir metot aşağıdakilerden biri biçiminde olabilir:
		1. Geri dönüş değeri var, parametre veya parametreleri var
		2. Geri dönüş değeri var, parametresi yok
		3. Geri dönüş değeri yok, parametre veya parametreleri var
		4. Geri dönüş değeri yok, parametresi yok	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Java'da atama işlemi 3 yerde yapılır:
	- Atama operatörü (işlemli atama operatörleri dahil) ile. Initialization işlemi de bu gruba sokulabilir.
	- Bir metodun geri dönüş değerinin geçici değişkene aktarılması
	- Metot çağrısında, argümanların parametre değişkenlerine aktarılması
	
	İstisna bazı durumlar dışında atama operatörü ile ilgili kuralların hepsi, diğer iki atama için de geçerlidir. İstisna
	durumlar konular içerisinde ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	27.08.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Neden metot yazalım? Yani, programcının uygulamayı geliştirirken çeşitli metotları yazması ne gibi bir avatajlar 
	sağlar? Aslında bu sorulara tek bir cümle ile cevap verilemez. Bu avantajlar genel olarak şu şekilde belirtilebilir: 
	- Bir metodun yaptığı işin detayları yani kabaca nasıl yaptığı, çağıran tarafından bilinmek zorunda değildir. Bu anlamda
	metot aslında, metodu çağrıdan programcıdan detayları gizlemiş olur.
	
	- Bir metodun yaptığı iş başka konuları da bilmeyi gerektirebilir. Ancak kullanan açısından bu durum önemsiz olabilir. 
	Örneğin bir sayının asal olup olmadığının anlaşılması konusu, asal sayı üretirken kullanılır ancak birbirlerinden 
	algoritmik olarak bağımsızdır. Bu durumda asal sayı üreten bir programcı, elinde sayının asal olup olmadığını test 
	etmek için kullanılan bir metodu çağırarak, sayının asal olup olmadığının nasıl anlaşılacağından bağımsız kod yazabilir.
	
	- Metot çağrılması okunabilirliği/algılanabilirliği artırır
	
	- Bir algoritma akış içerisinde bir çok yerde yazılmak isteneblir. Örneğin, bir sayının faktoriyel değerini bulan
	bir kod akış içerisinde bir çok yerde gerekebilir. Programcı bu kodu gereken her yerde yazarsa bu durumda hata yapma
	olasılığı artar. Aynı zamanda kodunda bir hata yaptığını farkederse veya kodda değişiklik yapmak isterse bunu yazdığı
	her yerde yapmak zorunda kalır. Bu da görece karmaşık bir hale getirebilir. İşte bu durumda programcı bir metot yazar
	ve gereken her yerde o metodu çağırırsa hata yapma olasılığı azalır, hata yaptığını anladığında veya bir değişiklik 
	gerektiğinde sadece metotta bu değişiklik yapılır. Bu da daha kolay ve çabuk bir biçimde yapılmasını sağlar. 
	
	- Uzun bir kodu bir çok yerde yazmak byte code'u büyütebilir. Ancak metot yazılıp çağrıldığında bu durum oluşmaz
	
	- Bir kodu metot olarak yazmak, o koda ilişkin test işlemlerini yaparak olası programlama hatalarının daha kolay
	belirlenebilmesini ve dolayısıyla daha kolay düzeltilmesini sağlar
	
	Anahtar Notlar: Buradaki maddelerinin hiç birisi birbirinden daha az önemli değildir.
	
	Anahtar Notlar: Programlamada en temel prensip kod tekrarından mümkün olduğunca kaçınmaktır. Yani, aynı işi yapan bir 
	kodu tekrar yazmak ZORUNLU OLMADIKÇA iyi bir teknik değildir. Bu kavrama programlamada "DO NOT REPEAT YOURSELF (DRY)" de 
	denilmektedir. İşte bu tekrarlamanın en yalın yöntemi metot yazmaktır ve çağırmaktır. Ayrıca ileride Nesne Yönelimli
	Programlama tekniğine ilişkin kavramlarla birlikte DRY çok daha etkin bir biçimde yapılabilmektedir.	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	System.out.printf metodu formatlı yazdırmak için kullanılan çok temel bir metottur. Bu metodun birinci parametresine
	argüman olarak bir yazı (bir String literal olabilir) geçilmelidir. Bu metot değişken sayıda argüman ile (vararg) 
	çağrılabilen bir metottur. Bu metodun diğer parametrelerinde herhangi bir türden argüman geçilebilir. Birinci parametre
	geçilen argümana ilişkin yazıda % karakteri ile birlikte özel bazı karakterler (format characters/specifiers) 
	yer tutucu (placeholder) olarak kullanılır. Örneğin n format karakteri imleci bir sonraki satırın başına geçirir. Bu 
	metot ileride göreceğimiz bazı metotlarla da aynı sistematik ile çalışır. printf metodunda format karakterlerin yer 
	tutucu dışında anlamı vardır. Bu anlamda bu metodu tanımak programcı açısından önemlidir. Örnek bir kullanım aşağıda 
	verilmiştir. Detaylar şu an önemsizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bugün ve yarınki tahmini hava sıcaklığını giriniz:");
		int today = kb.nextInt();
		int tomorrow = kb.nextInt();
		
		System.out.printf("Bugün hava %d derece. Yarın %d derece olacak%n", today, tomorrow);				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı türden bir değeri decimal olarak formatlamak için d format karakteri kullanılır, hexadecimal olarak formatlamak
	için x (küçük veya büyük) format karakteri kullanılır, octal formatlamak için o format karakteri kullanılır. 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		System.out.printf("a = %d%na = %x%na = %X%na = %o%n", a, a, a, a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı türlerinin formatlanmasında % ile format karakteri arasına sıfır dışında pozitif bir sayı hizalama (alignment)
	anlamına gelir. Eğer sayının başına sıfır da yazılırsa basılacak karakterler hizalanacak sayıdan küçükse başına sıfır
	eklenir. Eğer sıfır yazılmazsa space karakteri eklenir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		System.out.printf("a = %02d%na = %08X%n", a, a);
		System.out.printf("a = %2d%na = %8X%n", a, a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Gün, Ay ve Yıl bilgilerini giriniz:");
		int day = kb.nextInt();
		int month = kb.nextInt();
		int year = kb.nextInt();
		
		System.out.printf("%02d/%02d/%04d%n", day, month, year);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Gerçek sayıların formatlanmasında f format karakteri kullanılır. f format karakteri noktadan sonraki basamak sayısını
	default olarak belirli bir sayıda basamak kadar alır. Bu sayı doğrudan belirtilmemiş olsa da pek çok sistemde 6 dır.
	Geri kalan basamaklar bilimsel yuvarlama yöntemiyle yuvarlanır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		float b = kb.nextFloat();
		
		System.out.printf("a = %f, b = %f%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Gerçek sayılarda noktadan sonra istenilen sayıda basamağın formatlanması için % ile f karakteri arasında . (nokta)
	ve negatif olmayan bir sayı yazılır. Bu durumda sayı o kadar sayıda basamak olarak formatlanmış olur. Geri kalan
	basamaklar yine yuvarlanarak atılır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		float b = kb.nextFloat();
		
		System.out.printf("a = %.2f, b = %.2f%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	char türünün için c format karakteri kullanılır. Bu durumda char türü içerisinde tutulan sayıya karşılık gelen
	karakter formatlanmış olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char c = 68;
		
		System.out.printf("c = %c%n", c);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	boolean türünün için b format karakteri kullanılır. Bu durumda boolean türüne ilişkin değerin (true veya false) yazısal
	karşılığı ile formatlama yapılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		boolean flag1 = true;
		boolean flag2 = false;
		
		System.out.printf("flag1 = %b, flag2 = %b%n", flag1, flag2);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	printf metodunda kullanılan format karakteri geçilen argümanın türünden farklı ise bu durumda genel olarak exception 
	oluşur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("a = %f, b = %f%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	printf metodunda s format karakteri ile her tür formatlanabilir. Tabii bu durumda türe özgü bazı formatlama biçimleri
	kullanılamaz. s format karakteri ile bu işlemin nasıl yapıldığı ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		double b = kb.nextDouble();
		
		System.out.printf("a = %s, b = %s%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	System.out.printf metodu ile tamamen aynı işi yapan System.out.format isimli bir metot da vardır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		double b = kb.nextDouble();
		
		System.out.format("a = %d, b = %.20f%n", a, b);
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: printf (ve format) metodu için başka format karakterleri ve format karakterlerine özgü başka 
	detaylar da vardır. Bunlar zaman içerisinde ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Klavyeden girilen iki tam sayının toplamını, çarpımını ve farkını açıklamalara göre ekrana bastıran
	programı yazınız: 
	Açıklamalar:
		- Girilen sayılar 10 ve 20 olsun. Ekran çıktısı şu şekilde olacaktır:
		  	10 + 20 = 30
		  	10 * 20 = 200
		  	10 - 20 = -10
		- Ekrana formatlı yazdırmak için printf metodunu kullanınız 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		OperationApp.run();
	}
}

class OperationApp {
	public static void printResult(int a, int b)
	{
		System.out.printf("%d + %d = %d%n", a, b, NumberUtil.add(a, b));
		System.out.printf("%d * %d = %d%n", a, b, NumberUtil.multiply(a, b));
		System.out.printf("%d - %d = %d%n", a, b, NumberUtil.subtract(a, b));
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		printResult(a, b);
	}
}

class NumberUtil {
	public static int add(int a, int b)
	{
		return a + b;
	}
	
	public static int multiply(int a, int b)
	{
		return a * b;
	}
	
	public static int subtract(int a, int b)
	{
		return a - b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	JavaSE'de de bir çok sınıf ve bir çok metot vardır. Ayrıca programcı geliştirme sırasında kullandığı kütüphane ve 
	ortamlarda da (framework) pek çok sınıf ve metot bulunur. Peki programcı bir konuya ilişkin metodu ne zaman 
	yazmaya karar vermelidir? Yani başka bir deyişle JavaSE ya da diğer kullanılan ortam ve kütüphanelerde ilgili
	işlemi yapan sınıflar ya da metotlar programcı kendisi yazmalı mıdır? Programcı önce JavaSE'de ilgili işlemi yapan
	sınıfları ve metotları tercih etmelidir. Eğer işlemi yapan sınıf veya metot JavaSE'de yoksa, kullandığı kütüphane veya
	ortamda varsa onu tercih etmelidir. Eğer burada da yoksa kendisi yazmalı veya bu konuda yine iyi yazılmış olan bir 
	kütüphaneninkini varsa kullanmalıdır. Programcı kendi yazacağı metodu mutlaka test eder ve ona göre kodunu iyileştirir.
	Bununla birlikte Java programcısı zaman içerisinde (bu hemen olmayabilir) hepsini olmasa da kullandığı sınıfları ve
	metotları yazabilmeyi öğrenmelidir. Ancak, bir uygulama geliştirirken var olanları kullanmalıdır. Bu anlamda her şey
	de hazır değildir. Programcı da pek çok sınıf ve metot yazar.
	
	Peki, JavaSE'de ya da kullanılan ortamlar ve kütüphanelerdeki metotları kullanmanın avantajları nelerdir?
	- Okunabilirlik/algılanabilirlik
	
	- Kodun taşınabilirliğini sağlar. Özellikle JavaSE'deki bir metodun kod içerisinde çağrılması durumunda, o kod her ortama
	taşınabilir ve kodu derlenmesi için ektra bir işlem yapmaya gerek kalmaz
	
	- Bu metotlar zaman içerisinde test edildiği ve iyileştirildiği için uygun çalışması anlamında güvenilirdir
	 
	- JavaSE'den kullanılan bir metot veya sınıf için derleyici daha etkin kodlar üretebilir.
	
	- Programcının yalnızca kendi konusuna odaklanmasını sağlar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının PI ve E veri elemanları
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println(Math.PI);
		System.out.println(Math.E);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	02.09.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	İki tam sayı bölme işlemine sokulduğunda bölümün noktadan sonraki kısmı atılır. Ayrıca iki tamsayı bölme işlemine
	sokulduğunda bölen yani payda sıfır ise exception oluşur. Yani tamsayılar ile bölme işlemi paydanın sıfır olması
	durumunda yapılamaz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		double c;
		
		c = a / b;
		
		System.out.printf("c = %f%n", c);				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İki gerçek sayı bölme işlemine sokulduğunda bölünenin (payın) sıfır dışı bir değer, bölenin (paydanın) sıfır olması
	durumunda +-Infinity, payın da sıfır olması durumunda NaN (Not a number) değeri elde edilir. IEEE 754 standardına göre 
	gerçek sayılar kümesinde gerçek sayılar dışında özel bazı değerler vardır. İşte Infinity ve NaN değerleri de bunlardan
	ikisidir. Aşağıdaki örneği çeşitli değerler içinm çalıştırıp sonuc-çları gözlemleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c;
		
		c = a / b;
		
		System.out.printf("c = %f%n", c);				
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Math sınıfının metotları matematiksel olarak geçersiz olan argümanlar için genel olarak exception
	oluşturmazlar. Duruma göre NaN, Infinity gibi özel değerlere geri dönerler 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Math sınfının karakök alan sqrt metodu. Metot argümanın negatif olması durumunda NaN değerine geri döner 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();
		
		System.out.printf("sqrt(%f) = %f%n", a, Math.sqrt(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınfının karakök alan sqrt metodu. Metot argümanın negatif olması durumunda NaN değerine geri döner 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();
		
		System.out.printf("|%f| = %f%n", a, Math.abs(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınfının abs metotları 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();
		
		System.out.printf("|%f| = %f%n", a, Math.abs(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bir sınıf içerisinde aynı isimde birden fazla metot bildirilmesi durumunda "method overloading"
	denir. Method overloading konusu ileride detaylı olarak ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Math sınfının pow metodu 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		
		System.out.printf("pow(%f, %f) = %f%n", a, b, Math.pow(a, b));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı 2 noktanın koordinat bilgilerine göre aralarındaki uzaklığa geri dönen
	distance isimli metodu yazınız ve aşağıdaki kod ile test ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		PointUtilDistanceTest.run();
	}
}

class PointUtilDistanceTest {
	public static void printDistance(double x1, double y1, double x2, double y2)
	{
		System.out.printf("Distance:%f%n", PointUtil.distance(x1, y1, x2, y2));
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki noktanın koordinatlarını giriniz");
		double x1 = kb.nextDouble();
		double y1 = kb.nextDouble();
		double x2 = kb.nextDouble();
		double y2 = kb.nextDouble();

		printDistance(x1, y1, x2, y2);
	}
}

class PointUtil {
	public static double distance(double x1, double y1, double x2, double y2)
	{
		return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı 2 noktanın koordinat bilgilerine göre aralarındaki uzaklığa geri dönen
	distance isimli metodu yazınız ve aşağıdaki kod ile test ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		PointUtilDistanceTest.run();
	}
}

class PointUtilDistanceTest {
	public static void printDistance(double x1, double y1, double x2, double y2)
	{
		System.out.printf("Distance:%f%n", PointUtil.distance(x1, y1, x2, y2));
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki noktanın koordinatlarını giriniz");
		double x1 = kb.nextDouble();
		double y1 = kb.nextDouble();
		double x2 = kb.nextDouble();
		double y2 = kb.nextDouble();

		printDistance(x1, y1, x2, y2);
	}
}

class PointUtil {
	public static double distance(double x1, double y1, double x2, double y2)
	{
		return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının min ve max metotları
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		
		System.out.printf("min(%f, %f) = %f%n", a, b, Math.min(a, b));
		System.out.printf("max(%f, %f) = %f%n", a, b, Math.max(a, b));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte 3 tane sayının en büyüğü ve en küçüğü bulunmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Üç sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c = kb.nextDouble();
		
		System.out.printf("min(%f, %f, %f) = %f%n", a, b, c, Math.min(Math.min(a, b), c));
		System.out.printf("max(%f, %f, %f) = %f%n", a, b, c, Math.max(Math.max(a, b), c));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının logaritma işlemi yapan metotları
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();	
		
		System.out.printf("log10(%f) = %f%n", a, Math.log10(a));
		System.out.printf("log(%f) = %f%n", a, Math.log(a));
		System.out.printf("log1p(%f) = %f%n", a, Math.log1p(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Math sınıfının yuvarlama işlemi yapan önemli metotları
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		double a = kb.nextDouble();	
		
		System.out.printf("round(%f) = %d%n", a, Math.round(a));		
		System.out.printf("rint(%f) = %f%n", a, Math.rint(a));
		System.out.printf("ceil(%f) = %f%n", a, Math.ceil(a));
		System.out.printf("floor(%f) = %f%n", a, Math.floor(a));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Math sınıfında yukarıdaki metotlar dışında da pek çok metot bulunmaktadır. Bunlar genel olarak
	spesifik durumlarda ihtiyaç olan metotlardır. Gerektiğinde dokümantasyondan öğrenilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sabit İfadesi (constant expression): Yalnızca sabitlerden ve operatörlerden oluşan ifadelere denir. Sabitler de 
	tek başına bir sabit ifadesidir. 
	
	Anahtar Notlar: İleride aslında bir sabit olarak ele alınan değişken bildirimleri de yapılabileceğini göreceğiz
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Sabitler (Literals/Constants): Program içerisinde doğrudan yazılan sayılara denir.  Sabitlerin de türleri vardır. 
	Yani derleyici yazılan sabitin türüne göre işlem yapar. Sabitlerin türlerine ilişkin detaylar şu şekildedir:
	- Sayı nokta içermiyorsa VE sonuna herhangi bir ek almamışsa VE int türü sınırları içerisindeyse int türdendir. int
	türü sınırları dışında ise error oluşur. Örneğin: 10, 20, 45
	
	- Sayı nokta içermiyorsa ve sonuna L (küçük veya büyük) ekini almışsa (bu ek sayıya bitişik olarak yazılmalıdır)
	long türdendir. Sayı long türü sınırları dışında ise error oluşur.. Örneğin: 10L, 20000L 
	Anahtar Notlar: Küçük harf L karakteri sayının sonuna getirildiğinde bazı yazı tiplerinde 1 (bir) rakamı ile 
	karıştırılabileceğinden okunabilirlik açısından küçük harf L son ekinin kullanımı tavsiye edilmez
	
	- Java'da byte ve short türden sabitler yoktur
	
	- Sayı nokta içeriyorsa ve herhangi bir sonek almamışsa ve sınırlar içerisindeyse double türdendir. Örneğin: 3.4, 9.28759
	
	- Sayı nokta içersinde ya da içermesin sonuna D (küçük veya büyük) ekini almışsa double türdendir. Örneğin: 10D, 3.45d
	
	- Sayı nokta içersin ya da içermesin sonuna F (küçük veya büyük) ekini almışsa float türden. Sayının ondalık kısmı
	varsa F eki ile yuvarlama hataları oluşabilir. Örneğin: 3.4F, 8f
	
	- boolean türden iki tane sabit vardır: true, false
	
	- Tek tırnak içerisinde yazılan bir karakter, o karakterin karakter tablosundaki sıra numarasına karşılık gelir.
	Örneğin, 'Ş', 'D' gibi. Tek tırnak içerisinde özel bazı durumlar dışında yalnızca bir tane karakter yazılabilir. Bazı
	karakterlerin doğrudan sembol karşılığı yoktur. Bu karakterlere "escape sequence" karakterler denir. Bu karakterler
	için karakter sabitleri ters bölü ile birlikte özel bir karakter kullanılarak yazılır. Java'da desteklenen escape
	sequence karakterler şunlardır:
	
	'\n' -> Line Feed (LF)
	'\r' -> Carriage Return (CR)
	'\t' -> Horizontal Tab
	'\'' -> Single quote	
	'\"' -> Double quote (optional)
	'\0' -> null character
	'\\' -> back slash
	'\f' -> form feed
	'\b' -> backspace
	
	Peki, klavyemizin desteklemediği bir karakteri karakter sabiti olarak yazmanın yolu var mıdır? Sıra numarası doğrudan
	yazılabilir ya da çok kullanılan bir teknik olarak ters bölü ve u ile birlikte yazılabilir. Örneğin: '\u00C6'. Burada
	hexadecimal değer kesinlikle iki byte olarak yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	LF karakter sabiti
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char c;
		
		c = '\n';
		
		System.out.print("Merhaba");
		System.out.print(c);
		System.out.print("Nasılsın");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Eclipse ve IntelliJ gibi bazı IDE'ler işletim sisteminin console'unu doğrudan kullanmazlar. Kendi 
	console'ları da vardır. Bazı durumlarda bu console programın çalıştırıldığı sistemin console'undan farklı davranabilirler
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	CR karakter sabiti. Aşağıdaki örneği işletim sisteminizin console'unda çalıştırıp sonucu gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char c;
		
		c = '\r';
		
		System.out.print("Merhaba");
		System.out.print(c);
		System.out.print("Ali");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Escape sequence karakterler string literal içerisinde kendi anlamlarında kullanılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("Merhaba\rAli");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tek tırnak karakterinin karakter sabiti ters bölü ile yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char c = '\'';
		
		System.out.println(c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tek tırnak karakteri string literal içerisinde iki şekilde kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("'Ankara'");
		System.out.println("\'Ankara\'");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İki tırnak karakterinin sabiti iki şekilde yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char c1 = '\"';
		char c2 = '"';
		
		System.out.println(c1);
		System.out.println(c2);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İki tırnak karakteri string literal içerisinde ters bölü ile kullanılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("\"Ankara\"");;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Ters bölü karakter sabiti de ters bölü ile kullanılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		char c = '\\';
		
		System.out.println(c);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte escape sequence karakterler kullanıldığından çıktı C:\test\names.txt biçiminde olmaz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("C:\test\names.txt");;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnekte ters bölü karakterinin çıkartılması için ili tane ters bölü kullanılmalıdır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("C:\\test\\names.txt");;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ters bölü karakterinden sonra uygun bir karakter gelmediğinden error oluşur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("C:\deneme\names.txt");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek aşağıdaki gibi yazılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		System.out.println("C:\\deneme\\names.txt");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Backspace karakter sabiti
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		System.out.println("Merhaba\bAli");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Backtick karakter sabiti. Bu karakterin çok özel bir anlamı yoktur. Tek tırnak karakterine benzerliği dolayısıyla
	burada örnek olarak gösterilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		char c = '`';
		
		System.out.println(c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir karakterin sıra numarası ters bölü ve u ile birlikte hexadecimal olarak da verilebilmektedir. Bu durumda ilgili
	karakterin sıra numarası alınmış olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		char c = '\u00C6';
		
		System.out.println(c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	03.09.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Bir karakterin ters bölü u ile kullanımı string literal'larda da geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		System.out.println("Karakter:\u00C6");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aslında ters bölü u kullanımı değişken isimlendirmede de geçerlidir. Değişken isimlendirmede bir convention olarak
	hep İnglizce alfabedeki karakterleri kullandığımızdan böyle bir isimlendirmeye ihtiyacımız olmaz. Ancak bazı mülakatlarda
	sorulabildiği için bilmeniz önerilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int \u00c6x;
		
		\u00c6x = 10;
		
		System.out.println(\u00c6x);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aslında ters bölü u kullanımı değişken isimlendirmede de geçerlidir. Değişken isimlendirmede bir convention olarak
	hep İnglizce alfabedeki karakterleri kullandığımızdan böyle bir isimlendirmeye ihtiyacımız olmaz. Ancak bazı mülakatlarda
	sorulabildiği için bilmeniz önerilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int \u0041\u0042\u0043;
		
		ABC = 10;
		
		System.out.println(ABC);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tamsayı sabitleri çeşitli sistemlerde gösterilebilirler. Tamsayı sabiti doğrudan yazıldığında decimal olarak 
	gösterilmiş olur. Sabitin başına 0x (x küçük veya büyük olabilir) bitişik olarak yazıldığında sabit artık hexadecimal
	olarak yazılabilir. Sabitin başına 0(sıfır) bitişik olarak yazıldığında artık octal olarak yazılabilir. Java 7 ile 
	birlikte sabitin başına 0b (b küçük veya büyük olabilir) bitişik olarak yazıldığında artık binary olarak yazılabilir.
	Sabit hangi sistemine göre yazılıyorsa, o sayı sisteminin dışında kalan basamak değerleri kullanımı error oluşturur.
	Octal sistem nadir kullanılsa da programcı sayının başına yanlışlıkla sıfır koymamalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 10;
		int b = 0xA;
		int c = 012;
		int d = 0b1010; // Since Java 7
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
		System.out.printf("d = %d%n", d);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki out metodunu, pinlerden oluşan bir sistemin pinlerini aktif veya pasif (5 volt veya 0 colt) hale getirmek 
	için parametresi ile değerin bitlerine göre işlem yaptığını varsayınız. Bu durumda ilgili değeri sabit olarak vermek 
	istediğimizde hexadecimal veya binary gösterimin daha okunabilir/algılanabilir olduğuna dikkat ediniz. Örnek durumu
	göstermek için yazılmıştır. Burada binary gösterim daha anlaşılır olsa da bit sayısı arttığında hexadecimal gösterim 
	değeri daha basitleştirebilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		PinIOUtil.out(8128);
		PinIOUtil.out(0x1FC0);
		PinIOUtil.out(0b0001111111000000);
	}
}

class PinIOUtil {
	public static void out(int val)
	{
		System.out.printf("val = %d%n", val);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sabitler birçok programlama dilinde olduğu gibi Java'da da bilimsel/üstel olarak gösterilebilmektedir. Bu sabitlerin
	değeri noktadan sonra bir basamak değeri içermese de türleri double'dır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		double avogadroNumber = 6.02E23;
		
		System.out.println(avogadroNumber);
		System.out.printf("%f%n", avogadroNumber);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sabitler birçok programlama dilinde olduğu gibi Java'da da bilimsel/üstel olarak gösterilebilmektedir. Bu sabitlerin
	değeri noktadan sonra bir basamak değeri içermese de türleri double'dır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		double avogadroNumber = 6.02E+23;
		
		System.out.println(avogadroNumber);
		System.out.printf("%f%n", avogadroNumber);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sabitler birçok programlama dilinde olduğu gibi Java'da da bilimsel/üstel olarak gösterilebilmektedir. Bu sabitlerin
	değeri noktadan sonra bir basamak değeri içermese de türleri double'dır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		double avogadroNumber = 6.02e+23;
		
		System.out.println(avogadroNumber);
		System.out.printf("%f%n", avogadroNumber);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sabitler birçok programlama dilinde olduğu gibi Java'da da bilimsel/üstel olarak gösterilebilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		double val = 6.02e-23;
		
		System.out.println(val);
		System.out.printf("%.30f%n", val);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 7 ile birlikte sabitlerin herhangi iki basamağı arasında istenildiği sayıda alttire karakteri kullanılabilmektedir.
	Sabitlerde _ kullanımı okunabilirliği artırmak amacıyla dile eklenmiştir. Programcı da mantıksal olarak uygun yere 
	alttire karakterini yerleştirmelidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		long a = 4_000_000_000L;
		double b = 2_567.234_567;
		int c = 0b0001_1111_1100_0000;
		int d = 0x1F_C0;
		
		System.out.println(a);
		System.out.println(b);
		System.out.println(c);
		System.out.println(d);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Alttire karakteri istenilen sayıda kullanılabilir. Şüphesiz okunabilirliğin olumsuz etkilenmemesine dikkat edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 1______________________________________________0;
		
		System.out.println(a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Alttire karakteri yalnızca iki basamak arasında geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		double a = 10._45; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki kurala istisna olarak octal sabitlerde sıfır ile sayının ilk basamağı arasında alttire kullanımı 
	geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 0_12;
		
		System.out.println(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir gerçek sayı sabitinin noktadan önceki değeri (yani tamsayı kısmı) sıfır ise, sıfır yazılmayabilir. Benzer şekilde
	sayının noktadan sonraki değeri (yani ondalık kısmı) sıfır ise yine sıfır yazılmayabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		double a = .2;
		double b = 2.;
		
		System.out.printf("a = %f%n", a);
		System.out.printf("b = %f%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Temel Operatörler: Belirli bir işleme yol açan ve işlem sonucunda bir değer üreten atomlara operatör (operator) denir.
	Java'da çok fazla operatör vardır. Bu bölümde temel operatörler ele alınacaktır. Konular içerisinde diğer operatörler de
	incelenecektir. Bir operatör ile işleme giren ifadelere operand denir. Bir operatör için aşağıdakilerin bilinmesi gerekir:
	- Operatörün hangi sınıfta olduğu
		- İşlevlerine göre sınıflandırma
			- Aritmetik operatörler (arithmetic operators)			
			- Karşılaştırma operatörler (comparison operators)
			- Mantıksal operatörler (logical operators)
			- Bitsel operatörler (bitwise operators)
			- Özel amaçlı operatörler (special purpose operators)
		- Operand sayısına göre sınıflandırma
		  	- Tek operandlı (unary)
		  	- İki operandlı (binary)
		  	- Üç operandlı (ternary)
		- Operatörün operandına göre konumu
			- Ön ek (prefix)
			- Ara ek (infix)
			- Son ek (postfix)
			
	- Operatörün kısıtı (constraint): Bu operatörün kullanılabilmesi için özel şartlar var mı
	
	- Operatörün ürettiği değer (product value)
	
	- Operatörün önceliği (precedence): Operatörün genel olarak ifade içerisinde işleme girme sırası. Örneğin:
		a = b + c * d 
	ifadesinde derleyicinin ürettiği koda ilişkin işlem sırası şu şekildedir:
		i1: c * d
		i2: b + i1
		i3: a = i2
		
		a = (b + c) * d
	ifadesinde derleyicinin ürettiği koda ilişkin işlem sırası şu şekildedir:
		i1: b + c
		i2: i1 * d
		i3: a = i2
		
	- Operatörün yan etkisi (side effect) var mı? Operatör operandına ilişkin değeri değiştiriyor mu? 
	
	Anahtar Notlar: Bazı operatörler operatör önceliğine doğrudan uymazlar. Bu anlamda operatör önceliği ile işleme 
	girme sırası değişiklik gösterebilir. Bu tarz operatörler ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aritmetik 4 işlem operatörleri: +, -, *, /
	Bu operatörler iki operandlı (binary) ve araek (infix) durumda operatörlerdir. İlgili işleme sokulabilecek operandlar
	için geçerlidir. Operatörler operandlarına ilişkin değerlerin ilgili işleme sokulduktan sonraki değerini üretirler. 
	Bu operatörlerin yan etkisi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("%d + %d = %d%n", a, b, a + b);
		System.out.printf("%d - %d = %d%n", a, b, a - b);
		System.out.printf("%d * %d = %d%n", a, b, a * b);
		System.out.printf("%d / %d = %d%n", a, b, a / b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Mod (%) aritmetik operatörü iki operandlı araek durumunda bir operatördür. Ürettiği değer mod işlemine ilişkin değerdir.
	Operatörün yan etkisi yoktur. Çarpma ve bölme operatörleri ile aynı öncelik seviyesindededir. Operatörün kısıtı 
	çarpma ve bölme operatörleri ile aynıdır. Bu operatörm gerçek sayı türleri için de kullanılabilir.
	
	Bu operatörün ikinci operandının negatif olmasının bir önemi yoktur. Pozitif olarak işlem yapılır. Birinci
	operandının işareti sonucun işaretini belirler. İşlem yapılırken birinci operand negatif ise pozitif olarak
	işlem yapılır ve elde edilen değerin ters işaretlisi üretilir. Örneğin 10 % 3 işleminin sonucu 1'dir, -10 % 3 
	işleminin sonucu -1'dir. Benzer şekilde 10 % -3 işleminin sonucu da 1, -10 % -3 işleminin sonucu da -1'dir. Yani
	negatif sayılar için Matematikteki mod işlemi ile aynı şekilde sonuç üretmez. Bu bu operatörün çalışma biçimidir.
	Yanlış çalıştığı anlamına gelmez. Bu şekilde çalışma pratikte programcının daha çok işine yarar. Örneklerle
	ele alacağız
	
	Anahtar Notlar: printf metodunda yazıda % karakterinin çıkartılabilmesi için iki tane % karakteri bitişik olarak
	kullanılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("%d %%  %d = %d%n", a, b, a % b);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı int türden 3 basamaklı bir sayının basamakları toplamına geri dönen 
	sum3DigitsNumber metodunu yazınız ve test ediniz.
	Açıklamalar: 
		- Metot sayının 3 basamaklı olup olmadığı kontrolünü yapmayacaktır
		- Sayı negatif ise basamakları toplamı pozitif olarak döndürülecektir  
		
	Aşağıdaki örnekte % operatörünün negatif sayılar için çalışma biçimi örnek açısından programcı için uygundur. % 
	operatörü Matematik'teki gibi çalışsaydı aşağıdaki metot negatif sayılar için yanlış çalışacaktı. Bu durumda programcı
	metodu farklı bir şekilde yazmak zorunda kalacaktı. / ve % operatörleri aynı seviyededir. O seviyedeki operatörlerin
	aynı ifadede bulunması durumunda işlem soldan sağa (left associative) olarak yapılır. Bu sebeple onlar basamağı
	bulunurken herhangi önceliklendirme yapılmazı yani parantez kullanılması gerekmez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		Sum3DigitsTest.run();		
	}
}

class Sum3DigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();
		
		System.out.printf("%d sayısının basamakları toplamı:%d%n", val, Util.sum3DigitsNumber(val));
	}
}

class Util {
	public static int sum3DigitsNumber(int val)
	{
		int a, b, c;
		
		a = val / 100;
		b = val / 10 % 10; //val % 100 / 10;
		c = val % 10;
		
		return Math.abs(a + b + c);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İşaret - aritmetik operatörü tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. Operatörün yan etkisi 
	yoktur. Operatör boolean türü dışında tüm temel türler ile kullanılabilir. Operatör 2. seviyede bir operatördür. Bu 
	seviyedeki operatörler sağdan sola önceliklidir (right associative). Operatör operandına ilişkin ifadenin değerinin
	ters işaretlisini üretir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = -a;
		
		System.out.printf("a = %d%n", a);		
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İşaret + aritmetik operatörü tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. Operatörün yan etkisi 
	yoktur. Operatör boolean türü dışında tüm temel türler ile kullanılabilir. Operatör 2. seviyede bir operatördür. 
	Operatör operandına ilişkin ifadenin değerinin aynısını üretir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = +a;
		
		System.out.printf("a = %d%n", a);		
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da negatif bir sabit doğrudan yoktur. Pozitif bir sabite işaret eksi operatörü uygulandığında negatif olur. Örneğin
	-2 yazıldığında 2 sabitine işaret - operatörü uygulandığında elde edilen değer üretilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a;
		
		a = -2;
		
		System.out.printf("a = %d%n", a);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte işaret - operatörü sağdan sola öncelikli olduğundan herhangi bir problem oluşmaz. Örneği çalıştırıp
	sonucu gözlemleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a;
		
		a = - - - - - - - - - - - - - - - - - - -  -2;
		
		System.out.printf("a = %d%n", a);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = - - - - - - - - - - - - - - - - -  - - - - - - - - - -a;
		
		System.out.printf("a = %d%n", a);		
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c;
		
		c = a - - - - - - - - - - - - - - - - -  - - - - - - - - - -b;
		
		System.out.printf("a = %d%n", a);		
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	++ aritmetik operatörü tek operandlı, önek ve sonek durumunda kullanılabilen bir operatördür. Bu operatörün operandı
	bir değişken olmalıdır. Operatör operandı olan değişkenin değerini 1 artırır. Dolayısıyla operatörün yan etkisi
	vardır. Operatör 2. seviyede bir operatördür.  Operatör önek veya son olarak nasıl kullanılırsa kullanılsın operandına
	ilişkin değeri 1 artırır. Operatör boolean türü dışında tüm temel türler ile kullanılabilir. Operatörün ürettiği 
	değer yani işleme giren değer önek ve sonek kullanımına göre farklılık  gösterir. Bu durum ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	++ operatörü nasıl kullanılırsa kullanılsın operandına ilişkin değeri 1 artırır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		System.out.printf("a = %d%n", a);
		
		++a; //a = a + 1;
		
		System.out.printf("a = %d%n", a);
		
		a++; //a = a + 1;
		
		System.out.printf("a = %d%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	++ operatörü prefix olarak kullanıldığında ürettiği değer yani işleme giren değer artırılmış değerdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = ++a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	++ operatörü postfix olarak kullanıldığında ürettiği değer yani işleme giren değer artırılMAmış değerdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = a++;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	-- aritmetik operatörü tek operandlı, önek ve sonek durumunda kullanılabilen bir operatördür. Bu operatörün operandı
	bir değişken olmalıdır. Operatör operandı olan değişkenin değerini 1 azaltır. Dolayısıyla operatörün yan etkisi
	vardır. Operatör 2. seviyede bir operatördür.  Operatör önek veya son olarak nasıl kullanılırsa kullanılsın operandına
	ilişkin değeri 1 azaltır. Operatör boolean türü dışında tüm temel türler ile kullanılabilir. Operatörün ürettiği 
	değer yani işleme giren değer önek ve sonek kullanımına göre farklılık  gösterir. Bu durum ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	-- operatörü nasıl kullanılırsa kullanılsın operandına ilişkin değeri 1 azaltır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		System.out.printf("a = %d%n", a);
		
		--a; //a = a - 1;
		
		System.out.printf("a = %d%n", a);
		
		a--; //a = a - 1;
		
		System.out.printf("a = %d%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	-- operatörü prefix olarak kullanıldığında ürettiği değer yani işleme giren değer azaltılmış değerdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = --a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	-- operatörü postfix olarak kullanıldığında ürettiği değer yani işleme giren değer azaltılMAmış değerdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = a--;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: İki operandlı operatörler için bazı özel operatörler dışında operanlar arasında bir ve yalnız bir tane
	space karakteri koyacağız. Tek operandlı operatörleri genel olarak operandına bitişik olarak yazacağız 
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = ++a * 2;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		int b;
		
		b = a++ * 2;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	09.09.2023	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici soldan sağa ve yukarıdan aşağıya doğru anlamlı en uzun ifadeyi ele alacak şekilde parsing işlemini yapar.
	Bu kurala "maximal munch" da denilmektedir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2;
		int b = 5;
		int c;
		
		c = a+++b; //a++ + b		
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c); //a = 3, b = 5, c = 7
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2;
		int b = 5;
		int c;
		
		c = a++b; //error
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2;
		int b = 5;
		int c;
		
		c = a++++b; //error		
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2;
		int b = 5;
		int c;
		
		c = a+++-b;		
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c); //a = 3, b = 5, c = -3
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2;	
		
		a = a++;
		
		System.out.printf("a = %d%n", a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2;	
		
		a = ++a;
		
		System.out.printf("a = %d%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2;
		int b;
		
		b = a++ + a;
		
		System.out.printf("a = %d, b = %d%n", a, b); //a = 3, b = 5
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2, b = 3;
		int c;
		
		c = ++a + ++b * a--;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c); //a = 2 , b = 4, c = 15 
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2, b = 3;
		int c;
		
		c = ++b * a-- + ++a;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c); //a = 2 , b = 4, c = 10
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 2, b = 3;
		int c;
		
		c = ++b * a-- + ++a;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c); //a = 2 , b = 4, c = 10 
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Temel karşılaştırma operatörleri 6 tanedir: <, >, <=, >=, ==, !=. Bu operatörler iki operandlı ve araek durumundadır.
	Bu operatörlerin yan etkisi yoktur. Bu operatörlerin temel türler açısından operandının boolean türünden olmaması 
	gerektiği dışında bir kısıtı yoktur. Bu operatörlerin ürettiği değer karşılaştırmanın sonucuna göre boolean türdendir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("%d < %d = %b%n", a, b, a < b);
		System.out.printf("%d > %d = %b%n", a, b, a > b);
		System.out.printf("%d <= %d = %b%n", a, b, a <= b);
		System.out.printf("%d >= %d = %b%n", a, b, a >= b);
		System.out.printf("%d == %d = %b%n", a, b, a == b);
		System.out.printf("%d != %d = %b%n", a, b, a != b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte boolean ile int türü karşılaştırması geçersiz olacağından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 10, b = 20, c = 30;

		
		System.out.println(a < b < c);	//error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Mantıksal operatörler (logical operators) 3 tanedir: Logical AND (&&), logical OR (||), logical NOT (!).
	&& ve || operatörleri iki operandlı araek durumundadır, ! operatörü tek operandlı ve önek durumundadır. Mantıksal
	operatörlerin operandları boolean türden olmak zorundadır. Bu operatörlerin ürettiği değer işlemin sonucuna göre
	boolean türdendir. Bu operatörlerin yan etkisi yoktur.
	
	Mantıksal operatörlerin doğruluk tabloları (truth table):
	
	a 		b		a && b		a || b
	T		T		  T			  T
	T		F		  F			  T
	F		T		  F			  T
	F		F		  F			  F
	
	a		!a
	T		F
	F		T
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	&& operatörü. Metotlar durumu göstermek aşağıdaki gibi yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result = Sample.foo() && Sample.bar();
		
		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	|| operatörü. Metotlar durumu göstermek aşağıdaki gibi yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result = Sample.bar() || Sample.foo();
		
		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	&& operatörünün kısa devre davranışı (short circuit behavior) . Aşağıdaki örnekte foo metodunun çağrılması sonucu
	etkilemediğinden çağrılmaz. Metotlar durumu göstermek aşağıdaki gibi yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result = Sample.bar() && Sample.foo();
		
		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	|| operatörünün kısa devre davranışı (short circuit behavior) . Aşağıdaki örnekte bar metodunun çağrılması sonucu
	etkilemediğinden çağrılmaz. Metotlar durumu göstermek aşağıdaki gibi yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result = Sample.foo() || Sample.bar();
		
		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	&& ve || operatörleri doğru sonuca en kısa yoldan hesaplamak isterler. Bunu da kısa devre davranışı ile yaparlar. 
	Derleyici bu operatörlerin kullanıldığı ifadelerde buna yönelik kod üretir.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	&& ve || operatörlerine ilişkin ifadelerde işlem önceliği düşünülmeksizin hep soldan başlanarak işlem yapılır. Yani
	bu operatörlerle işlem yapılırken operatör önceliğine uyulmaz. Ancak elde edilen sonuç operatör önceliğine uyulsa
	(yani Matematiksel olarak işlem yapılsa) elde edilecek sonucun aynısı olur. Aşağıdaki örneği inceleyiniz. Metotlar 
	durumu göstermek aşağıdaki gibi yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result = Sample.foo() || Sample.bar() && Sample.tar();
		
		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte operatör önceliği, işlem yapılış önceliği aynıdır. Bu durumda ona yönelik kod üretilir. Örnekte 
	tar çağrılmadan sonuç elde edilemez. Ancak foo'nunn çağrılmasına gerek yoktur. Metotlar  durumu göstermek aşağıdaki 
	gibi yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result = Sample.bar() && Sample.foo() || Sample.tar();
		
		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	! operatörü operandına ilişkin ifadenin mantıksal tersini üretir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean flag = false; //Buradaki değerin ne olduğu ve nereden elde edildiğini düşünmeyiniz
		
		flag = !flag;
		
		System.out.printf("flag = %b%n", flag);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bitwise AND (&) ve bitwise OR (|) operatörleri boolean türü ile kullanıldığında yani operandları boolean türden 
	olduğunda kısa devre davranışı dışında && ve || operatörleri ile aynı biçimde çalışırlar. Yani bu operatörler boolean
	türü ile kullanıldıklarında ne olursa olsun kısa devre olmaz. Metotlar durumu göstermek aşağıdaki gibi yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		boolean result = Sample.foo() | Sample.bar() & Sample.tar();
		
		System.out.printf("result = %b%n", result);
	}
}

class Sample {
	public static boolean foo()
	{
		System.out.println("foo");
		
		return true;
	}
	
	public static boolean bar()
	{
		System.out.println("bar");
		
		return false;
	}
	
	public static boolean tar()
	{
		System.out.println("tar");
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	& ve | operatörleri iki tamsayının karşılıklı bitlerini işleme sokarlar ve elde edilen sayıyı üretirler. Örnek durumu
	göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 10; //00000000000000000000000000001010 -> 0000000A
		int b = 11; //00000000000000000000000000001011 -> 0000000B
		int c;
		
		c = a & b; //00000000000000000000000000001010 -> 0000000A
		
		System.out.printf("c = %d%n", c);
		
		c = a | b; //00000000000000000000000000001011 -> 0000000B
		
		System.out.printf("c = %d%n", c);
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bitsel operatörlerin detayları burada ele alınmayacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Atama operatörü (assignment operator) (=) iki operandlı araek durumundadır. Operatörün birinci operandı değişken
	olmalıdır. Operatörün yan etkisi vardır. Atama operatörü atanmış olan değeri üretir. Atama operatörü sağdan sola
	önceliklidir. Bu sebeple aşağıdaki işlem geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a, b, c;
		
		a = b = c = 2;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Atama operatörü (assignment operator) (=) iki operandlı araek durumundadır. Operatörün birinci operandı değişken
	olmalıdır. Operatörün yan etkisi vardır. Atama operatörü atanmış olan değeri üretir. Atama operatörü sağdan sola
	önceliklidir. Bu sebeple aşağıdaki işlem geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a, b, c;
		
		a = b = c = 2;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte, atama operatörünün birinci operandının değişken olması gerektiğinden error oluşur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 20, b = 10, c = 10;
		
		(a = b) = c = 2;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte, atama operatörünün birinci operandının değişken olması gerektiğinden error oluşur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 20, b = 34, c = 3;
		
		a = (b = c) = 3;
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek geçerlidir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 20, b = 34, c = 3;
		
		a = b = (c = 2);
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java'da bir grup işlemli atama (compound/augmented assignment) operatörü vardır. Bu operatörlerin genel biçimi şu 
	şekildedir:
	<değişken> <op>= <ifade>
	Örneğin 
	a += b;
	
	Bu operatöler iki operandlı ve araek durumundadır. Bu operatörlerin birinci operandları değişken olmalıdır. Bu 
	opetörlerin çalışme biçimi şu şekildedir:
	
	<değişken> <op>= <ifade> => <değişken> = <değişken> <op> <ifade>
	Örneğin: 
	a += b => a = a + b
	
	İşlemli atama operatörleri de atanmış değeri üretirler
	
	Anahtar Notlar: İşlemli atama operatörleri aslında <değişken> = <değişken> <op> <ifade> işlemini bu şekilde 
	yapmazlar. İleride asıl işlemi ele alacağız
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	İşlemli atama operatörleri
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 20;
		
		a += 10; //a = a + 10;
		
		System.out.printf("a = %d%n", a);		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	İşlemli atama operatörleri ifadelerin daha basit yazılması için tercih edilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 20, b = 10, c = 20;
		
		a *= b + c; //a = a * (b + c); 
		
		System.out.printf("a = %d%n", a);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 20, b = 10, c = 20;
		
		a += b += c;  
		
		System.out.printf("a = %d, b = %d, c = %d%n", a, b, c);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	10.09.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Metot çağırma operatörü özel amaçlı, iki operandlı araek durumunda bir operatördür. Operatör metot ismini ve metodun
	parametreleri varsa ilgili argümanları alır ve metodun çağrılmasına yol açar. Operatör operatör öncelik tablosunda 
	birinci seviyededir. Operatör eğer void bir metot değilse metodun geri dönüş değerini üretir. Bu anlamda değer
	üretmeyebilecek tek operatördür. void bir metodun çağrısı teknik olarak void bir ifadedir. Mantıksal olarak herhangi 
	bir değer üretmeyen bir ifadedir. 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int result;
		
		result = Util.add(10, 20) * 2;
		
		System.out.printf("result = %d%n", result);
	}
}

class Util {
	public static int add(int a, int b)
	{
		return a + b;		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Java'da etkisiz ifadeler genel olarak geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		int a = 10, b = 20;
		
		a + b; //error
				
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki metot çağrısı her ne kadar metot boş olsa da geçersiz değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		Util.foo();
	}
}

class Util {
	public static void foo()
	{
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Noktalı virgül Java'da sonlandırıcı (terminator) olarak kullanılır. İfadelerin veya bazı deyimlerin sonlandırılması
	için kullanılmaktadır. Java'da başka sonlandırıcı yoktur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıda anlatılan operatörler dışında pek çok operatör bulunmaktadır. Bu operatörler ilerdeki konularda ele
	alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Deyimler (Statements): Bir programın çalıştırılabilen parçalarına denir. Yani bir program deyimlerin çalıştırılmasıyla
	çalışır. Java'da deyimler şunlardır:
	1. Basit deyimler (simple statements): Bir ifadenin sonuna noktalı virgül konmasıyla oluşan deyimdir. 
	Örneğin:
		c = a + b;
		System.out.println("Merhaba");
	Basit deyim çalıştırıldığında ilgili ifade hesaplanır. 
	
	2. Bileşik deyimler (compound statments): Bir blok küme parantezleri ile birlikte bileşik deyimdir. Bu anlamda metot 
	gövdesi de bileşik deyimdir. 
	Örneğin:
		{
			int a = 10;
			
			++a;
			
			a += 2;
			{
				//...
			}
		}
	Bileşik deyim çalıştırıldığında blok içerisindeki tüm deyimler yukarıdan aşağıya ya da soldan sağa olmak üzere 
	çalıştırılır.
	
	3. Bildirim deyimleri (declaration stataments): Değişken bildirimine ilişkin deyimlerdir. 
	Örneğin:
		int a;
		int b = 20;
	Bildirim deyimi çalıştırıldığında bellekte yer ayrılır.
	 		
	4. Kontrol deyimleri (control statements): Akışa yön veren yani akışın yönlendirilmesini sağlayan deyimlerdir.
	Örneğin:
		if deyimi
		for döngü deyimi
		for-each döngü deyimi
	Her kontrol deyiminin çalıştırılması kendine özgüdür
	
	5. Boş deyim (empty/null statements): Noktalı virgülün tek başına kullanılmasıyla oluşan deyimdir. Boş deyim
	çalıştırıldığında hiç bir şey yapılmaz
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	 if deyimi (if statements): if deyimi en temel kontrol deyimlerindendir. if deyimi bir koşulun doğru ya da yanlış
	 olmasına göre akışın yönlendirilmesi için kullanılır. if deyiminin genel biçimi şu şekildedir:
	 if (<koşul ifadesi>)
	 	<deyim>
	 [
	 else
	 	<deyim>
	 ]
	 
	 Koşul ifadesi boolean türden olmak zorundadır. if deyiminin else kısmı olmayabilir. Ancak else bir if deyimine ait
	 olmalıdır. if deyimi varsa else kısmıyla birlikte tek bir deyimdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a % 2 == 0) 
			System.out.printf("%d çift bir sayıdır%n", a);		
		else
			System.out.printf("%d tek bir sayıdır%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte if deyiminde bileşik deyim kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a % 2 == 0) {
			System.out.printf("%d çift bir sayıdır%n", a);
			a /= 2;
		}
		else {
			System.out.printf("%d tek bir sayıdır%n", a);
			a *= 2;
		}
		
		System.out.printf("a = %d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a % 2 == 0) {
			System.out.printf("%d çift bir sayıdır%n", a);
			a /= 2;
		}
		else
			System.out.printf("%d tek bir sayıdır%n", a);
			
		System.out.printf("a = %d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 if deyiminin else kısmı olmak zorunda değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a % 2 == 0)			
			a /= 2;
			
		System.out.printf("a = %d%n", a);		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 if deyiminde yanlışlıkla noktalı virgül konması durumu
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a % 2 == 0);		
			a /= 2;
			
		System.out.printf("a = %d%n", a);		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte else'in ait olduğu bir if deyimi olmadığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a % 2 == 0);		
			a /= 2;
		else //error
			a *= 2;
			
		System.out.printf("a = %d%n", a);		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte else ** ilem belirtilen if deyimine ait olur. Buna "dangling else" denir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0)
			if (a % 2 == 0) //**
				System.out.printf("%d sayısı pozitif bir çift sayıdır%n", a);			
		else
			System.out.println("Pozitif sayı girmelisiniz!...");
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Yukarıdaki örnek bileşik deyim kullanımı ile düzeltilebilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0) {
			if (a % 2 == 0)
				System.out.printf("%d sayısı pozitif bir çift sayıdır%n", a);
		}
		else
			System.out.println("Pozitif sayı girmelisiniz!...");
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte bileşik deyim kullanılmasına gerek yoktur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0)
			if (a % 2 == 0) 
				System.out.printf("%d sayısı pozitif bir çift sayıdır%n", a);
			else
				System.out.printf("%d sayısı pozitif bir tek sayıdır%n", a);	
		else
			System.out.println("Pozitif sayı girmelisiniz!...");		
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Yukarıdaki örnek aşağıdaki gibi daha okunabilir/algılanabilir olarak yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0)
			System.out.printf("Pozitif bir sayı girdiniz:%d%n", a);
		else if (a == 0)
			System.out.println("Sıfır girdiniz");
		else
			System.out.printf("Negatif bir sayı girdiniz:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte koşullar ayrık olmasına karşın programcı ayrık değilmiş gibi if deyimleri yazmıştır. Bu durumda
	 bir koşul gerçekleştiğinde geri kalan if deyimlerini de boşu boşuna kontrol edecektir. Aynı zamanda ayrık koşulların
	 ayrık değilmiş gibi yazılması okunabilirliği/algılanabilirliği azaltır. Yani aşağıdaki örneğin yukarıdaki gibi else-if
	 biçiminde yazılması iyi bir tekniktir. Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 0)
			System.out.printf("Pozitif bir sayı girdiniz:%d%n", a);
		if (a == 0)
			System.out.println("Sıfır girdiniz");
		if (a < 0)
			System.out.printf("Negatif bir sayı girdiniz:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki koşullar ayrık değildir. Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (a > 6)
			System.out.printf("%d > 6%n", a);
		if (a > 8)
			System.out.printf("%d > 8%n", a);
		if (a > 11)
			System.out.printf("%d > 11%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 boolean türden ifadelerin if deyiminde == veya != operatörü ile kullanımı iyi bir teknik değildir. Örnek durumu 
	 göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		Util.printEvenStatus(a % 2 == 0);		
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static void printEvenStatus(boolean even)
	{
		if (even) //if (even == true)
			System.out.println("Çift sayı girildi!...");
		else
			System.out.println("Tek sayı girildi!...");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 boolean türden ifadelerin if deyiminde == veya != operatörü ile kullanımı iyi bir teknik değildir. Örnek durumu 
	 göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		Util.printEvenStatus(a % 2 == 0);		
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static void printEvenStatus(boolean even)
	{
		if (!even) //if (even != true)
			System.out.println("Tek sayı girildi!...");
		else
			System.out.println("Çift sayı girildi!...");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Anahtar Notlar: Programlamada bir kontrol işlemi yapan ve duruma göre kontrolün doğru ya da yanlış olduğunu
	 belirleyen yapılara "predicate" denir. Örneğin bir sayının asal olup olmadığını test eden bir metot predicate
	 bir metottur. Java'da bu tarz metotların geri dönüş değerleri boolean türden yapılır ve genel olarak isimlendirilmesinde
	 bir fiil söz konusu değilse is gibi yardımcı fiiller kullanılır. Bir sayının asal sayı olup olmadığını test eden
	 bir metodun ismi isPrime biçiminde belirlenebilir. Eğer işlem bir fiil olarak isimlendirilecekse fiil doğrudan
	 yazılır gerekirse s eki alır. Örneğin bir dosyanın var olup olmadığını test eden bir metodun ismi exists yapılır 
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki isEven metodunda yazılan if deyiminde else anahtar sözcüğüne gerek yoktur. Çünkü akış return deyimine
	 geldiğinde metot sonlanır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (Util.isEven(a))
			System.out.printf("Çift sayı girdiniz:%d%n", a);
		else
			System.out.printf("Tek sayı girdiniz:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static boolean isEven(int a)
	{
		if (a % 2 == 0)
			return true;
		else
			return false;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Yukarıdaki isEven metodu if deyimiyle aşağıdaki gibi yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (Util.isEven(a))
			System.out.printf("Çift sayı girdiniz:%d%n", a);
		else
			System.out.printf("Tek sayı girdiniz:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static boolean isEven(int a)
	{
		if (a % 2 == 0)
			return true;
		
		return false;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 isEven metodu % operatörü ile aşağıdaki gibi de yazılabilir. == operatörünün ürettiği değerin boolean türden 
	 olduğunu anımsayınız. isEven metodu % operatörü en iyi aşağıdaki gib yazılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (Util.isEven(a))
			System.out.printf("Çift sayı girdiniz:%d%n", a);
		else
			System.out.printf("Tek sayı girdiniz:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static boolean isEven(int a)
	{
		return a % 2 == 0;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örneği inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		
		if (!Util.isOdd(a))
			System.out.printf("Çift sayı girdiniz:%d%n", a);
		else
			System.out.printf("Tek sayı girdiniz:%d%n", a);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class Util {
	public static boolean isEven(int a)
	{
		return a % 2 == 0;		
	}
	
	public static boolean isOdd(int a)
	{
		return !isEven(a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	 Sınıf Çalışması: Klavyeden katsayıları girilen ikinci dereceden bir denklemin köklerini bulan programı yazınız
	 Not: İleride daha iyisi yazılacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		QuadraticEquationApp.run();		
	}
}

class QuadraticEquationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Kaysayıları giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c = kb.nextDouble();
		
		QuadraticEquation.findRoots(a, b, c);		
	}
}

class QuadraticEquation {
	public static double calculateDelta(double a, double b, double c)
	{
		return b * b - 4  * a * c;
	}
	
	public static void findRoots(double a, double b, double c)
	{
		double delta = calculateDelta(a, b, c);
		
		if (delta > 0) 
			printDifferentRoots(a, b, delta);
		else if (delta == 0)
			printSameRoots(a, b);
		else
			System.out.println("Gerçek kök yok");		
	}
	
	public static void printDifferentRoots(double a, double b, double delta)
	{
		double sqrtDelta = Math.sqrt(delta);
		double x1 = (-b + sqrtDelta) / (2 * a);
		double x2 = (-b - sqrtDelta) / (2 * a);
		
		System.out.printf("x1 = %f, x2 = %f%n", x1, x2);
		
	}
	
	public static void printSameRoots(double a, double b)
	{
		double x = -b / (2 * a);
		
		System.out.printf("x1 = x2 = %f%n", x);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	 Sınıf Çalışması: Klavyeden katsayıları girilen ikinci dereceden bir denklemin köklerini bulan programı yazınız
	 Not: İleride daha iyisi yazılacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		QuadraticEquationApp.run();		
	}
}

class QuadraticEquationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Kaysayıları giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c = kb.nextDouble();
		
		QuadraticEquation.findRoots(a, b, c);		
	}
}

class QuadraticEquation {
	public static double calculateDelta(double a, double b, double c)
	{
		return b * b - 4  * a * c;
	}
	
	public static void findRoots(double a, double b, double c)
	{
		double delta = calculateDelta(a, b, c);
		
		if (delta >= 0) 
			printRoots(a, b, delta);		
		else
			System.out.println("Gerçek kök yok");		
	}
	
	public static void printRoots(double a, double b, double delta)
	{
		double sqrtDelta = Math.sqrt(delta);
		double x1 = (-b + sqrtDelta) / (2 * a);
		double x2 = (-b - sqrtDelta) / (2 * a);
		
		System.out.printf("x1 = %f, x2 = %f%n", x1, x2);
		
	}	
}

/*----------------------------------------------------------------------------------------------------------------------	 
	16.09.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	Döngüler (loops): Bir takım işlemlerin yinelemeli olarak yapılmasını sağlayan kontrol deyimleridir. Java'da döngü
	deyimleri şunlardır: 
	1. while döngü deyimleri
		- Kontrolün başta yapıldığı while döngü deyimi (while döngüsü)
		- Kontrolün sonda yapıldığı whike döngü deyimi (do-while döngüsü)
	2. for döngü deyimi
	3. for-each döngü deyimi (enhanced for loop)
	
	Anahtar Notlar: while döngüsü dendiğinde ilk akla gelen kontrolün başta yapıldığı while döngü deyimidir.
	Biz de "while döngüsü" dediğimizde bunu anlayacağız. Kontrolün sonda yapıldığı while döngü deyimi için  
	"do-while döngüsü" diyeceğiz 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Kontrolün başta yapıldığı while döngü deyiminin (while döngüsü) genel biçimi şu şekildedir:
	
	while (<koşul ifadesi>)
		<deyim>
	
	Burada koşul ifadesi boolen türden olmalıdır. while döngü deyimi parantez içerisindeki koşul doğru olduğu sürece
	yani koşul ifadesi true olduğu sürece yinelenir. Akış while döngüsüne geldiğinde de koşul kontrol edilir, duruma
	göre döngüye hiç girmeyebilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = 0;
		
		while (i < n) {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.printf("%ni = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	while döngü deyiminde yanlışlıkla noktalı virgül kullanılması durumu
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = 0;
		
		while (i < n); {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.printf("%ni = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	while döngü deyiminde n-kez dönen döngü kalıbı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = 0;
		
		while (i < n) {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.printf("%ni = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	while döngü deyiminde n-kez dönen döngü kalıbı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = 1;
		
		while (i <= n) {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.printf("%ni = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	while döngü deyiminde n-kez dönen döngü kalıbı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i = n - 1;
		
		while (i >= 0) {
			System.out.printf("%d ", i);
			--i;
		}
		
		System.out.printf("%ni = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	while döngü deyiminde n-kez döngü kalıbı. Bu döngü bir kalıp olarak hatırlanmalıdır. Bazı programcolar bazı
	durumlarda bu döngüyü kullanılırlar. Bu döngü kullanılmasa da programcı tarafından görüldüğünde tanınmalıdır. Ayrıca 
	bu döngüde while parantezi içerisinde kullanılan değişkenin değerinin değiştiğine dikkat ediniz. Döngüden sonra bu
	değişkenin önceki değeri kullanılmak istenirse başka bir değişkende saklanmalıdır
	
	n = 4 olsun 
	Döngü içerisinde n	: 3 -> 2 -> 1 -> 0
	Yineleme sayısı		: 1 -> 2 -> 3 -> 4
	Döngü sonrası n		: -1
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		while (n-- > 0)
			System.out.printf("%d ", n);
		
		System.out.printf("%nn = %d%n", n);
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	while döngü deyiminde bir değişkene bir metodun geri dönüş değerinin atandıktan sonra kontrolüne ilişkin compact
	ifadeler kullanılabilir. Bu durumda atama işleminin öncelikli olarak yapılması için atama işlemi parantez içerisinde
	yazılmalıdır. Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Sayıları girmeye başlayınız:");
		int total = 0;
		int val;
		
		while ((val = kb.nextInt()) != 0)
			total += val;
		
		System.out.printf("Toplam:%d%n", total);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan sayılardan pozitif olanlarının ve negatif olanlarının ayrı
	ayrı toplamlarını ve kaçar tane olduklarını bulan programı yazınız.
	Açıklamalar:
		- Program hiç pozitif ve/veya negatif sayı girilmezse de uygun mesajı (örneğin: Hiç pozitif sayı girilmedi!...)
		 verecektir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		FindPosNegCountAndTotalApp.run();
	}
}


class FindPosNegCountAndTotalApp {
	public static void printPositiveResult(int total, int count)
	{
		if (count != 0)
			System.out.printf("%d adet pozitif sayı girdiniz. Toplamı:%d%n", count, total);
		else
			System.out.println("Hiç pozitif sayı girmediniz!...");
	}
	
	public static void printNegativeResult(int total, int count)
	{
		if (count != 0)
			System.out.printf("%d adet negatif sayı girdiniz. Toplamı:%d%n", count, total);
		else
			System.out.println("Hiç negatif sayı girmediniz!...");
	}
	
	public static void printResult(int posTotal, int posCount, int negTotal, int negCount)
	{
		printPositiveResult(posTotal, posCount);
		printNegativeResult(negTotal, negCount);
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Sayıları girmeye başlayınız");
		int posTotal = 0, negTotal = 0, posCount = 0, negCount = 0;
		
		int val;
		
		while ((val = kb.nextInt()) != 0)
			if (val > 0) {
				posTotal += val;
				++posCount;
			}
			else {
				negTotal += val;
				++negCount;
			}
		
		printResult(posTotal, posCount, negTotal, negCount);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan sayılardan pozitif olanlarının ve negatif olanlarının ayrı
	ayrı toplamlarını ve kaçar tane olduklarını bulan programı yazınız.
	Açıklamalar:
		- Program hiç pozitif ve/veya negatif sayı girilmezse de uygun mesajı (örneğin: Hiç pozitif sayı girilmedi!...)
		 verecektir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		FindPosNegCountAndTotalApp.run();
	}
}


class FindPosNegCountAndTotalApp {
	public static void printPositiveResult(int total, int count)
	{
		if (count != 0)
			System.out.printf("%d adet pozitif sayı girdiniz. Toplamı:%d%n", count, total);
		else
			System.out.println("Hiç pozitif sayı girmediniz!...");
	}
	
	public static void printNegativeResult(int total, int count)
	{
		if (count != 0)
			System.out.printf("%d adet negatif sayı girdiniz. Toplamı:%d%n", count, total);
		else
			System.out.println("Hiç negatif sayı girmediniz!...");
	}
	
	public static void printResult(int posTotal, int posCount, int negTotal, int negCount)
	{
		printPositiveResult(posTotal, posCount);
		printNegativeResult(negTotal, negCount);
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.println("Sayıları girmeye başlayınız");
		int posTotal = 0, negTotal = 0, posCount = 0, negCount = 0;
		
		int val;
		
		System.out.print("Bir sayı giriniz:");
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			if (val > 0) {
				posTotal += val;
				++posCount;
			}
			else {
				negTotal += val;
				++negCount;
			}
			
			System.out.print("Bir sayı giriniz:");
		}
		
		printResult(posTotal, posCount, negTotal, negCount);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sonsuz Döngü (Infinite loop): Koşul ifadesinden dolayı sonlanmayan döngüdür. Yani koşul ifadesinin hep true olduğu
	bir döngüdür. Bu anlamda hiç sonlanmayan bir döngü bir sonsuz döngüdür. Aynı zamanda örneğin bir metot içerisinde
	yazılan bir döngüde return deyimi kullanılırsa da metot sonlandığı için sonsuz döngüden de çıkılmış olur. 
	
	while döngüsü ile sonsuz döngü şu gibi oluşturulabilir:
	
	while (true)
		<deyim>
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısına geri dönen digitsCount isimli metodu
	NumberUtil isimli sınıf içerisinde yazınız ve aşağıdaki kod ile test ediniz  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilDigitsCountTest.run();
	}
}

class NumberUtilDigitsCountTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d saysının basamak sayısı:%d%n", val, NumberUtil.digitCount(val));
			
			if (val == 0)
				return;
		}
	}
}

class NumberUtil {
	public static int digitCount(int val)
	{
		if (val == 0)
			return 1;
		
		int count = 0;
		
		while (val != 0) {
			++count;
			val /= 10;
		}
		
		return count;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamakları toplamına geri döenen digitsSum isimli
	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz 
	Açıklama: Sayı negatif ise basamaklar toplamı yine pozitif olacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilDigitsSumTest.run();
	}
}

class NumberUtilDigitsSumTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d saysının basamakları toplamı:%d%n", val, NumberUtil.digitsSum(val));
			
			if (val == 0)
				return;
		}
	}
}

class NumberUtil {
	public static int digitsSum(int val)
	{
		int total = 0;
		
		while (val != 0) {
			total += val % 10;
			val /= 10;
		}
		
		return Math.abs(total);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının tersine geri dönen reversed isimli metodu NumberUtil
	sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Algoritması için örnekler:
		123 -> 3 * 10 + 2 = 32 -> 32 * 10 + 1 = 321
		-123 -> -3 * 10 - 2 = -32 -> -32 * 10 - 1 = -321
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilReversedTest.run();
	}
}

class NumberUtilReversedTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d saysının tersi:%d%n", val, NumberUtil.reversed(val));
			
			if (val == 0)
				return;
		}		
	}
}

class NumberUtil {
	public static int reversed(int val)
	{
		int result = 0;
		
		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Kontrolün sonda yapıldığı while döngüsünün (do-while) genel biçimi şu şekildedir:
	do 
		<deyim>		
	while (<koşul ifadesi>);
	
	Akış do-while döngüsüne geldiğinde koşul kontrolü yapılmaz. Yani bu döngünün ilk adımı çalıştırılmış olur. Koşul
	kontrolü ilk adımdan sonra yapılır. Yani kısaca bu döngünün en az bir adımının çalıştırılacağı garanti altındadır.
	Bu döngü deyimi while döngüsü kadar yoğun kullanılmasa da bazı durumlarda okunabilirliği artırmak için tercih
	edilebilir. Bununla birlikte gereksiz yer kullanımı okunabilirliği azaltabilir. Kodu okuyan kişi do-while döngüsü
	gördüğünde kişinin azdığı algoritmada o döngünün ilk adımının kesin yapıldığı algısını oluşuturur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		int i = 0;
		
		do {
			System.out.printf("%d ", i);
			++i;
		} while (i < n);
		
		System.out.println("\n"
				+ "Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısına geri dönen digitsCount isimli metodu
	NumberUtil isimli sınıf içerisinde yazınız ve aşağıdaki kod ile test ediniz  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilDigitsCountTest.run();
	}
}

class NumberUtilDigitsCountTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d saysının basamak sayısı:%d%n", val, NumberUtil.digitCount(val));
			
			if (val == 0)
				return;
		}
	}
}

class NumberUtil {
	public static int digitCount(int val)
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
		} while (val != 0);
		
		return count;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte val değişkeni yerel değişken olduğundan faaliyet alanı kuralları gereği while parantezi içerisinde
	kullanılamaz.
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		do {
			System.out.println("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d * %d = %d%n", val, val, val * val);
		} while (val != 0); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıdaki örnek aşağıdaki gibi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		int val;
		
		do {
			System.out.println("Bir sayı giriniz:");
			val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d * %d = %d%n", val, val, val * val);
		} while (val != 0);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	17.09.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	for döngü deyimi: for döngü deyimi Java'da en yetenekli döngü deyimidir. Aslında diğer döngü deyimlerini de 
	kapsamaktadır. Ancak şüphesiz her durumda for döngü kullanılması gerekmez. for döngü deyiminin genel biçimi
	şu şekildedir:
	
	for ([1.kısım]; [2.kısım]; [3.kısım])
		<deyim>
		
	Görüldüğü gibi for döngü deyiminin 3 kısmı da olmayabilir. Ancak iki tane noktalı virgül her zaman gerekir
	1.kısım: Akış for döngüsüne geldiğinde yapılır. 1.kısım yalnızca 1 kez yapılır.
	
	2.kısım: Koşul ifadesine ilişkin bölümdür. boolean türden bir ifade olmalıdır. for döngü deyimi 2.kısımdaki
	ifade true ise yinelenir. Bı döngü deyiminde 1.kısım yapıldıktan sonra da koşul kontrolü yapılır. Yani duruma
	göre döngüye hiç girmeyebilir.
	
	3.kısım: Döngünün bir adımı tamamlandığında, bir sonraki adıma geçip geçmeme kontrolünü yapmadan önce yapılan
	kısımdır.
	
	Anahtar Notlar: for döngü deyiminin bölümleri içerisinde kullanılan değişkenlere genel olarak döngü değişkeni 
	denir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i;
		
		for (i = 0; i < n; ++i)
			System.out.printf("%d ", i);
		
		System.out.println();
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	for döngü deyiminde 1.kısımda değişken bildirimi yapılabilir. Bu değişken bir yerel değişken olduğundan aynı faaliyet
	alanında aynı isimde başka bir yerel değişken olamaz. Aşağıdaki örnekte döngü değişkeni 1.kısımda bildirilmiş ve 
	ilkdeğerlenmiştir (initialization)
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		for (int i = 0; i < n; ++i)
			System.out.printf("%d ", i);
		
		System.out.println();
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	for döngüsünde 1.kısımda bildirilen değişken yalnızca döngü deyiminde kullanılabilir. Döngü deyiminden sonra 
	artık faaliyet alanı bitmiş olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		for (int i = 0; i < n; ++i)
			System.out.printf("%d ", i);
		
		System.out.println(i); //error
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte bildirilen döngü değişkenleri geçerlidir. Çünkü faaliyet alanları (scope) çakışmaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		for (int i = 0; i < n; ++i)
			System.out.printf("%d ", i);
		
		System.out.println();
		
		for (int i = 0; i < n; ++i)
			System.out.printf("%d ", i);
		
		System.out.println();
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	for döngüsünde, döngü değişkeninin son değeri döngüden sonra kullanılmayacaksa, döngü içerisinde bildirimi tavsiye
	edilir. Çünkü bu durumda döngü değişkenin döngüden önce bildirildiği döngülerin okunabilirliği artar. Çünkü döngü 
	değişkenin döngüden önce bildirilmesi durumunda kodu okuyan programcı döngü değişkenin döngüden sonra son değerinin
	kullanıldığını anlar
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i;
		
		for (i = 0; i < n; ++i)
			System.out.printf("%d ", i);
		
		System.out.printf("%ni = %d%n", i);
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	for döngü deyiminde yanlışıkla noktalı virgül kullanılması durumu. Aşağıdaki örnekte bir error durumu oluşmaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i;
		
		for (i = 0; i < n; ++i);
			System.out.printf("%d ", i);
	
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte döngü değişkeni döngü içerisinde bildirilşdiği için error oluşur. Bu durumda programcı yanlışlıkla
	noktalı virgül koymasından dolayı böcekli (bug) bir kod yazmamış olur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		for (int i = 0; i < n; ++i);
			System.out.printf("%d ", i);//error
	
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	for döngü deyiminde birinci ve üçüncü kısımda virgül bir ayraç olarak ifadeleri ayırmak için kullanılabilir. Virgül 
	Java'da bir operatör değildir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		int i;
		
		for (i = 0, System.out.println("Akış for döngüsünde"), System.out.println("1.Kısım"); i < n; 
				System.out.println("3.kısım"), ++i)
			System.out.println("Deyim");
	
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	for döngüsünde birinci kısımda birden fazla değişken bildirimi yapılabilir. Bu durumda değişkenler aynı türden
	olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		
		for (int i = 0, k = 20; i < 10 && k >= 0; ++i, --k)
			System.out.printf("(%d, %d)%n", i, k);
	
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	for döngüsünde birinci kısımda bir bildirim yapıldığında artık başka bir ifade yazılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		
		for (int i = 0, System.out.println("1.kısım"); i < 10; ++i) //error
			System.out.printf("%d ", i);
	
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnek geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int i;
		double k;
		
		for (i = 0, k = 2.34; i < 1000 && k > 1.456; ++i, k -= 0.01)
			System.out.printf("i = %d, k = %f%n", i, k);
	
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmaktadır. Örnekte dikkat edilirse
	for döngü deyiminin her bir adımı için boş deyim kullanılmıştır. Çünkü zaten toplama işlemi 3.kısımda yapılmaktadır.
	Şüphesiz bu kod okunabilir değildir ancak Java programcısı for döngü deyiminin çalışma sistemini bilmeli ve böyle bir
	kodu yazabilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		int total = 0;
		int val;
		
		for (System.out.println("Sayıları girmeye başlayınız:"), System.out.print("Bir sayı giriniz:"); 
				(val = Integer.parseInt(kb.nextLine())) != 0; total += val, System.out.print("Bir sayı giriniz:"))
			;
		
		System.out.printf("Total = %d%n", total);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir değerin faktoriyel değerine geri dönen factorial isimli 
	metodu NumberUtil sınıfı içerisinde yazınız ve [-1, 13) aralığındaki sayıların faktoriyelini ekrana bastırarak kodu 
	test ediniz:
	Açıklamalar:
		- Faktoriyel işlemi 
		0! = 1
		1! = 1
		2! = 1 * 2
		3! = 1 * 2 * 3
		...
		n! = 1 * 2 * ... * n- 1 * n
		
		- Negatif sayılar için faktoriyel değeri 1 olarak döndürülecektir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilFactorialTest.run();
	}
}

class NumberUtilFactorialTest {
	public static void run()
	{
		for (int n = -1; n < 13; ++n)
			System.out.printf("%d! = %d%n", n, NumberUtil.factorial(n));
	}
}

class NumberUtil {
	public static int factorial(int n)
	{
		int result = 1;
		
		for (int i = 2; i <= n; ++i)
			result *= i;
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden taban ve üzs bilgisine göre a'nın b-inci kuvvetini döndüren
	pow isimli metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- Metot üssün negatif olması durumunda 1 değerine geri dönecektir
		- Metot içerisinde Math sınıfının pow metodu kullanılmayacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilPowTest.run();
	}
}

class NumberUtilPowTest {
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Tabanı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
		
			System.out.print("Üssü giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			
			System.out.printf("pow(%d, %d) = %d%n", a, b, NumberUtil.pow(a, b));
			
			if (b <= 0)
				return;
		}
		
	}
}

class NumberUtil {
	public static int pow(int a, int b) 
	{
		int result = 1;
		
		for (int i = 0; i < b; ++i)
			result *= a;
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden taban ve üzs bilgisine göre a'nın b-inci kuvvetini döndüren
	pow isimli metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- Metot üssün negatif olması durumunda 1 değerine geri dönecektir
		- Metot içerisinde Math sınıfının pow metodu kullanılmayacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilPowTest.run();
	}
}

class NumberUtilPowTest {
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Tabanı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
		
			System.out.print("Üssü giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			
			System.out.printf("pow(%d, %d) = %d%n", a, b, NumberUtil.pow(a, b));
			
			if (b <= 0)
				return;
		}
		
	}
}

class NumberUtil {
	public static int pow(int a, int b) 
	{
		int result = 1;
		
		while (b-- > 0)
			result *= a;
		
		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı bir sayının basamaklarının basamak sayıncı kuvvetleri toplamının kendisine
	eşit olup olmadığını test eden isArmstrong isimli metodu yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- 153 sayısı 3 basamaklıdır ve 1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3 = 153'dür.
		
		- Negatif sayılar için metot false değerine geri dönecektir.
		
		- Kuvvet alma işlemi için bir önceki örnekteki pow metodu kullanılacaktır.
		
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilIsArmstrongTest.run();
	}
}

class NumberUtilIsArmstrongTest {
	public static void run() 
	{
		for (int n = -1; n <= 999_999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);
	}
}

class NumberUtil {	
	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}
	
	public static int getDigitsPowSum(int val)
	{
		int n = digitsCount(val);
		int result = 0;
		
		while (val != 0) {
			result += pow(val % 10, n);
			val /= 10;
		}
		
		return result;
	}
	
	public static int digitsCount(int val)
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
		} while (val != 0);
		
		return count;
	}
	
	public static int pow(int a, int b) 
	{
		int result = 1;
		
		while (b-- > 0)
			result *= a;
		
		return result;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	23.09.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünde 1.kısım boş bırakıldığında akış for döngüsüne geldiğinde yalnızca koşul kontrolü yapılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		int i = 0;
		
		for (; i < n; ++i) 
			System.out.printf("%d ", i);
		
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünde 3.kısım boş bırakıldığında her adım sonunda koşul kontrol edilmeden herhangi bir işlem yapılmamış
	olur. Şüphesiz programcı bu duruma göre kodunu düzenlemelidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		for (int i = 0; i < n;) { 
			System.out.printf("%d ", i);
			++i;			
		}
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünde 1. ve 3. kısımlar boş bırakıldığında while döngü deyimi gibidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		int i = 0;
		
		for (; i < n;) { //while (i < n) {  
			System.out.printf("%d ", i);
			++i;			
		}
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünde ikinci kısmın boş bırakılması durumu true yazılmasıyla aynı anlamdadır. Yani sonsuz döngüdür
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);	

		for (int i = 0; ; ++i)  
			System.out.printf("%d%n", i);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	for döngüsünde sonsuz döngü oluşturmak için programcılar okunabilirlik açısından 3 kısmı da boş bırakırlar
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);	
	
		for (;;) {
			//...
		}
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sonsuz döngü sanılan ancak olmayan bir döngü örneği
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		int i;
		for (i = 0; i < 10; --i)
			;//System.out.println(i);
			
			
		System.out.printf("i = %d%n", i);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		int i;
		for (i = 20; i >= 0; ++i)
			;//System.out.println(i);
			
		System.out.printf("i = %d%n", i);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrime isimli
	metodu yazınız
	Asal Sayı: Yalnızca 1'e ve kendisine bölünebilen pozitif sayılara asal sayı denir
	(Yavaş versiyon) 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilIsPrimeTest.run();
	}
}

class NumberUtilIsPrimeTest {
	public static void run()
	{
		for (long i = -10; i <= 100; ++i)
			if (NumberUtil.isPrime(i))
				System.out.printf("%d ", i);
		
		System.out.println();
		
		System.out.println(NumberUtil.isPrime(1_000_003));			 
	}
}

class NumberUtil {
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		for (long i = 2; i <= val / 2; ++i)
			if (val % i == 0)
				return false;
		
		return true;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrime isimli
	metodu yazınız
	Asal Sayı: Yalnızca 1'e ve kendisine bölünebilen pozitif sayılara asal sayı denir
	
	Kural: Bir sayı kare kökünden küçük olan asal sayıların hiç birisine bölünmüyorsa asaldır
	(Daha hızlı versiyon)
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilIsPrimeTest.run();
	}
}

class NumberUtilIsPrimeTest {
	public static void run()
	{			
		for (long i = -10; i <= 100; ++i)
			if (NumberUtil.isPrime(i))
				System.out.printf("%d ", i);
		
		System.out.println();
		
		System.out.println(NumberUtil.isPrime(1_000_003));
	}
}

class NumberUtil {
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		for (long i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;
		
		return true;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte isPrime metotlarının demo bir counter testi yapılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilIsPrimeTest.run();
	}
}

class NumberUtilIsPrimeTest {
	public static void run()
	{		
		System.out.println(NumberUtil.isPrime(1_000_003));
		System.out.println(NumberUtil.isPrimeSlow(1_000_003));
	}
}

class NumberUtil {
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		int count = 0;
		
		for (long i = 11; i * i <= val; i += 2) {
			++count;
			if (val % i == 0)
				return false;
		}
		
		System.out.printf("isPrime:count:%d%n", count);
		
		return true;		
	}
	
	public static boolean isPrimeSlow(long val)
	{
		if (val <= 1)
			return false;
		
		int count = 0;
		for (long i = 2; i <= val / 2; ++i) {
			++count;
			if (val % i == 0)
				return false;
		}
		
		System.out.printf("isPrimeSlow:count:%d%n", count);
		return true;
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	Yukarıdaki algoritmanın Matematiksel olarak daha hızlısı vardır. Ancak burada ele alınmayacaktır. Çoğu zaman
	bu algoritma yeterli olacaktır. Eğer çok büyük sayılarla çalışılmıyorsa sayının yarısına kadar dolaşan algoritma da
	yeterli olabilir. Yukarıdaki iki algoritmayı aşağıdaki asal sayılar ile çalıştırıp sonuçları gözlemleyebilirsiniz:
	
	6750161072220585911
	1603318868174368979
	6584583408148485263
	6245098347044246839
	6285871677077738093
	5697859706174583067
	710584055392819667
	4935060337471977161
	3728803592870153407
	4331452335614730577
	1386437196678024971
	1677990107453991593
	4765603950744460867
	4498306523077899307
	4434895834573449257	
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı pozitif bir n değeri için n-inci asal sayıya geri dönen nthPrime isimli
	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- n değerinin pozitif olup olmadığı kontrol edilmeyecektir		
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilNthPrimeTest.run();
	}
}

class NumberUtilNthPrimeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n <= 0)
				return;
			
			System.out.printf("%d. asal sayı:%d%n", n, NumberUtil.nthPrime(n));
		}
	}
}

class NumberUtil {
	public static long nthPrime(int n)
	{
		long val = 2;
		int count = 0;
		
		for (long i = 2; count < n; ++i)
			if (isPrime(i)) {
				++count;
				val = i;
			}
		
		return val;
	}
	
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		for (long i = 11; i * i <= val; i += 2)		
			if (val % i == 0)
				return false;
		
		return true;		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı pozitif bir n değeri için n-inci asal sayıya geri dönen nthPrime isimli
	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- n değerinin pozitif olup olmadığı kontrol edilmeyecektir		
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilNthPrimeTest.run();
	}
}

class NumberUtilNthPrimeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n <= 0)
				return;
			
			System.out.printf("%d. asal sayı:%d%n", n, NumberUtil.nthPrime(n));
		}
	}
}

class NumberUtil {
	public static long nthPrime(int n)
	{
		long val = 2;
		int count = 0;
		
		while (true) {
			if (isPrime(val))
				++count;
			
			if (count == n)
				return val;
			
			++val;
		}
	}
	
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		for (long i = 11; i * i <= val; i += 2)		
			if (val % i == 0)
				return false;
		
		return true;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	24.09.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir sayıdan büyük ilk asal sayıya geri dönen nextClosestPrime isimli metodu 
	yazınız ve aşağıdaki kod ile test ediniz
	
	Not: Aşağıdaki örnekte sayının üstten taşması (over flow) durumu kontrol edilmemiştir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilNextClosestPrimeTest.run();
	}
}

class NumberUtilNextClosestPrimeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			long n = Long.parseLong(kb.nextLine());		
			
			
			System.out.printf("%d. sayısından büyük ilk asal sayı:%d%n", n, NumberUtil.nextClosestPrime(n));
			
			if (n == 0)
				return;
		}
	}
}

class NumberUtil {
	public static long nextClosestPrime(long val)
	{		
		while (!isPrime(++val))
			;
		
		return val;		
	}
	
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		for (long i = 11; i * i <= val; i += 2)		
			if (val % i == 0)
				return false;
		
		return true;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir sayıdan küçük en büyük asal sayıya geri dönen previousClosestPrime isimli metodu 
	yazınız ve aşağıdaki kod ile test ediniz
	
	Not: Aşağıdaki örnekte sayının alttan taşması (under flow) durumu kontrol edilmemiştir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilPreviousClosestPrimeTest.run();
	}
}

class NumberUtilPreviousClosestPrimeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			long n = Long.parseLong(kb.nextLine());		
			
			
			System.out.printf("%d. sayısından küçük en büyük asal sayı:%d%n", n, NumberUtil.previousClosestPrime(n));
			
			if (n == 0)
				return;
		}
	}
}

class NumberUtil {
	public static long previousClosestPrime(long val)
	{		
		while (!isPrime(--val))
			;
		
		return val;
	}
	
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		for (long i = 11; i * i <= val; i += 2)		
			if (val % i == 0)
				return false;
		
		return true;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İçiçe döngülerde dıştaki döngünün bir adımı için içteki döngü tamamlanır. Bu durumda örneğin içiçe iki döngünün 
	toplam dönme sayısı "dıştaki döngünün adım sayısı * içteki döngünün adım sayısı" kadardır. Örnek durumu göstermek
	için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int m = kb.nextInt();
		int n = kb.nextInt();
		
		for (int i = 0; i < m; ++i)
			for (int k = n - 1; k >= 0; --k)
				System.out.printf("(%d, %d)%n", i, k);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bazen programcı tek bir döngü yazsa bile, döngü içerisinde çağırmış olduğu bir metot da döngüye girdiğinde dolaylı
	olarak içiçe döngü kullanmış olur. Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int m = kb.nextInt();
		int n = kb.nextInt();
		
		for (int i = 0; i < m; ++i)
			Sample.doWork(i, n);
	}
}

class Sample {
	public static void doWork(int i, int n)
	{
		for (int k = n - 1; k >= 0; --k)
			System.out.printf("(%d, %d)%n", i, k);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Prtaikte içiçe döngüler için, 2 veya 3 döngü karşımıza çok fazla çıkabilir. Programcı özellikle 
	3'den fazla içiçe döngü ile bir algoritmayı gerçekleştirmişse, algoritmasını tekrar gözden geçirmesi tavsiye edilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte içiçe döngü kullanılarak 3 basamaklı Armstrong sayıları bulunmuştur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		for (int a = 1; a <= 9; ++a)
			for (int b = 0; b <= 9; ++b)
				for (int c = 0; c <= 9; ++c)
					if (100 * a + 10 * b + c == a * a * a + b * b * b + c * c * c)
						System.out.printf("%d%d%d ", a, b, c);
		
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	break deyimi: break deyimi döngüyü sonlandırmak için kullanılır. break deyiminin genel biçimi şu şekildedir:
	
		break [etiket ismi];
		
	break deyiminin tek başına kullanımına etiketsiz break ya da sadece break, etiket ile kullanımına ise etiketli break
	deyimi denilmektedir. break tek başına kullanıldığında, akış break deyimine geldiğinde ilgili döngü sonlanır ve akış
	döngü deyiminden sonraki deyimle devam eder. break deyimi ya bir döngü deyimi içerisinde ya da  ileride göreceğimiz 
	switch deyimi içerisinde kullanılabilir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Sayıları girmeye başlayınız:");
		int total = 0;				
		
		while (true) {
			int val = kb.nextInt();
			
			if (val == 0)
				break;
			
			total += val;
		}
		
		System.out.printf("Toplam:%d%n", total);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı pozitif bir n değeri için n-inci asal sayıya geri dönen nthPrime isimli
	metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- n değerinin pozitif olup olmadığı kontrol edilmeyecektir		
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		NumberUtilNthPrimeTest.run();
	}
}

class NumberUtilNthPrimeTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n <= 0)
				break;
			
			System.out.printf("%d. asal sayı:%d%n", n, NumberUtil.nthPrime(n));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static long nthPrime(int n)
	{
		long val = 2;
		int count = 0;
		
		while (true) {
			if (isPrime(val))
				++count;
			
			if (count == n)
				return val;
			
			++val;
		}
	}
	
	public static boolean isPrime(long val)
	{
		if (val <= 1)
			return false;
		
		if (val % 2 == 0)
			return val == 2;
		
		if (val % 3 == 0)
			return val == 3;
		
		if (val % 5 == 0)
			return val == 5;
		
		if (val % 7 == 0)
			return val == 7;
	
		for (long i = 11; i * i <= val; i += 2)		
			if (val % i == 0)
				return false;
		
		return true;		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte içteki döngüde bir koşul gerçekleştiğinde dıştaki döngünün sonlanrılması için flag değişken 
	kullanılmıştır. Örnek durumu göstermek için yazılmıştır		
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{
		boolean exitFlag = false;
		
		for (int i = 2; i <= 20; ++i) { 
			for (int k = 30; k >= 3; --k) {
				System.out.printf("(%d, %d)%n", i, k);
				
				if ((i + k) % 6 == 0) {
					exitFlag = true;
					break;
				}
			}
			if (exitFlag)
				break;
		}
				
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Etiketli break deyimi, etiketin bildirildiği kontrol deyiminin (tipik olarak döngü deyimi) sonlanmasını sağlar. Etiket
	ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Ancak bir convention etiket isimlerinin
	tamamı büyük harf ile, birden fazla kelimeden oluşuyorsa kelimeler arasına alttire karakteri kullanılarak bildirim
	yapılır. Etiket bildirimi etiket isminden sonra : ile birlikte ilgili kontrol deyiminden önce yapılır. Etiket ismi
	bildirildiği döngü boyunca görülebilirdir. Yukarıdaki etiketli break kullanılarak aşağıdaki gibi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		EXIT_LOOP:
		for (int i = 2; i <= 20; ++i) 
			for (int k = 30; k >= 3; --k) {
				System.out.printf("(%d, %d)%n", i, k);
				
				if ((i + k) % 6 == 0)
					break EXIT_LOOP;
			}	
				
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyimiz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		EXIT_LOOP:
		for (int i = 2; i <= 20; ++i) 
			EXIT_INNER_LOOP:
			for (int j = 3; j <= 40; ++j) 
				for (int k = 30; k >= 3; --k) {
					System.out.printf("(%d, %d, %d)%n", i, j, k);
					
					if ((i +  j + k) % 11 == 0)
						break EXIT_LOOP;
					
					if ((i +  j + k) % 7 == 0)
						break EXIT_INNER_LOOP;
				}	
					
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	continue deyimi: Bu deyim döngünün bir adımını sonlandırmak için kullanılır. continue deyimi yalnızca döngü deyimlerinde
	kullanılabilir. continue deyimi, break deyimi kadar çok kullanılmasa da okunabilirliği artırmak için tercih edilebilir.
	Aşağıdaki örnek continue deyiminin nasıl çalıştığını göstermek için yazılmıştır. Şüphesiz başka yöntemlerle de yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int n = kb.nextInt();
		
		for (int i = 1; i <= n; ++i) {
			if (i % 2 == 0)
				continue;
			
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Aslında continue deyiminin de etiketli kullanımı söz konusudur. Ancak programlama tekniği açısından
	kullanımı tavsiye edilmez. Aşağıdaki kullanım tavsiye edilmez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		CONTINUE_LOOP:
		for (int i = 2; i <= 20; ++i) 
			for (int k = 30; k >= 3; --k) {
				System.out.printf("(%d, %d)%n", i, k);
				
				if ((i + k) % 6 == 0)
					continue CONTINUE_LOOP;
			}	
				
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek break deyimi ile hem daha okunabilir hem de daha basit bir biçimde yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		for (int i = 2; i <= 20; ++i) 
			for (int k = 30; k >= 3; --k) {
				System.out.printf("(%d, %d)%n", i, k);
				
				if ((i + k) % 6 == 0)
					break;
			}	
				
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo menü uygulamasını inceleyiniz
	
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DemoMenuApp.run();
	}
}

class DemoMenuApp {
	public static void printMenu()
	{		
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Ara");
		System.out.println("4.Sil");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doInsert()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ekle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doUpdate()
	{
		System.out.println("-------------------------------------");
		System.out.println("Güncelle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doSearch()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ara seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doDelete()
	{
		System.out.println("-------------------------------------");
		System.out.println("Sil seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doOption(int option)
	{
		if (option == 1)
			doInsert();
		else if (option == 2)
			doUpdate();
		else if (option == 3)
			doSearch();
		else 
			doDelete();
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			printMenu();
			int option = Integer.parseInt(kb.nextLine());
			
			if (option < 1 || option > 5) {
				System.out.println("-------------------------------------");
				System.out.println("Geçersiz seçenek!...");
				System.out.println("-------------------------------------");
				continue;
			}
			
			if (option == 5)
				break;
			
			doOption(option);
		}
		
		System.out.println("C ve Sistem Programcıları Derneği");
		System.out.println("Teşekkür ederiz");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Herhangi bir noktada (yani herhangi bir metot içerisinde) programı sonlandırmak için System.exit 
	metodu çağrılabilir. Bu metodun int türden bir parametresi vardır. Bu parametre "exit code" değeridir. Bu değer 
	teknik olarak program sonlandığında JVM'e oradan da işletim sistemine iletilen bir değerdir. Bu değerin çoğu zaman 
	önemi yoktur. Bu değerin anlamı uygulama kurslarında ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki demo menü uygulaması aşağıdaki gibi de yazılabilir
	
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DemoMenuApp.run();
	}
}

class DemoMenuApp {
	public static void printMenu()
	{		
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Ara");
		System.out.println("4.Sil");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doInsert()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ekle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doUpdate()
	{
		System.out.println("-------------------------------------");
		System.out.println("Güncelle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doSearch()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ara seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doDelete()
	{
		System.out.println("-------------------------------------");
		System.out.println("Sil seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doExit()
	{
		System.out.println("C ve Sistem Programcıları Derneği");
		System.out.println("Teşekkür ederiz");
		System.exit(0);
	}
	
	public static void doInvalidOption()
	{
		System.out.println("-------------------------------------");
		System.out.println("Geçersiz seçenek!...");
		System.out.println("-------------------------------------");
	}
	
	public static void doOption(int option)
	{
		if (option == 1)
			doInsert();
		else if (option == 2)
			doUpdate();
		else if (option == 3)
			doSearch();
		else if (option == 4)
			doDelete();
		else if (option == 5)
			doExit();
		else
			doInvalidOption();		
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			printMenu();
			doOption(Integer.parseInt(kb.nextLine()));		
		}		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir n değeri için n-inci Fibonacci sayısına geri dönen nthFibonacciNumber 
	isimli metodu NumberUtil sınıfı içerisinde aşağıdaki açıklamalara göre yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- n değerinin pozitif olup olmadığı kontrolü yapılmayacaktır
		- Fibonacci sayılarına ilişkin seri şu şekildedir
			0 1 1 2 3 5 8 13 21 ...	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		NumberUtilNthFibonacciNumberTest.run();
	}
}

class NumberUtilNthFibonacciNumberTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n <= 0)
				break;
			
			System.out.printf("%d.Fibonacci sayısı:%d%n", n, NumberUtil.nthFibonacciNumber(n));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int nthFibonacciNumber(int n)
	{
		if (n <= 2)
			return n - 1;
		
		int prev1 = 1, prev2 = 0, val = prev1 + prev2;
		
		for (int i = 3; i < n; ++i) {
			prev2 = prev1;
			prev1 = val;
			val = prev1 + prev2;
		}
		
		return val;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı bir sayıdan büyük ilk Fibonacci sayısına geri dönen nextFibonacciNumber
	metodunu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		NumberUtilNextFibonacciNumberTest.run();
	}
}

class NumberUtilNextFibonacciNumberTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());			
			
			System.out.printf("%d sayısından büyük ilk Fibonacci sayısı:%d%n", val, NumberUtil.nextFibonacciNumber(val));
			
			if (val == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int nextFibonacciNumber(int val)
	{
		if (val < 0)
			return 0;
		
		int prev1 = 1, prev2 = 0;
		
		while (true) {
			int next = prev1 + prev2;
			
			if (next > val)
				return next;
			
			prev2 = prev1;
			prev1 = next;
		}
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	30.09.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	switch deyimi: 	switch belirli koşullar altında, sabit olan değerleri eşitlik karşılaştırmasına sokmak ve duruma göre
	işlem yapmak için kullanılan bir kontrol deyimidir. Yani if deyimine alternatif olmasa da belirli koşullar altında
	if deyimi yerine kullanılabilen bir deyimdir. switch deyimi okunabilirliği artırmak için if deyimi yerine tercih
	edilebilir. switch deyiminin geneş biçimi şu şekildedir:
		switch (<ifade>) {
			case <sabit ifadesi>:
				<deyim>
			case <sabit ifadesi>:
				<deyim>
				
				...
			[
			default:
				<deyim>
			]
		}
		
	switch deyiminin parantezi içerisindeki ifadenin temel türlerden tamsayı türlerinden biri veya char türünden olması
	gerekir. Gerçek sayı türlerinden biri ve boolean türünden olamaz. switch deyiminin parantezi içerisindeki ifadenin
	değeri yukarıdan aşağıya doğru case bölümlerine ilişkin sabit ifadesi ile eşitlik karşılaştırmasına sokulur ve ilk
	doğru olan (yani eşitliğin sağlandığı) case bölümünden itibaren akış switch deyiminden çıkılana kadar devam eder. 
	Eğer hiç bir case bölümü doğru olmazsa (yani eşitlik sağlanmazsa) varsa default case bölümü çalıştırılır. Default 
	case yoksa akış switch deyiminden sonrasından devam eder  
	
	Anahtar Notlar: switch deyimi temel türler dışında String sınıfı ve enum sınıflar ile de kullanılmaktadır. Bunlar
	ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki switch deyiminin if deyimi karşılığı şu şekildedir:
	
	if (plate == 34)
		System.out.println("İstanbul");
	else if (plate == 67)
		System.out.println("Zonguldak");
	else if (plate == 6)
		System.out.println("Ankara");
	else if (plate == 35)
		System.out.println("İzmir");
	else
		System.out.println("Geçersiz şehir girdiniz!...");
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Plakayı giriniz:");
		int plate = kb.nextInt();
		
		switch (plate) {
		case 34:
			System.out.println("İstanbul");
			break;
		case 67:
			System.out.println("Zonguldak");
			break;
		case 6:
			System.out.println("Ankara");
			break;
		case 35:
			System.out.println("İzmir");
			break;
		default:
			System.out.println("Geçersiz şehir girdiniz!...");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde gerçek sayı türleri kullanılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Plakayı giriniz:");
		double plate = kb.nextDouble();
		
		switch (plate) { //error
		//...
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde boolean türü kullanılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{	
		
		boolean flag = true;
		
		switch (flag) { //error
		//...
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde default bölüm olmayabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Plakayı giriniz:");
		int plate = kb.nextInt();
		
		switch (plate) {
		case 34:
			System.out.println("İstanbul");
			break;
		case 67:
			System.out.println("Zonguldak");
			break;
		case 6:
			System.out.println("Ankara");
			break;
		case 35:
			System.out.println("İzmir");
			break;		
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde aşağı düşme (fall through) özelliği vardır. Akış bir bölümü çalıştırdıktan sonra bir sonraki
	bölüme geçmeyi engelleyen bir deyime kadar veya switch sonuna kadar tüm deyimleri çalıştırır. break deyimi switch
	deyimini de sonlandırır. Aşağıdaki örneği çeşitli değerler ile çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Plakayı giriniz:");
		int plate = kb.nextInt();
		
		switch (plate) {
		case 34:
			System.out.println("İstanbul");
		case 67:
			System.out.println("Zonguldak");			
		case 6:
			System.out.println("Ankara");
			break;
		case 35:
			System.out.println("İzmir");			
		default:
			System.out.println("Geçersiz şehir girdiniz!...");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde default bölüm sonda olmak zorunda değildir. Sonda olmasa bile default bölümün anlamı değişmez. Sonda
	olmaması durumunda default bölüm çalıştırıldıktan sonra yine aşağıda düşme olur bu sebeple engellenmesi gerekir. 
	Şüphesiz default bölümün sonda yazılması okunabilirlik açısından daha normal bir durumdur. Aşağıdaki örneği
	çeşitli değerler için çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Plakayı giriniz:");
		int plate = kb.nextInt();
		
		switch (plate) {
		case 34:
			System.out.println("İstanbul");
		case 67:
			System.out.println("Zonguldak");			
		case 6:
			System.out.println("Ankara");
			break;
		default:
			System.out.println("Geçersiz şehir girdiniz!...");
		case 35:
			System.out.println("İzmir");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte fall through özelliği kullanılarak kod tekrarı engellenmiştir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		switch (code) {
		case 212:
			System.out.print("Avrupa ");			
		case 216:
			System.out.println("İstanbul");
			break;
		case 372:
			System.out.println("Zonguldak");
			break;
		case 312:
			System.out.println("Ankara");
			break;
		case 232:
			System.out.println("İzmir");
			break;			
		default:
			System.out.println("Geçersiz telefon kodu girdiniz!...");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		switch (code) {
		case 212:						
		case 216:
			System.out.println("İstanbul");
			break;
		case 372:
			System.out.println("Zonguldak");
			break;
		case 312:
			System.out.println("Ankara");
			break;
		case 232:
			System.out.println("İzmir");
			break;			
		default:
			System.out.println("Geçersiz telefon kodu girdiniz!...");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 12 ile birlikte preview olarak, Java 14 ile birlikte normal olacak şekilde case ifadesinde birden fazla sabit
	için aynı işlem yapılacaksa sabitler tek bir case içerisinde vigül ile listelebilir. Java programcısı bu sentaks 
	ticari olarak Java 17 ile birlikte kullanılabilir olarak düşünmelidir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		switch (code) {
		case 212, 216:
			System.out.println("İstanbul");
			break;
		case 372:
			System.out.println("Zonguldak");
			break;
		case 312:
			System.out.println("Ankara");
			break;
		case 232:
			System.out.println("İzmir");
			break;			
		default:
			System.out.println("Geçersiz telefon kodu girdiniz!...");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*---------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: switch deyiminde case bölümlerinin özellikle çok uzun tutulmamasına dikkat edilmelidir. Yani switch
	deyimi tüm bölümleriyle okunabilir olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Derleyicinin yazılan kodun algoritmasını değiştirmeden daha hızlı veya daha az yer kaplayacak 
	şekilde bir kod üretmesine derleyicinin kod optimizasyonu (code optimization) denir. Bu anlamda derleyicilerin 
	optimizasyonu ikiye ayrılır: speed, size. Burada baskın olan genelde hızdır. Derleyicilerin çok fazla optimizasyonu
	vardır. Zaman içerisinde ele alınacaktır 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Derleyici sabit ifadelerinin değerlerini hesaplayıp arakoda yazar, yani akış o noktaya geldiğinde sabit ifadeleri
	hesaplanmaz. Buna "constant folding optimization" denir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long divider = 1000L * 60 * 60 * 24 * 365;
		
		System.out.println(divider);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde aynı değere sahip birden fazla case bölümü geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		switch (code) {
		case 212: //error						
		case 216 - 4: //error
			System.out.println("İstanbul");
			break;
		case 212 - 2 + 2: //error
			System.out.println("Zonguldak");
			break;
		case 312:
			System.out.println("Ankara");
			break;
		case 232:
			System.out.println("İzmir");
			break;			
		default:
			System.out.println("Geçersiz telefon kodu girdiniz!...");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch deyiminde case bölüme ilişkin ifadenin sabit ifadesi olması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		int c = 372;
		
		switch (code) {
		case 212: 						
		case 216:
			System.out.println("İstanbul");
			break;
		case c: //error
			System.out.println("Zonguldak");
			break;
		case 312:
			System.out.println("Ankara");
			break;
		case 232:
			System.out.println("İzmir");
			break;			
		default:
			System.out.println("Geçersiz telefon kodu girdiniz!...");
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo menü uygulamasını inceleyiniz
	
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DemoMenuApp.run();
	}
}

class DemoMenuApp {
	public static void printMenu()
	{		
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Ara");
		System.out.println("4.Sil");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doInsert()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ekle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doUpdate()
	{
		System.out.println("-------------------------------------");
		System.out.println("Güncelle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doSearch()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ara seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doDelete()
	{
		System.out.println("-------------------------------------");
		System.out.println("Sil seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doExit()
	{
		System.out.println("C ve Sistem Programcıları Derneği");
		System.out.println("Teşekkür ederiz");
		System.exit(0);
	}
	
	public static void doInvalidOption()
	{
		System.out.println("-------------------------------------");
		System.out.println("Geçersiz seçenek!...");
		System.out.println("-------------------------------------");
	}
	
	public static void doOption(int option)
	{
		switch (option) {
		case 1:
			doInsert();
			break;
		case 2:
			doUpdate();
			break;
		case 3:
			doSearch();
			break;
		case 4:
			doDelete();
			break;
		case 5:
			doExit();
			break;
		default:
			doInvalidOption();		
		}				
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			printMenu();
			doOption(Integer.parseInt(kb.nextLine()));		
		}		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı yıl bilgisinin artık yıl olup olmadığını test eden isLeapYear isimli 
	metodu yazınız ve aşağıdaki kod ile test ediniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DateUtilIsLeapYearTest.run();
	}
}

class DateUtilIsLeapYearTest {
	public static void run()
	{
		for (int year = 1999; year <= 2104; ++year)
			if (DateUtil.isLeapYear(year))
				System.out.println(year);
	}
}

class DateUtil {
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı gün, ay ve yıl bilgilerine ilişkin tarihin geçerli bir tarih olup olmadığını
	test eden isValidDate isimli metodu DateUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar: 
	 - Yıl 1900'den küçük olmamalıdır
	 
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DateUtilIsValidDateTest.run();
	}
}

class DateUtilIsValidDateTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.println("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if (DateUtil.isValidDate(day, month, year))
				System.out.printf("%02d/%02d/%04d geçerli bir tarihtir%n", day, month, year);
			else
				System.out.println("Geçersiz tarih!...");
			
			if (day == 0 && month == 0 && year == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DateUtil {
	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && 1900 <= year && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{
		int days = 31;
		
		switch (month) {
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		case 2:
			days = 28;
			if (isLeapYear(year))
				++days;
		}
		
		return days;
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Parametresi ile aldığı gün, ay ve yıl bilgilerine ilişkin tarihin geçerli bir tarih olup olmadığını
	test eden isValidDate isimli metodu DateUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar: 
	 - Yıl 1900'den küçük olmamalıdır
	 
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DateUtilIsValidDateTest.run();
	}
}

class DateUtilIsValidDateTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.println("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if (DateUtil.isValidDate(day, month, year))
				System.out.printf("%02d/%02d/%04d geçerli bir tarihtir%n", day, month, year);
			else
				System.out.println("Geçersiz tarih!...");
			
			if (day == 0 && month == 0 && year == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DateUtil {
	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && 1900 <= year && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{
		int days = 31;
		
		switch (month) {
		case 4, 6, 9, 11:		
			days = 30;
			break;
		case 2:
			days = 28;
			if (isLeapYear(year))
				++days;
		}
		
		return days;
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	01.10.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Aşağıdaki açıklamalara göre ilgili metotları yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- getDayOfYear metodu parametresi ile aldığı değerlere ilişkin tarihin yılın kaçıncı günü olduğu bilgisine geri
		dönecektir. Metot tarihin geçersiz olması durumunda -1 değerine geri dönecektir
		
		 - getDayOfWeek metodu parametresi ile aldığı değerlere ilişkin tarihin haftanın hangi gününe karşılık geldiği bilgisine
		 geri dönecektir. Geçersizlik durumu kontrol edilmeyecektir. Haftanın hangi gününe geldiği bilgisi şu şekilde
		 bulunabilir: 01.01.1900 ile ilgili tarih arasındaki gün sayısı hesaplanır ve 7 değerine modu alınır. Bu durumda
		 sıfır Pazar, 1 pazartesi, ..., 6 cumartesi'ye karşılık gelir
		 
		 - printDateTR metodu parametresi ile aldığı değerlere ilişkin tarihi geçerli bir tarihse şu şekilde yazdıracakdır:
		 		 
		 	01/03/2023 Çarşamba yılın 60. günüdür 
		 			 	
		 tarih geçersizse şu şekilde yazdıracaktır:
		 
		  	Geçersiz tarih!...
		 	
		 - Varolan metotların yapısını (isim, parametreler ve geri dönüş değeri gibi) değiştirmeden istediğiniz 
		 metodu ekleyebilirsiniz		 
		  
		 - Metotlar şu ana kadar görülen bilgiler ile yazılacaktır
		
	Not: Örnekte bazı kodlar dolaylı da olsa tekrarlanmıştır. İleride daha iyisi yazılacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DemoDateApp.run();
	}
}

class DemoDateApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if (day == 0 && month == 0 && year == 0)
				break;
			
			DateUtil.printDateTR(day, month, year);			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DateUtil {	
	public static void printDateTR(int day, int month, int year)
	{
		int dayOfYear = getDayOfYear(day, month, year);
		
		if (dayOfYear == -1) {
			System.out.println("Geçersiz tarih!...");
			return;
		}
		
		switch (getDayOfWeek(day, month, year)) {
		case 0:
			System.out.printf("%02d/%02d/%04d Pazar yılın %d. günüdür%n", day, month, year, dayOfYear);
			break;			
		case 1:
			System.out.printf("%02d/%02d/%04d Pazartesi yılın %d. günüdür%n", day, month, year, dayOfYear);
			break;
		case 2:
			System.out.printf("%02d/%02d/%04d Salıyılın %d. günüdür%n", day, month, year, dayOfYear);
			break;
		case 3:
			System.out.printf("%02d/%02d/%04d Çarşamba yılın %d. günüdür%n", day, month, year, dayOfYear);
			break;
		case 4:
			System.out.printf("%02d/%02d/%04d Perşembe yılın %d. günüdür%n", day, month, year, dayOfYear);
			break;
		case 5:
			System.out.printf("%02d/%02d/%04d Cuma yılın %d. günüdür%n", day, month, year, dayOfYear);
			break;
		case 6:
			System.out.printf("%02d/%02d/%04d Cumartesi yılın %d. günüdür%n", day, month, year, dayOfYear);
			break;
		}
	}

	
	public static int getDayOfWeek(int day, int month, int year)
	{
		return getTotalDays(day, month, year) % 7;				
	}
	
	public static int getTotalDays(int day, int month, int year)
	{
		int totalDays = getDayOfYear(day, month, year);

		for (int y = 1900; y < year; ++y) {
			totalDays += 365;
			if (isLeapYear(y))
				++totalDays;
		}
		
		return totalDays;
	}
	
	
	public static int getDayOfYear(int day, int month, int year)
	{
		 if (isValidDate(day, month, year))
			 return getDayOfYearValue(day, month, year);
		 
		 return -1;
	}
	
	public static int getDayOfYearValue(int day, int month, int year)
	{
		int dayOfYear = day;
		
		switch (month - 1) {
		case 11:
			dayOfYear += 30;
		case 10:
			dayOfYear += 31;
		case 9:
			dayOfYear += 30;
		case 8:
			dayOfYear += 31;
		case 7:
			dayOfYear += 31;
		case 6:
			dayOfYear += 30;
		case 5:
			dayOfYear += 31;
		case 4:
			dayOfYear += 30;
		case 3:
			dayOfYear += 31;
		case 2:
			dayOfYear += 28;
			if (isLeapYear(year))
				++dayOfYear;
		case 1:
			dayOfYear += 31;				
		}
		
		return dayOfYear;
	}
		
	
	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && 1900 <= year && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{
		int days = 31;
		
		switch (month) {
		case 4, 6, 9, 11:		
			days = 30;
			break;
		case 2:
			days = 28;
			if (isLeapYear(year))
				++days;
		}
		
		return days;
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 12 ile birlikte preview olarak, ava 14 ile birlikte normal olacak şekilde switch expression dile eklenmiştir. 
	Java programcısı bu sentaksı ticari olarak Java 17 ile birlikte kullanılabilir olarak düşünmelidir. switch expression
	hem bir deyim olarak hem de bir ifade olarak kullanılabilmektedir. switch expression'ın genel biçimi şu şekildedir:
	switch (<ifade>) {
		case <si>[,<si>,...] -> <deyim>
		case <si>[,<si>,...] -> <deyim>
		
		...
		[
		default-> <deyim>
		]
	}
	
	switch expression'da da temel türlerden yalnızca tam sayı türleri ve char türü için kullanılabilir. switch expression'da 
	da case bölümlerinin sabit ifadesi olması zorunludur. switch expression'da aşağı düşme özelliği yoktur. switch
	expression'da break kullanımı geçersizdir
	
	Anahtar Notlar: Programlamada hem deyim hem de ifade biçiminde kullanılabilen araçlara "expression statement" da 
	denilmektedir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Plakayı giriniz:");
		int plate = kb.nextInt();
		
		switch (plate) {
		case 34 -> System.out.println("İstanbul");		
		case 67 -> System.out.println("Zonguldak");
		case 6 -> System.out.println("Ankara");			
		case 35 -> System.out.println("İzmir");		
		default -> System.out.println("Geçersiz şehir girdiniz!...");		
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch expression'da da birden fazla değer case bölümünde virgül ile ayrılarak yazılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		switch (code) {
		case 212, 216 -> System.out.println("İstanbul");		
		case 372 -> System.out.println("Zonguldak");
		case 312-> System.out.println("Ankara");			
		case 232 -> System.out.println("İzmir");		
		default -> System.out.println("Geçersiz şehir girdiniz!...");		
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte "switch expression" bir expression olarak kullanılmıştır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		System.out.println(
			switch (code) {
			case 212, 216 -> "İstanbul";		
			case 372 -> "Zonguldak";
			case 312-> "Ankara";			
			case 232 -> "İzmir";		
			default -> "Geçersiz şehir girdiniz!...";		
			}
		);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	"switch expression" bir expression olarak kullanıldığında default bölümü olmak zorundadır. Aksi durumda error
	oluşur 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		System.out.println(
			switch (code) {
			case 212, 216 -> "İstanbul";		
			case 372 -> "Zonguldak";
			case 312-> "Ankara";			
			case 232 -> "İzmir";		
			//default -> "Geçersiz şehir girdiniz!...";		
			}
		);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	"switch expression"'da birden fazla işlem yapılması durumunda bileşik deyim yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		switch (code) {
		case 212, 216 -> {
			System.out.print("Marmara Bölgesi -> ");
			System.out.println("İstanbul");
		}		
		case 372 -> System.out.println("Zonguldak");
		case 312-> System.out.println("Ankara");			
		case 232 -> System.out.println("İzmir");		
		default -> System.out.println("Geçersiz şehir girdiniz!...");		
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch expression'da bir case bölümünde bileşik deyim yazılmışsa ve değer üretilecekse yield anahtar sözcüğü
	kullanılmalıdır. Bileşik deyim yoksa yield kullanımı error oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		System.out.println(
			switch (code) {
			case 212, 216 -> {
				System.out.print("Marmara Bölgesi -> ");
				yield "İstanbul";				
			}
			case 372 -> "Zonguldak";
			case 312-> "Ankara";			
			case 232 -> "İzmir";		
			default -> "Geçersiz şehir girdiniz!...";		
			}
		);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	switch expression ile birlikte switch deyimi de expression olarak kullanılabilir duruma gelmiştir. Bu durumda 
	değer üretimi yield anahtar sözcüğü ile yapılır. Bu durumda her zaman case bölümünün bileşik deyim olarak
	yazılması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Telefon kodunu giriniz:");
		int code = kb.nextInt();
		
		System.out.println(
			switch (code) {
			case 212, 216: {yield "İstanbul";}			
			case 372: {yield "Zonguldak";}
			case 312: {yield "Ankara";}
			case 232: {yield "İzmir";}
			default: {yield "Geçersiz şehir girdiniz!...";}		
			}
		);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();
		
		int a = switch (val) {
		case 0 -> 10;
		case 1 -> 30;
		case 2 -> 55;
		default -> -1;		
		} + 100;
		
		
		System.out.printf("a = %d%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int val = kb.nextInt();
		
		int a = Sample.foo(val) + 100;
		
		System.out.printf("a = %d%n", a);
	}
}

class Sample {
	public static int foo(int val)
	{
		return switch (val) {
			case 0 -> 10;
			case 1 -> 30;
			case 2 -> 55;
			default -> -1;		
		};
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo menü uygulamasını inceleyiniz
	
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DemoMenuApp.run();
	}
}

class DemoMenuApp {
	public static void printMenu()
	{		
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Ara");
		System.out.println("4.Sil");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doInsert()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ekle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doUpdate()
	{
		System.out.println("-------------------------------------");
		System.out.println("Güncelle seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doSearch()
	{
		System.out.println("-------------------------------------");
		System.out.println("Ara seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doDelete()
	{
		System.out.println("-------------------------------------");
		System.out.println("Sil seçildi");
		System.out.println("-------------------------------------");
	}
	
	public static void doExit()
	{
		System.out.println("C ve Sistem Programcıları Derneği");
		System.out.println("Teşekkür ederiz");
		System.exit(0);
	}
	
	public static void doInvalidOption()
	{
		System.out.println("-------------------------------------");
		System.out.println("Geçersiz seçenek!...");
		System.out.println("-------------------------------------");
	}
	
	public static void doOption(int option)
	{
		switch (option) {
		case 1 -> doInsert();		
		case 2 -> doUpdate();			
		case 3 -> doSearch();		
		case 4 -> doDelete();			
		case 5 -> doExit();
		default -> doInvalidOption();		
		}				
	}
	
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			printMenu();
			doOption(Integer.parseInt(kb.nextLine()));		
		}		
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Aşağıdaki açıklamalara göre ilgili metotları yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- getDayOfYear metodu parametresi ile aldığı değerlere ilişkin tarihin yılın kaçıncı günü olduğu bilgisine geri
		dönecektir. Metot tarihin geçersiz olması durumunda -1 değerine geri dönecektir
		
		 - getDayOfWeek metodu parametresi ile aldığı değerlere ilişkin tarihin haftanın hangi gününe karşılık geldiği bilgisine
		 geri dönecektir. Geçersizlik durumu kontrol edilmeyecektir. Haftanın hangi gününe geldiği bilgisi şu şekilde
		 bulunabilir: 01.01.1900 ile ilgili tarih arasındaki gün sayısı hesaplanır ve 7 değerine modu alınır. Bu durumda
		 sıfır Pazar, 1 pazartesi, ..., 6 cumartesi'ye karşılık gelir
		 
		 - printDateTR metodu parametresi ile aldığı değerlere ilişkin tarihi geçerli bir tarihse şu şekilde yazdıracakdır:
		 		 
		 	01/03/2023 Çarşamba yılın 60. günüdür 
		 			 	
		 tarih geçersizse şu şekilde yazdıracaktır:
		 
		  	Geçersiz tarih!...
		 	
		 - Varolan metotların yapısını (isim, parametreler ve geri dönüş değeri gibi) değiştirmeden istediğiniz 
		 metodu ekleyebilirsiniz		 
		  
		 - Metotlar şu ana kadar görülen bilgiler ile yazılacaktır
		
	Not: Örnekte bazı kodlar dolaylı da olsa tekrarlanmıştır. İleride daha iyisi yazılacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DemoDateApp.run();
	}
}

class DemoDateApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if (day == 0 && month == 0 && year == 0)
				break;
			
			DateUtil.printDateTR(day, month, year);			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DateUtil {	
	public static void printDateTR(int day, int month, int year)
	{
		int dayOfYear = getDayOfYear(day, month, year);
		
		if (dayOfYear == -1) {
			System.out.println("Geçersiz tarih!...");
			return;
		}	
	
		switch (getDayOfWeek(day, month, year)) {
		case 0 -> System.out.printf("%02d/%02d/%04d Pazar yılın %d. günüdür%n", day, month, year, dayOfYear);						
		case 1 -> System.out.printf("%02d/%02d/%04d Pazartesi yılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 2 -> System.out.printf("%02d/%02d/%04d Salıyılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 3 -> System.out.printf("%02d/%02d/%04d Çarşamba yılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 4 -> System.out.printf("%02d/%02d/%04d Perşembe yılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 5 -> System.out.printf("%02d/%02d/%04d Cuma yılın %d. günüdür%n", day, month, year, dayOfYear);
		case 6 -> System.out.printf("%02d/%02d/%04d Cumartesi yılın %d. günüdür%n", day, month, year, dayOfYear);			
		}
	}

	
	public static int getDayOfWeek(int day, int month, int year)
	{
		return getTotalDays(day, month, year) % 7;				
	}
	
	public static int getTotalDays(int day, int month, int year)
	{
		int totalDays = getDayOfYear(day, month, year);

		for (int y = 1900; y < year; ++y) {
			totalDays += 365;
			if (isLeapYear(y))
				++totalDays;
		}
		
		return totalDays;
	}
	
	
	public static int getDayOfYear(int day, int month, int year)
	{
		 if (isValidDate(day, month, year))
			 return getDayOfYearValue(day, month, year);
		 
		 return -1;
	}
	
	public static int getDayOfYearValue(int day, int month, int year)
	{
		int dayOfYear = day;
		
		switch (month - 1) {
		case 11:
			dayOfYear += 30;
		case 10:
			dayOfYear += 31;
		case 9:
			dayOfYear += 30;
		case 8:
			dayOfYear += 31;
		case 7:
			dayOfYear += 31;
		case 6:
			dayOfYear += 30;
		case 5:
			dayOfYear += 31;
		case 4:
			dayOfYear += 30;
		case 3:
			dayOfYear += 31;
		case 2:
			dayOfYear += 28;
			if (isLeapYear(year))
				++dayOfYear;
		case 1:
			dayOfYear += 31;				
		}
		
		return dayOfYear;
	}
		
	
	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && 1900 <= year && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{		
		return switch (month) {
			case 4, 6, 9, 11 -> 30;			
			case 2 -> {		
				if (isLeapYear(year))
					yield 29;
				yield 28;
			}
			default -> 31;
		};
		
		
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Ne zaman klasik deyimi ne zaman switch expression kullanacağız? Buna nasıl karar vereceğiz? Zaten ticari olarak Java 17
	öncesinde ya da Java 12 veya Java 14 öncesinde çalışıyorsak zaten switch expression kullanamayız. Java 17 ile 
	çalışıyorsak aşağı düşme özelliğinden faydalanmıyorsak her zaman switch expression kullanılmalıdır.  
	
	Anahtar Notlar: switch'e, özellikle ticari olarak Java 21 ile kullanılabilecek bazı özellikler eklenmiştir. Bu özelliklerin
	bazılar preview biçimindedir. Bu özellikler başka konuları da gerektirdiğinden ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	08.10.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Farklı Türlerin Birbirine Atanması (Type Conversions)
	Java'da farklı türlerin birbirine atanabilmesine (dönüşebilmesine) yönelik kurallar belirlenmiştir. T1 ve T2 birer
	tür ismi olmak üzere
		T1 t1;
		T2 t2;
		
		...
		
		t1 = t2; //**
	kodları için ** ile belirtilen ifadede T2 türünden T1 türüne doğrudan dönşüm/atama (implicit conversion) denir.
	Bu ifadede T2 türüne kaynak tür (source type), T1 türüne ise hedef tür (destination/target type) denir. Java'da 
	derleyici açısından hangi türün hangi türe doğrudan atanabileceği belirlidir. Bu anlamda atanamayan türler de 
	genel olarak ileride göreceğimiz tür dönüştürme operatörü (type cast operator) ile dönüştürülebilmektedir. Tür
	dönüştürme operatörü ile yapılan dönüşüme ise explicit conversion denir. Burada temel türler arasındaki tür 
	dönüştürme kuralları ele alınacaktır. Diğer türler arasındaki dönüşümler ileride konular içerisinde ele alınacaktır.
	
	Temel türler arasındaki doğrudan dönüşümlerde genel kural şu şekildedir: Genel olarak bilgi/veri kaybına yol açmayacak 
	dönüşümler doğrudan yapılabilir
	
	Derleyici kaynak türe ile ilişkin değerin hedef tür sınırları içerisinde olup olmadığına bakmaz ki çoğu zamanda bakamaz.
	Örneğin değer klavyeden okunsa zaten derleme zamanında hiç bir şekilde bilinemez. Bu durumda derleyici kaynak türden hedef
	türe doğrudan atamanın geçerli olup olmadığına göre kodu derler. Doğrudan dönüşüme ilişkin ayrıntılar ayrıca ele alınacaktır.
	
	Anahtar Notlar: Size olarak küçük türden size olarak büyük türe yapılan atamalara Java Language Specification'da (JLS)
	widening conversion, size olarak büyük türden size olarak küçük türe yapılan atamalar ise narrowing conversion 
	her ikisinin birden olduğu dönüşümlere ise widening and narrowing conversion denilmektedir. Buradaki terimler,
	dönüşümün geçerli ya da geçersiz olmasından bağımsızdır. Anlatım bu şekilde kullanılmıştır. Biz burada bu terimleri
	her zaman kullanmayarak konuyu daha anlaşılır hale getirmeye çalışacağız.
	
	Anahtar Notlar: Anımsanacağı gibi Java'da 3 yerde atama işlemi yapılmaktadır:
	1. Yalın atama işlemi
	2. Metot çağrısında argümanlardan parametrelere aktarım
	3. Metodun geri dönüş değerinin geçici değişkene atanması
	Tür dönüştürme kuralları istisna bir kaç kural dışında tüm atama durumlarında geçerlidir. İstisna kurallar ayrıca
	ele alınacaktır.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte long türünden int türüne yapılan dönüşüm geçersiz olduğundan error oluşur. Derleyici a değişkeni
	içerisindeki değer bilmesine rağmen atama durumunda bunu dikkate almaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long a = 10;
		int b;
		
		b = a;//error
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte a değişkeninin değeri derleme zamanında kesinlikle bilinemez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		long a = kb.nextLong();
		int b;
		
		b = a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Temel türler arasındaki implicit conversion detayları şunlardır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	Büyük tamsayı türünden küçük tamsayı türüne doğrudan dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		short b;
		
		b = a; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Hiç bir türden char türüne doğrudan dönüşüm yapılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		byte a = 10;
		char b;
		
		b = a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Anımsanacağı gibi byte ve short türden sabit yoktur. Java'da int türden bir sabit sınırlar içerisinde kalması
	koşuluyla byte veya short türüne doğrudan atanabilir. Aksi durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a;
		byte b;
		int c = 10;
		
		a = 10;
		b = 20;
		
		b = c; //error
		b = 10L; //error
		a = 70000; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıdaki istisna kural char türü için de geçerlidir. Yani sınırlar içerisinde kalması koşuluyla int türden 
	bir sabit char türüne doğrudan atanabilir. Ancak bu kural shot ve byte türleri kadar pratikte kullanılmaz. Çünkü
	char türden sabitler vardır ve bunlar kullanılmalıdır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c;
		int a = 67;
		
		c = 67;
		c = a; //error
		c = 67L; //error
		c = -23; //error
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	short, byte ve char türüne ilişkin yukarıdaki istisna kurallar, metodun geri dönüş değeri varsa return deyimine 
	ilişkin ifadeler için de geçerlidir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static short foo()
	{
		//...
	
		return 10;
	}
	
	public static byte bar()
	{
		//...
	
		return 127;
	}
	
	public static char tar()
	{
		//...
	
		return 67;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	short, byte ve char türüne ilişkin yukarıdaki istisna kurallar, argümalardan parametrelere aktarıma ilişkin atamada
	geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo(10); //error
		Sample.bar(127); //error
		Sample.tar(67); //error
	}
}

class Sample {
	public static void foo(short a)
	{
		//...
	}
	
	public static void bar(byte b)
	{
		//...
	}
	
	public static void tar(char c)
	{
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Küçük tamsayı türünden büyük tamsayı türüne doğrudan atama geçerlidir. Bu durumda sayının yüksek anlamlı bit
	değerleri sayı pozitifse sıfır ile, negatif ise 1 ile beslenir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		int a = kb.nextInt();
		long b;
		
		b = a;
		
		System.out.printf("a = %d, a = %08Xh%n", a, a);
		System.out.printf("b = %d, b = %016Xh%n", b, b);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Küçük tamsayı türünden büyük tamsayı türüne doğrudan atama geçerlidir. Bu durumda sayının yüksek anlamlı bit
	değerleri sayı pozitifse sıfır ile, negatif ise 1 ile beslenir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayı giriniz:");
		short a = kb.nextShort();
		int b;
		
		b = a;
		
		System.out.printf("a = %d, a = %04Xh%n", a, a);
		System.out.printf("b = %d, b = %08Xh%n", b, b);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	char türünden kendisinden size olarak büyük herhangi bir türe doğrudan dönüşüm geçelidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = 'D';
		int a;
		double b;
		
		a = c;
		b = c;
		
		System.out.printf("a = %d, b = %f%n", a, b);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	char türünden short türüne doğrudan dönüşüm geçersizdir. Çünkü char türü içerisinde short türü sınırlarından büyük
	değerler de tutulabilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = 40000;
		short a;
		
		a = c; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Tüm tamsayı türlerinden gerçek sayı türlerine doğrudan dönüşüm geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		long a = 10;
		float b;
		
		b = a; 
		
		System.out.printf("b = %f%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Gerçek sayı türlerinden tamsayı türlerine doğrudan dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 10;
		long b;
		
		b = a; //error
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	float türünden double türüne doğrudan dönüşüm geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			float a = Float.parseFloat(kb.nextLine());
			
			if (Math.abs(a) < 0.00001)
				break;
			
			double b;
			
			b = a;
			
			System.out.printf("a = %.20f, b = %.20f%n", a, b);
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	double türünden float türüne doğrudan dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		double a = 123;
		float b;
		
		b = a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte, double türünden float türüne doğrudan atama geçersiz olduğundan error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a;
		
		a = 0.3; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte 0.3 sabit float olarak alınmıştır. Yuvarlama hatasına dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a;
		
		a = 0.3F;
		
		System.out.printf("a = %.20f%n", a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnek int türünden float türüne doğrudan atama yapılabileceği için geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a;
		
		a = 10;
		
		System.out.printf("a = %.20f%n", a);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	bool türünden hiç bir türe, herhangi bir türden bool türüne doğrudan dönüşüm yapılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 1;
		boolean b;
		
		b = a; //error
		
		b = true;
		
		a = b; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Doğrudan dönüşüme ilişkin özet şu şekilde yazılabilir: 
	byte		-> short, int, long, float, double
	short		-> int, long, float, double
	int			-> long, float, double
	long		-> float, double
	float		-> double
	char		-> int, long, float, double
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	İşlem Öncesi Otomatik Tür Dönüşümleri: İki operandlı operatörlere ilişkin işlemler aşağı seviye farklı türlerle 
	yapılamaz. Örneğin farklı türden iki ifade doğrudan toplanamaz. Bu işlemler aynı türler ile yapılabilir. Bu durumda
	farklı türden işlemler için derleyici bir operandı ya da operandları farklı bir türden ele alacak kodu üretir ve işlem
	ortak tür ile yapılır. Buna işlem öncesi otomatik tür dönüşümü denir. Bu dönüşümler yukarıda anlatılan "implicit conversion"
	kurallarına uygun olarak yapılır. Otomatik tür dönüşümü bir ifadenin (örneğin bir değişkenin) türünün değişmesi
	demek değildir. O ifadenin değerinin dönüştürülmüş olan tür ile temsil edilmesidir. Bu işlemin aşağı seviyede nasıl
	yapıldığı ileride ele alınacaktır  
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	İşlem öncesi otomatik tür dönüşümüne ilişkin ayrıntılar şunlardır (else if biçiminde değerlendiriniz):
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	Bölme işleminde operandlar tam sayı türündense sonuç tamsayı türünden çıkar. Bölme işleminden  elde edilen değerin 
	noktadan sonraki kısmı atılır. Tam kısmı alınır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Birinci sayıyı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			
			if (a == 0)
				break;
			
			System.out.print("İkinci sayıyı giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			int c;
			
			c = a / b;
			
			System.out.printf("%d / %d = %d%n", a, b, c);
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Birinci sayıyı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			
			if (a == 0)
				break;
			
			System.out.print("İkinci sayıyı giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			double c;
			
			c = a / b;
			
			System.out.printf("%d / %d = %f%n", a, b, c);
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	int türünden size olarak küçük tamsayı türleri (short, byte) ve char türü kendi aralarında işleme sokulduğunda her 
	iki ifadeye ilişkin değer de int türüne dönüştürülür ve sonuç int türünden çıkar. Buna integral/integer promotion 
	denir. Yani iki operandlı bir operatör için en az int türünde işlem yapılar. Aşağıdaki error'u inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a, b;
		short c;
		
		a = 10;
		b = 20;
		
		c = a + b; //error
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	int türünden size olarak küçük tamsayı türleri (short, byte) ve char türü kendi aralarında işleme sokulduğunda her 
	iki ifadeye ilişkin değer de int türüne dönüştürülür ve sonuç int türünden çıkar. Buna integral/integer promotion 
	denir. Yani iki operandlı bir operatör için en az int türünde işlem yapılar. Aşağıdaki error'u inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a;
		byte b;
		short c;
		
		a = 10;
		b = 20;
		
		c = a + b; //error
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	int türünden size olarak küçük tamsayı türleri (short, byte) ve char türü kendi aralarında işleme sokulduğunda her 
	iki ifadeye ilişkin değer de int türüne dönüştürülür ve sonuç int türünden çıkar. Buna integral/integer promotion 
	denir. Yani iki operandlı bir operatör için en az int türünde işlem yapılar. Aşağıdaki error'u inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a;
		char b;
		char c;
		
		a = 10;
		b = 20;
		
		c = a + b; //error
		
	}
}

/*---------------------------------------------------------------------------------------------------------------------
	14.10.2023
----------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------
	Yukarıdaki maddeye göre tamsayı türleri ile işlemler aşağı seviyde size olarak en az int türü yapılabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Büyük tamsayı türü ile küçük tamsayı türü işleme sokulduğunda küçük tamsayı türüne ilişkin değer büyük tamsayı türüne
	dönüştürülür, işlem büyük tamsayı türünden yapılır ve sonuç büyük tamsayı türünden çıkar 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		long b = 30;		
		int c;
		
		c = a + b; //error		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	char türü kendisinden size olarak olarak büyük bir tür ile işleme sokulduğunda char türüne ilişkin değer ilgili türe
	dönüştürülür ve sonuç o türden çıkar 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = 'A';
		double b = 4.5;
		double result;
		
		result = c + b;
		
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	 Bir tamsayı türü ile gerçek sayı türü işleme sokulduğunda tamsayı türüne ilişkin değer gerçek sayı türüne 
	 dönüştürülür ve işlem o gerçek sayı türünden çıkar
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 3.4F;
		long b = 345;
		float c;
		
		c = a + b;
		
		//...				
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 float türü ile double türü işleme sokulduğunda float türüne ilişkin değer double türüne dönüştürülür ve sonuç
	 double türünden elde edilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		float a = 3.4F;
		double b = 345.89;
		float c;
		
		c = a + b; //error

	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	 boolean türü hiç bir tür ile işleme sokulamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b = 1;	
		
		System.out.println(a == b); //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	İşlem öncesi otomatik tür dönüşümü geçici değişken yaratılarak yapılır. Yani derleyici geçici değişken yaratılan 
	kodu üretir. Aşağıdaki örnekte c = a + b ifadesi için derleyici tarafından üretilen kod yaklaşık olarak şu 
	şekildedir:
		long temp;
		
		temp = a;
		
		c = temp + b;	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		long b = 345;		
		long c;
		
		c = a + b;
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte c = a + b ifadesi için derleyici tarafından üretilen kod yaklaşık olarak şu şekildedir:
		int temp1, temp2;
		
		temp1 = a;
		temp2 = b;
		
		c = temp1 + temp2;	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		short b = 345;		
		int c;
		
		c = a + b;
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte c = a + b ifadesi için derleyici tarafından üretilen kod yaklaşık olarak şu şekildedir:
		double temp1;
		double temp2;		
		long temp3;
		
		temp1 = Math.sqrt(a);
		temp3 = Math.round(b);
		temp2 = temp3;
		
		c = temp1 + temp2;
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		double a = kb.nextDouble();
		double b = kb.nextDouble();
		double c;
		
		c = Math.sqrt(a) + Math.round(b);
	
		System.out.printf("c = %f%n", c);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Anahtar Notlar: Yukarıdaki üç örnek için yazılan kodların yaklaşık olduğuna yani derleyicinin birebir aynı kodlar
	üretmeyebileceğine, hatta bazılarında o kadar sayıda geçici değişken yaratmayabileceğine dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Tür Dönüştürme (type cast) Operatörü: Tür dönüştürme operatörü özel amaçlı, tek operandlı ve önek durumunda bir 
	operatördür. Operatörün genel biçimi şu şekildedir:
	
		(<hedef tür>)<ifade>
		
	Operatör operandı olarak aldığı ifadenin değerini hedef türe dönüştürür ve o değeri üretir. Operatörün yan etkisi 
	yoktur. Tür dönüştürme operatörü ile yapılan dönüştürme işlemine "explicit conversion", "type casting" ya da kısaca
	"casting" denilmektedir. Tür dönüştürme operatörü operatör öncelik tablosunun ikinci seviyesinde ve sağdan sola
	önceliklidir. Implicit olarak yapılamayan dönüşümler genel olarak explicit olarak yani tür dönüştürme operatörü
	ile yapılabilir. implicit dönüşümlerde de tür dönüştürme operatörü kullanılabilir 
	
	Anahtar Notlar: Tür dönüştürme operatörünün sentaks olarak zorunlu olması durumu yani bu operatör kullanılmamasının
	error olması durumu şu şekilde özetlenebilir: Ortada bir problem olabilir. Derleyici programcının bunu doğrudan
	yapmasına izin vermiyor çünkü yanlışlıkla yapılabilir. Bu durumda programcı da bunu explicit olarak yaparak
	derleyiciye ben durumun farkındayım demiş olur. Bazı dönüşümler explicit olarak bile yapılamaz. Bunlar Java açısından
	anlamsız durumlardır ve derleyici buna hiç vermez.
	
	Anahtar Notlar: Bir dönüşüm implicit olarak yapılamıyor ise explicit olarak yapılıyor olabilir. Ancak explicit olarak
	yapılamıyorsa implicit olarak zaten yapılamaz
	
	Tür dönüştürme operatörü ile yapılan işlem de geçici değişkenyaratılarak yapılır. Yani tür dönüştürme operatörünün
	operandına ilişkin ifadenin türü değişmez. Aşağıdaki örnekte değişken a'nın türü değildir. Çünkü bir değişkenin 
	faaliyet alanı boyunca aynıdır. ** ile belirtilen basit deyime ilişkin ifade için derleyicinin ürettiği yaklaşık
	kod şu şekildedir:
	
		double temp1 = a;
		double temp2 = b;
		
		c = temp1 / temp2;	 	
	
	Örnekte bölme operatörünün birinci operandı double olarak işleme sokulduğundan ikinci operandına ilişkin
	değer de double türüne dönüştürülür, işlem double olarak yapılır ve sonuç da double olarak elde edilir. 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		double c;
		
		c = (double)a / b; //**
		
		System.out.printf("c = %f%n", c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Tür dönüştürme operatörüne yönelik detaylar şunlardır: 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Büyük tamsayı türünden küçük tamsayı türüne veya char türüne yapılan explicit dönüşümde değerin yüksek anlamlı
	byte değerleri atılır, elde edilen sonuç hedef türe atanır. Bu durumda değer hedef türün sınırları içerisindeyse
	bilgi kaybı oluşmaz, sınırları dışında ise bilgi kaybı oluşur. Aşağıdaki örneği çeşitli değerler ile çalıştırıp
	sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			short b;
			
			b = (short)a;
			
			System.out.printf("a = %d, a = %08X%n", a, a);
			System.out.printf("b = %d, b = %04X%n", b, b);
			
			if (b == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			byte b;
			
			b = (byte)a;
			
			System.out.printf("a = %d, a = %08X%n", a, a);
			System.out.printf("b = %d, b = %02X%n", b, b);
			
			if (b == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			char b;
			
			b = (char)a;
			
			System.out.printf("a = %d, a = %08X%n", a, a);
			System.out.printf("b = %d, b = %02X%n", (int)b, (int)b);
			
			if (b == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	short türünden char türüne yapılan explicit dönüşümde sayının bit kalıbı değişmez. Sayının yorumlanışı değişir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10, b = -10;
		char c1, c2;
		
		c1 = (char)a;
		c2 = (char)b;
		
		System.out.printf("a = %d, a = %04X%n", a, a);
		System.out.printf("c1 = %d, c1 = %04X%n", (int)c1, (int)c1);
		System.out.printf("b = %d, b = %04X%n", b, b);
		System.out.printf("c2 = %d, c2 = %04X%n", (int)c2, (int)c2);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	char türünden short türüne yapılan explicit dönüşümde sayının bit kalıbı değişmez. Sayının yorumlanışı değişir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c1 = 'D', c2 = '\uFFF6';
		short a, b;
		
		a = (short)c1;
		b = (short)c2;
		
		
		System.out.printf("c1 = %d, c1 = %04X%n", (int)c1, (int)c1);
		System.out.printf("a = %d, a = %04X%n", a, a);
		System.out.printf("c2 = %d, c2 = %04X%n", (int)c2, (int)c2);
		System.out.printf("b = %d, b = %04X%n", b, b);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	char türünden byte türüne dönüşümde sayının yük anlamlı byte'ı atılır ve elde edilen değer byte türüne atanır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		char c = '\uFFF6';
		byte b;		
		
		b = (byte)c;
		
		
		System.out.printf("c = %d, c = %04X%n", (int)c, (int)c);		
		System.out.printf("b = %d, b = %02X%n", b, b);		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	byte türünden char türüne explicit dönüşüm iki aşamada yapılır. Önce byte türüne ilişkin değer int türüne 
	dönüştürülür sonra elde edilen değerin yüksek anlamlı iki byte'ı atılır ve char türüne atılır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			byte a = Byte.parseByte(kb.nextLine());			
			char c;
			
			c = (char)a;
			
			System.out.printf("a = %d, a = %02X%n", a, a);
			System.out.printf("a = %d, a = %08X%n", (int)a, (int)a);
			System.out.printf("c = %d, c = %04X%n", (int)c, (int)c);
			
			if (a == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	double türünden float türüne yapılan explicit dönüşümde double türüne ilişkin değerin IEEE 754 formatına göre 
	float türüne en yakın değeri elde edilir. Bu durumda yuvarlama hataları oluşabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			double a = Double.parseDouble(kb.nextLine());			
			float b;
			
			b = (float)a;
			
			System.out.printf("a = %.20f%n", a);
			System.out.printf("b = %.20f%n", b);
			
			if (a == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	boolean türünden hiç bir türe ve hiç bir türden boolean türüne explicit dönüşüm yapılamaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b = 1;
		int c;
		boolean d;
		
		c = (int)a; //error	
		d = (boolean)b; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	15.10.2023	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	int, short, long ve byte türlerine ilişkin en küçük ve en büyük değerler ilgili sınıfların MIN_VALUE ve MAX_VALUE
	elemanları ile elde edilebilir:
	
	Tür				En küçük Değer					En büyük değer
	int				Integer.MIN_VALUE				Integer.MAX_VALUE
	short			Short.MIN_VALUE					Short.MAX_VALUE
	long			Long.MIN_VALUE					Long.MAX_VALUE
	byte			Byte.MIN_VALUE					Byte.MAX_VALUE
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.printf("byte:[%d, %d]%n", Byte.MIN_VALUE, Byte.MAX_VALUE);		
		System.out.printf("short:[%d, %d]%n", Short.MIN_VALUE, Short.MAX_VALUE);
		System.out.printf("int:[%d, %d]%n", Integer.MIN_VALUE, Integer.MAX_VALUE);
		System.out.printf("long:[%d, %d]%n", Long.MIN_VALUE, Long.MAX_VALUE);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Bir gerçek sayı türünden bir tamsayı türüne veya char türüne yapılan explicit dönüşüm şu şekilde gerçekleşir:
	- Sayının noktadan sonraki kısmı atılır
	
	- Elde edilen sayı hedef türün sınırları içerisindeyse hedef türe atanır
	
	- Elde edilen sayı hedef türün sınırları içerisinde değilse	
		- Hedef tür int, short, byte ve char türlerinden biriyse
			- Elde edilmiş olan değer int türü sınırları içerisindeyse tam sayılar arasındaki tür dönüşümü kuralları
			uygulanır. Yani int'den küçük türler için yüksek anlamlı byte değerleri atılır ve elde edilen değer hedef türe 
			atanır. Hedef tür int ise değer doğrudan atanır
			
			- Elde edilmiş olan değer int türü sınırları içerisinde değilse sayının pozitif ya da negatif olması 
			durumuna göre int türünün en büyük ve en küçük değeri alınır ve hedef türe dönüştürülür. Hedef tür int 
			ise int'in en büyük veya en küçük değeri atanır
			
		- Hedef tür long ise
			- Elde edilen değer long türü sınırları içerisindeyse doğrudan atanır
			
			- Elde edilen değer long türü sınırları içerisinde değilse sayının pozitif ya da negatif olması durumuna
			göre long türünün en büyük ve en küçük değeri alınır atanır
			
	Aşağıdaki örnekleri inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		double a = 123.45;
		byte b;
		
		b = (byte)a;
		
		System.out.printf("b = %d%n", b);
	}
}

package csd;

class App {
	public static void main(String [] args)
	{
		double a = 1236.45;
		byte b;
		
		b = (byte)a;
		
		System.out.printf("1236 = %08X%n", 1236);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %02X%n", b);		
	}
}

package csd;

class App {
	public static void main(String [] args)
	{
		double a = 40000.45;
		short b;
		
		b = (short)a;
		
		System.out.printf("40000 = %08X%n", 40000);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %04X%n", b);		
	}
}


package csd;

class App {
	public static void main(String [] args)
	{
		double a = 5_000_000_000.45;
		int b;
		
		b = (int)a;
		
		System.out.printf("5_000_000_000 = %08X%n", (int)5_000_000_000L);
		System.out.printf("2147483647 = %08X%n", Integer.MAX_VALUE);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %08X%n", b);		
	}
}


package csd;

class App {
	public static void main(String [] args)
	{
		double a = -5_000_000_000.45;
		int b;
		
		b = (int)a;
		
		System.out.printf("-5_000_000_000 = %08X%n", (int)-5_000_000_000L);
		System.out.printf("-2147483648 = %08X%n", Integer.MIN_VALUE);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %08X%n", b);
	}
}


package csd;

class App {
	public static void main(String [] args)
	{
		double a = 5_000_000_000.45;
		byte b;
		
		b = (byte)a;
		
		System.out.printf("5_000_000_000 = %02X%n", (byte)5_000_000_000L);
		System.out.printf("(byte)2147483647 = %08X%n", (byte)Integer.MAX_VALUE);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %02X%n", b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bazen tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir. Aşağıdaki örneği tür dönüştürme operatörünü de
	kaldırarak çeşitli değerler ile çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Birinci sayıyı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			
			System.out.print("İkinci sayıyı giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			long c;
			
			c = (long)a + b;
			System.out.printf("%d + %d = %d%n", a, b, c);
			
			if (a == 0 && b == 0)
				break;
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bazen tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir. Aşağıdaki örneği tür dönüştürme operatörünü de
	kaldırarak çeşitli değerler ile çalıştırıp sonuçları gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Sayıları girmeye başlayınız:");
		int count = 0;
		int total = 0;
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			total += val;
			++count;			
		}
		
		double average = (double)total / count;
		
		System.out.printf("Average:%f%n", average);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		int total = 0;
		
		for (int i = 0; i < 5; ++i) {
			System.out.print("Bir sayı giriniz:");
			total += Integer.parseInt(kb.nextLine());
		}
		
		double average = total / 5.;
		
		System.out.printf("Average:%f%n", average);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		int total = 0;
		
		for (int i = 0; i < 5; ++i) {
			System.out.print("Bir sayı giriniz:");
			total += Integer.parseInt(kb.nextLine());
		}
		
		double average = total / 5D;
		
		System.out.printf("Average:%f%n", average);
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İşlemli atama operatörlerinin genel biçimi aslında şu şekildedir:
		T1 ve T2 tür isimleri olmak üzere
		T1 a;
		T2 b;
		
	için
		a <op>= b;
	işlemi
		a = (T1)(a <op> b)
	Örneğin:
		int a;
		double b;
		
		//...
		
		a += b; 
	ifadesinin karşılığı
		a = (int)(a + b)	
		
	Aşağıdaki örneği inceleyiniz	
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilIsArmstrongTest.run();
	}
}

class NumberUtilIsArmstrongTest {
	public static void run() 
	{
		for (int n = -1; n <= 999_999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);
	}
}

class NumberUtil {	
	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}
	
	public static int getDigitsPowSum(int val)
	{
		int n = digitsCount(val);
		int result = 0;
		
		while (val != 0) {
			result += Math.pow(val % 10, n);
			val /= 10;
		}
		
		return result;
	}
	
	public static int digitsCount(int val)
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
		} while (val != 0);
		
		return count;
	}
	
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sayının basamak sayısını bulan metot aşağıdaki gibi döngü kullanmadan yazılabilir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilIsArmstrongTest.run();
	}
}

class NumberUtilIsArmstrongTest {
	public static void run() 
	{
		for (int n = -1; n <= 999_999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);
	}
}

class NumberUtil {	
	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}
	
	public static int getDigitsPowSum(int val)
	{
		int n = digitsCount(val);
		int result = 0;
		
		while (val != 0) {
			result += Math.pow(val % 10, n);
			val /= 10;
		}
		
		return result;
	}
	
	public static int digitsCount(int val)
	{
		if (val == 0)
			return 1;
		
		return (int)Math.log10(Math.abs(val)) + 1;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Koşul Operatörü (Conditional/Ternary Operator): Bu operatör özel amaçlı, üç operandlı (ternary) ve araek (infix) 
	durumundadır. Operatörün genel biçimi şu şekildedir:
		<ifade1> ? <ifade2> : <ifade3>
	Burada ifade1'in yani birinci operandın boolean türden olması zorunludur.  Bu operatör birinci operandının değeri
	true ise ikinci operandının değerini, false ise üçüncü operandının değerini üretir. Bu operatörün yan etkisi yoktur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ** ile belirtilen deyimin if deyimi ile yapılışı şu şekildedir:
		if (a > b)
			max = a;
		else 
			max = b;
	Şüphesiz şu şekilde de yapılabilir:
		max = a;
		if (a < b)
			max = b;
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int max;
		
		max = a > b ? a : b; //**
		
		System.out.printf("max(%d, %d) = %d%n", a, b, max);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörünün üçüncü operandı b - 200 ifadesidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result;
		
		result = a > b ? a + 100 : b - 200;
		
		System.out.printf("result = %d%n", result);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörünün üçüncü operandı b ifadesidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result;
		
		result = (a > b ? a + 100 : b) - 200; 
		
		System.out.printf("result = %d%n", result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	21.10.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörünün birinci operandı a + a > b ifadesidir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result;
		
		result = a + a > b ? a : b;
		
		System.out.printf("result = %d%n", result);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörünün ürettiği değer a ile toplama işlemine sokulmuştur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int result;
		
		result = a + (a > b ? a : b);
		
		System.out.printf("result = %d%n", result);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Koşul operatörü if deyimine alternatif gibi görünse de doğrudan değildir. Bu anlamda koşul operarörü okunabilirlik
	açısından tercih edilebilir. Aslında koşul operatörünün okunabilirlik açısından tercih edilebileceği durumlar
	tipik atama işlemleridir:
		- Yalın atama operatörü ile yapılan atama işlemi
		- Metot çağrısında argümanlardan parametrelere yapılan atama işlemi
		- Metodun geri dönüş değerinin geçici değişkene yapılan atama işlemi
	Bazen de ifadeyi karmaşıklaştırmamak koşuluyla (yine okunabilirlik açısından karmaşık olmaması) ürettiği
	değerin işleme sokulması durumunda da tercih edilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte yalın atama işleminde if deyimi yerine koşul operatörü kullanmak okunabilirliği artırır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int max;
		
		max = a > b ? a : b;
		
		System.out.printf("max(%d, %d) = %d%n", a, b, max);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörüne ilişkin ifade argüman olarak printf metoduna geçirilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("max(%d, %d) = %d%n", a, b, a > b ? a : b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörü return deyiminde kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("İki sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		
		System.out.printf("max(%d, %d) = %d%n", a, b, Util.max(a, b));
	}
}

class Util {
	public static int max(int a, int b)
	{
		return a > b ? a : b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörü return deyiminde kullanılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Üç sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();
		
		System.out.printf("result = %d%n", Util.addWithMax(a, b, c));
	}
}

class Util {
	public static int addWithMax(int a, int b, int c)
	{
		return (a > b ? a : b) + c;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Aşağıdaki açıklamalara göre ilgili metotları yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- getDayOfYear metodu parametresi ile aldığı değerlere ilişkin tarihin yılın kaçıncı günü olduğu bilgisine geri
		dönecektir. Metot tarihin geçersiz olması durumunda -1 değerine geri dönecektir
		
		 - getDayOfWeek metodu parametresi ile aldığı değerlere ilişkin tarihin haftanın hangi gününe karşılık geldiği bilgisine
		 geri dönecektir. Geçersizlik durumu kontrol edilmeyecektir. Haftanın hangi gününe geldiği bilgisi şu şekilde
		 bulunabilir: 01.01.1900 ile ilgili tarih arasındaki gün sayısı hesaplanır ve 7 değerine modu alınır. Bu durumda
		 sıfır Pazar, 1 pazartesi, ..., 6 cumartesi'ye karşılık gelir
		 
		 - printDateTR metodu parametresi ile aldığı değerlere ilişkin tarihi geçerli bir tarihse şu şekilde yazdıracakdır:
		 		 
		 	01/03/2023 Çarşamba yılın 60. günüdür 
		 			 	
		 tarih geçersizse şu şekilde yazdıracaktır:
		 
		  	Geçersiz tarih!...
		 	
		 - Varolan metotların yapısını (isim, parametreler ve geri dönüş değeri gibi) değiştirmeden istediğiniz 
		 metodu ekleyebilirsiniz		 
		  
		 - Metotlar şu ana kadar görülen bilgiler ile yazılacaktır
		
	Not: Örnekte bazı kodlar dolaylı da olsa tekrarlanmıştır. İleride daha iyisi yazılacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args) 
	{		
		DemoDateApp.run();
	}
}

class DemoDateApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz:");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if (day == 0 && month == 0 && year == 0)
				break;
			
			DateUtil.printDateTR(day, month, year);			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DateUtil {	
	public static void printDateTR(int day, int month, int year)
	{
		int dayOfYear = getDayOfYear(day, month, year);
		
		if (dayOfYear == -1) {
			System.out.println("Geçersiz tarih!...");
			return;
		}	
	
		switch (getDayOfWeek(day, month, year)) {
		case 0 -> System.out.printf("%02d/%02d/%04d Pazar yılın %d. günüdür%n", day, month, year, dayOfYear);						
		case 1 -> System.out.printf("%02d/%02d/%04d Pazartesi yılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 2 -> System.out.printf("%02d/%02d/%04d Salıyılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 3 -> System.out.printf("%02d/%02d/%04d Çarşamba yılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 4 -> System.out.printf("%02d/%02d/%04d Perşembe yılın %d. günüdür%n", day, month, year, dayOfYear);			
		case 5 -> System.out.printf("%02d/%02d/%04d Cuma yılın %d. günüdür%n", day, month, year, dayOfYear);
		case 6 -> System.out.printf("%02d/%02d/%04d Cumartesi yılın %d. günüdür%n", day, month, year, dayOfYear);			
		}
	}
	
	public static int getDayOfWeek(int day, int month, int year)
	{
		return getTotalDays(day, month, year) % 7;				
	}
	
	public static int getTotalDays(int day, int month, int year)
	{
		int totalDays = getDayOfYear(day, month, year);

		for (int y = 1900; y < year; ++y)
			totalDays += isLeapYear(y) ? 366 : 365;
		
		return totalDays;
	}
	
	
	public static int getDayOfYear(int day, int month, int year)
	{
		return isValidDate(day, month, year) ? getDayOfYearValue(day, month, year) : -1;
	}
	
	public static int getDayOfYearValue(int day, int month, int year)
	{
		int dayOfYear = day;
		
		switch (month - 1) {
		case 11:
			dayOfYear += 30;
		case 10:
			dayOfYear += 31;
		case 9:
			dayOfYear += 30;
		case 8:
			dayOfYear += 31;
		case 7:
			dayOfYear += 31;
		case 6:
			dayOfYear += 30;
		case 5:
			dayOfYear += 31;
		case 4:
			dayOfYear += 30;
		case 3:
			dayOfYear += 31;
		case 2:
			dayOfYear += isLeapYear(year) ? 29 : 28;
		case 1:
			dayOfYear += 31;				
		}
		
		return dayOfYear;
	}
		
	
	public static boolean isValidDate(int day, int month, int year)
	{
		return 1 <= day && day <= 31 && 1 <= month && month <= 12 && 1900 <= year && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{		
		return switch (month) {
			case 4, 6, 9, 11 -> 30;			
			case 2 -> isLeapYear(year) ? 29 : 28;
			default -> 31;
		};
		
		
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		NumberUtilIsArmstrongTest.run();
	}
}

class NumberUtilIsArmstrongTest {
	public static void run() 
	{
		for (int n = -1; n <= 999_999; ++n)
			if (NumberUtil.isArmstrong(n))
				System.out.println(n);
	}
}

class NumberUtil {	
	public static boolean isArmstrong(int val)
	{
		return val >= 0 && getDigitsPowSum(val) == val;
	}
	
	public static int getDigitsPowSum(int val)
	{
		int n = digitsCount(val);
		int result = 0;
		
		while (val != 0) {
			result += Math.pow(val % 10, n);
			val /= 10;
		}
		
		return result;
	}
	
	public static int digitsCount(int val)
	{
		return val == 0 ? 1 : (int)Math.log10(Math.abs(val)) + 1;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte void metotlar dolayısıyla error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		a > 0 ? Sample.foo() : Sample.bar(); //error
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
	}
	
	public static void bar()
	{
		System.out.println("bar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte koşul operatörü işleme sokulmadığı için error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		a > 0 ? Sample.foo() : Sample.bar(); //error
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
		
		return 10;
	}
	
	public static void bar()
	{
		System.out.println("bar");
		
		return 10;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki örnek if deyimi ile yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		if (a > 0)
			Sample.foo();
		else 
			Sample.bar();
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
	}
	
	public static void bar()
	{
		System.out.println("bar");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte 3 tane sayının en büyüğü bulunmuştur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Üç sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();
		int max;
		
		max = a > b ? a > c ? a : c : b > c ? b : c;
		
		System.out.printf("max(%d, %d, %d) = %d%n", a, b, c, max);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki koşul operatörüne ilişkin ifadenin daha okunabilir hale getirilmesi için sentaks olarak gerekmese de
	parantezler konulabilir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Üç sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();
		int max;
		
		max = (a > b) ? (a > c ? a : c) : (b > c ? b : c);
		
		System.out.printf("max(%d, %d, %d) = %d%n", a, b, c, max);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Üç sayı giriniz:");
		int a = kb.nextInt();
		int b = kb.nextInt();
		int c = kb.nextInt();
		int max;
		
		max = NumberUtil.max(a, b, c);
		
		System.out.printf("max(%d, %d, %d) = %d%n", a, b, c, max);
	}
}

class NumberUtil {
	public static int max(int a, int b, int c)
	{
		return (a > b) ? (a > c ? a : c) : (b > c ? b : c);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf içerisinde aynı isimde birden fazla metot bildirilmesi durumu (method overloading): Bir sınıf içerisinde
	aynı isimde birden fazla metot bildirilebilir. Buna method overloading denir. Farklı sınıflarda aynı isimde metotların
	olması method overloading değildir. Method overloading için şu iki sorunun cevaplarını ele alacağız:
		- Method overloading kuralları nelerdir?
		- Derleyici bir metot çağrıldığında hangi metodun çağrılacağına nasıl karar verecektir? (method overload resolution)
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte method overloading yapılmamıştır. Çünkü foo metotları ayrı sınıflardadır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo();
		Mample.foo();
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("Sample.foo");
	}
}

class Mample {
	public static void foo()
	{
		System.out.println("Mample.foo");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf içerisinde birden fazla AYNI metottan bildirilemez. Yani bir sınıf içerisinde metotların FARKLI olması
	gerekir. Bu durumda iki metodun AYNI ya da FARKLI olması durumlarının incelenmesi gerekir. İşte burada iki metodun
	AYNI ya da FARKLı olması durumlarına yönelik detaylar ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	İki metodun erişim belirleyicilerinin farklı olması o iki metodu farklı yapmaz. Yani overload işlemine etkisi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo() //error
	{
		//...
	}
	
	private static void foo() //error
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	İki metodun static veya non-static olması durumu metotları farklı yapmaz. Bu durumda overload'a etkisi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo() //error
	{
		//...
	}
	
	public void foo() //error
	{
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	İki metodun geri dönüş değerlerinin farklı olması da metotları farklı yapmaz. Yani overload'a etkisi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package csd;


class Sample {
	public static void foo() //error
	{
		//...
	}
	
	public static int foo() //error
	{
		//...
		
		return 0;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	İki metodun parametre değişkenlerinin isimlerinin farklı olması da metotları farklı yapmaz. Yani parametre değişken
	isimlerinin overload işlemine etkisi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo(int a) //error
	{
		//...
	}
	
	public static void foo(int b) //error
	{
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun overload edilebilmesi için parametrelerin türlerinin ve dizilimlerinin farklı olması gerekir. Bu anlamda
	bir metodun parametrelerinin türlerine ve dizilimlerine parametrik yapısı diyebiliriz. Yani bu durumda bir metodun
	overload edilebilmesi için parametrik yapısının diğer aynı isimde olan metotlardan farklı olması gerekir. Aşağıdaki
	metotları inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;


class Sample {
	public static void foo()
	{
		//...
	}
	
	public static void foo(int a)
	{
		//...
	}
	
	public static void foo(double a)
	{
		//...
	}
	
	public static void foo(double a, int b)
	{
		//...
	}
	
	public static void foo(int a, double b)
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir metodun imzası (signature) o metodun ismi ve parametrik yapı kombinasyonudur. Bir sınıf içerisinde aynı imzaya
	sahip birden fazla metot bildirimi geçersizdir. Aslında method overloading bu kavramın özel bir durumudur. İki
	metodun ismi aynı olacağına göre, imzaların farklı olması için parametrik yapısının farklı olması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public static void foo() //imza: foo
	{
		//...
	}
	
	public static void foo(int a) //imza: foo, int
	{
		//...
	}
	
	public static void foo(double a) //imza: foo, double
	{
		//...
	}
	
	public static void foo(double a, int b) //imza: foo, double, int
	{
		//...
	}
	
	public static void foo(int b, double a) //imza: foo, int, double
	{
		//...
	}
	
	public static void bar(int b, double a) //imza:bar, int, double
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici bir metot çağrısı gördüğünde hangi metodu çağrılacağına nasıl karar verecektir? Bu durumun ayrıntıları 
	vardır ve bu bölümde ele alınacaktır. Bu kavrama "method overload resolution" ya da kısaca "overload resolution"
	denir.  
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Overload resolution işleminde derleyici ismini en uygun metot (the most applicable) denilen metodu bulmaya çalışır. 
	Bunun için derleyici birazdan ele alacağımız sırayla metotları seçer. Ancak bu seçimin özel bir durumu olarak 
	çağrılan metoda geçilen argümanlar ile karşılık gelen parametrelerinin tür bakımından birebir uyumlu olduğu bir
	metot varsa o çağrılır. Bu kavrama "tam uyum (best match)" denir. 
	
	Derleyici overload resolution işlemini şu adımlardan geçerek yapar:
	1. Aday metotlar (candidate methods) belirlenir: Çağrılan metot ile aynı isimde olan tüm metotlardır. 
	
	2. Uygun metotlar (applicable methods) belirlenir: Çağrı sırasında geçilen argüman sayı ile parametre sayısı olan
	VE argümanların türünden karşılık geldikleri parametrenin türüne otomatik (implicit) tür dönüşümünün geçerli olduğu
	metotlardır. 
	
	3. En uygun metot (the most applicable method) belirlenir: En uygun metot öyle bir metottur ki, uygun metotlar
	arasında argümanlar ile parametreler kalite yarışına sokulduğunda toplamda daha iyi olan veya daha kötü olmayan
	metottur. Dönüşümün kalitesi şu şekilde belirlenir:
	T1 argümanın, T2 ve T3'de yarışa sokulan parametrelerin türleri ise:
	1. T1 -> T2 ve T1 -> T3 çağrıları yarışa sokulduğunda T2 veya T3'den birisi T1 ile aynı ise daha kalitelidir.
	Örneğin:
	int -> double
	int -> int *
	
	2. T1 -> T2 ve T1 -> T3 çağrıları yarışa sokulduğunda T2'den T3' otomatik dönüşüm var, T3'den T2'ye yoksa
	T2 daha kalitelidir. 
	Örneğin:
 	int -> long *
 	int -> float
	
	Bu adımlardan herhangi birisinde bir metot bulunamazsa error oluşur. Yani aday metot bulunamazsa VEYA aday
	metotlar var fakat uygun metot bulunamazsa VEYA uygun metotlar var en uygun metot bulunamazsa error oluşur. 
	  
	Anahtar Notlar: Aslında best match de yukarıda anlatılan biçimde yapılır. Ancak kolay anlaşılır olması açısından
	bu şekilde anlatılmıştır.
	
	Anahtar Notlar: Şüphesiz tam uyumlu çağrılar en idealidir. Ancak her zaman bu şekilde olmayabilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki çağrıda tam uyum vardır. Genel olarak incelersek:
	1. Aday metotlar: 1, 2, 3, 4, 5, 6
	2. Uygun metotlar: 5, 6
	3. En uygun metot: 5
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		double b = 4;
		
		Sample.foo(a, b);
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}
	
	public static void foo(double a, int b) //4
	{
		System.out.println("foo, double, int");
	}
	
	public static void foo(int b, double a) //5
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a, double b) //6
	{
		System.out.println("foo, long, double");
	}
	
	public static void bar(int b, double a) //7
	{
		System.out.println("bar, int, double");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	1. Aday metotlar: 1, 2, 3, 4, 5
	2. Uygun metotlar: 4, 5
	3. En uygun metot: 4
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		int b = 4;
		
		Sample.foo(a, b);
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}

	public static void foo(int b, double a) //4
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a, double b) //5
	{
		System.out.println("foo, long, double");
	}
	
	public static void bar(int b, double a) //6
	{
		System.out.println("bar, int, double");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Genel olarak incelersek:
	1. Aday metotlar: 1, 2, 3, 4, 5
	2. Uygun metotlar: 4, 5
	3. En uygun metot: Yok
	
	Örnekte en uygun metot olmadığından yani "uygun metotlar arasında toplamda daha iyi ya da ya da daha kötü olmayan
	dönüşümü sunan" bir tane metot bulunmadığından error oluşur. Bu duruma iki anlamlılık (ambiguity) denir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		int b = 4;
		
		Sample.foo(a, b); //error: ambiguity
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}

	public static void foo(int b, double a) //4
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a, float b) //5
	{
		System.out.println("foo, long, float");
	}
	
	public static void bar(int b, double a) //6
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	28.10.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Genel olarak incelersek:
	1. Aday metotlar: 1, 2, 3, 4, 5
	2. Uygun metotlar: Yok
	
	Örnekte uygun metot bulunamadığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b = 4;
		
		Sample.foo(a, b); //error
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}

	public static void foo(int b, double a) //4
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a, float b) //5
	{
		System.out.println("foo, long, float");
	}
	
	public static void bar(int b, double a) //6
	{
		System.out.println("bar, int, double");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Genel olarak incelersek:
	1. Aday metotlar: Yok
	Örnekte aday metot bulunamadığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b = 4;
		
		Sample.fo(a, b); //error
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}

	public static void foo(int b, double a) //4
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a, float b) //5
	{
		System.out.println("foo, long, float");
	}
	
	public static void bar(int b, double a) //6
	{
		System.out.println("bar, int, double");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Genel olarak incelersek:
	1. Aday metotlar: 1, 2, 3, 4, 5
	2. Uygun metotlar: 4
	3. En uygun metot: 4
	
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		int b = 4;
		
		Sample.foo(a, (double)b);
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}

	public static void foo(int b, double a) //4
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a, float b) //5
	{
		System.out.println("foo, long, float");
	}
	
	public static void bar(int b, double a) //6
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Genel olarak incelersek:
	1. Aday metotlar: 1, 2, 3, 4, 5
	2. Uygun metotlar: 4, 5
	3. En uygun metot: 5
	
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		short a = 10;
		int b = 4;
		
		Sample.foo((int)a, b); //error
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}

	public static void foo(int b, double a) //4
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a,  float b) //5
	{
		System.out.println("foo, long, float");
	}
	
	public static void bar(int b, double a) //6
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki çağrıda tam uyum vardır. Genel olarak incelersek:
	1. Aday metotlar: 1, 2, 3, 4, 5, 6
	2. Uygun metotlar: 4
	3. En uygun metot: 4
	
	Örnekte best match olduğuna dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		double b = 4;
		
		Sample.foo((double)a, (int)b);
	}
}

class Sample {
	public static void foo() //1
	{
		System.out.println("foo");
	}
	
	public static void foo(int a) //2
	{
		System.out.println("foo, int");
	}
	
	public static void foo(double a) //3
	{
		System.out.println("foo, double");
	}
	
	public static void foo(double a, int b) //4
	{
		System.out.println("foo, double, int");
	}
	
	public static void foo(int b, double a) //5
	{
		System.out.println("foo, int, double");
	}
	
	public static void foo(long a, double b) //6
	{
		System.out.println("foo, long, double");
	}
	
	public static void bar(int b, double a) //7
	{
		System.out.println("bar, int, double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Method overload resolution kavramının temel türler dışındaki bazı ayrıntıları konular içerisinde
	ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Nesne Yönelimli Programalama Tekniği (Object Oriented Programming): Nesne yönelimli programlama tekniğini (NYPT) tek
	bir cümle ifade etmek etmek pek mümkün değildir. Ancak bu tekniği bilen veya belirli ölçüde fikri olan birisine
	"sınıflar kullanarak program yazma tekniğidir" denebilir. NYPT aslında anahtar kavramların birleşiminden oluşur. Bu 
	anahtar kavramlar içiçe geçmiş daireler biçiminde düşünülebilir. Tüm bu anahtar kavramların temelinde kodun
	okunabilir/algılanabilir olması ve iyi yönetilmesi vardır. Örneğin, benzer işi yapan metotlara aynı ismin verilmesi
	(method overloading) programcıyı "çok şey var" duygusundan uzaklaştırıp, "az şey var" gibi bir algı oluşuturur. Bu
	da hatırlamayı kolaylaştırır ve kodun okunabilirliğini/algılanabilirliğini artırır
	
	NYPT insanının doğayı algılama biçimini model alır. İnsanlar her şeyi nesne biçiminde ele alıp kullanırlar. Örneğin
	herkesin bilgisayarı olabilse de konuşurken bunu bilgisayar olarak konuşuruz. Yani aslında bilgisayar soyut bir
	kavramdır, örneğin bize ait olan bir bilgisayar somutlaşmıştır. Bu anlamda, herkesin sahip olduğu şey (thing) 
	bilgisayardır. 
	
	NYPT'de artık fonksiyonlarla (Java'da metot) değil sınıflarla konuşulur. Böylece yine "çok şey var" duygusundan 
	uzakkaşıp, "az şey var" algısı oluşur. Bu anlamda sınıf ve nesne seviyesinde detaylar programcıdan gizlenmiş olur.
	Bu da yine algıyı kolaylaştırır.
	
	Burada anlatıların pek çok detayı vardır. Burada bir özet biçiminde ele alınmıştır. Bu kavramlar ve burada anlatılmayanlar
	Konular içerisinde detaylandırılacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	29.10.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Anımsanacağı gibi bir değişkenin bellekte yaratılmasıyla yani yer ayrılmasıyla, yok edilmesi yani o bellek alanının 
	o değişken içi artık kullanılmaması arasındaki süreye değişkenin ömrü (storage duration) denir. Peki, bir değişken
	için ayrılan bellek bölgesi neresidir? İşte bir Java uygulaması çalıştırıldığında o uygulama için iki tane
	bellek alanı ayrılır: stack, heap. Şüphesiz aşağı seviyede başka bir alanlar da söz konusudur. Stack ve heap, Java 
	seviyesinde ayrılan alanlar olarak düşünülebilir. Stack ve heap RAM'de organize edilir. Program çalıştırılırken bu 
	alanların uzunlukları ayarlanabilir. Herhangi bir belirleme yapılmazsa default uzunluklar kullanılır.
	
	
	Anahtar Notlar: Veri Yapıları (Data Structure): Birbiriyile genel olarak ilişkili olan verilerin belirli bir takım
	algoritmalara göre bir arada tutulmasını sağlayan ve gerektiğinde bu verilere erişilebilen yapılara denir. Stack 
	Last In First Out (LIFO) kuyruk biçiminde çalışan bir veri yapısıdır. Bu veri yapısında eleman ekleme işlemine "push",
	son eklenen elemanı silme işlemine ise "pop" denilmektedir. Bu veri yapısı örneğin editörlerin "undo-redo"
	işlemlerinde kullanılır. Örneğin undo yapıldığında undo stack'den pop yapılır ve redo stack'e push yapılır. Redo 
	yapıldığında ise redo stack'ten pop yapılır, undo stack'e push yapılır. Stack alanında yaratma ve yok etme işlemleri 
	stack veri yapısındaki gibi olduğundan bu alana stack alanı denir. Aslında stack alanı donanımsal olarak da 
	desteklenen bir yapıdır.
	
	Yerel değişkenler ve parametre değişkenleri stack alanında yaratılır. Stack doldur boşalt biçiminde çalışan bir
	bellek alanıdır. Böylece toplamda uzunluğundan daha fazla değişken için yer ayrılabilir.     
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------
	Yerel değişkenler akış kod bakımından bildirim noktasına geldiğinde yaratılırlar, bildirildikleri blok sonunda yok 
	edilirler. Bu durumda bir yerel değişkeninin yaratılması push komutuyla, yok edilmesi ise pop komutuyla yapılır. Bu 
	durumda peşpeşe bildirilen yerel değişkenler sırasıyla push edilir, ters sırada pop edilir. Bu durumda faaliyet alanı (scope)
	ve ömür (storage duration) arasında dolaylı bir ilişki de vardır. Anımsanacağı gibi compile time ve runtime'a ilişkin
	ayrı kavramlardır   
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		{
			int a; //a yaratılır
			int b; //b yaratılır
			
			//...
		} // b yok edilir, a yok edilir
	
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Parametre değişkenleri metot çağrıldığında yaratılır, metot çağrısı bittiğinde yok edilir   
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo(10, 20); //Parametre değişkenleri a ve b yaratılır, x yaratılır ...
		//x yok edilir, b ve a yok edilir
		
		//...
		
		Sample.foo(10, 20); //Parametre değişkenleri a ve b yaratılır, x yaratılır ...
		//x yok edilir, b ve a yok edilir
	}
}

class Sample {
	public static void foo(int a, double b)
	{
		int x;
		
		x = a++;
		
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf içerisinde, tüm metotların dışında bildirilen değişkenlere sınıf veri elemanı (class data member) denir. 
	Bu anlamda sınıf veri elemanları sınıf içerisinde bildirilen değişkenler olarak düşünülmelidir. Veri elemanları
	şu erişim belirleyicilere sahip olabililr: public, no-modifier, protected, private. İlgili konuya gelene kadar
	tüm veri elemanlarını public olarak bildireceğiz. Bir veri elemanı static veya non-static olabilir. static anahtar
	sözcüğü ile bildirildiğinde static olur. 
	
	Anahtar Notlar: Sınıf içerisindeki bildirimlere sınıfın elemanları (member) denir. Bu anlamda sınıfın elemanı bir
	değişken ise buna veri elemanı (data member, member variable, field) denir. Sınıfın elemanı bir alt program ise
	buna metot (method) denir. Sınıfın ilerideki konularda ele alacağımız başka elemanları da (member) olabilmektedir
	
	Bir veri elemanının faaliyet alanı ve ömrü ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;


class Sample {
	private static int x;
	public static void foo()
	{
		
	}
	
	public double y;
	protected static float z;
}


/*----------------------------------------------------------------------------------------------------------------------
	Java'da sınıf dışında değişken bildirimi geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

int a; //error

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf bildirimi aslında bir tür bildirimidir. Bu anlamda Java'da sınıf dışında da çeşitli tür bildirimleri 
	yapılabilmektedir. Bu şekilde yapılan tür bildirimlerine user defined types (UDT) denilmektedir. Bu durumda bir 
	sınıf da bir UDT'dir. Aşağıdaki sınıfların her biri bir UDT'dir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Student {
	//...
}

class SerialPort {
	//...
}

class Device {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Madem ki sınıf bildirimi bir tür bildirimidir, bu durumda sınıf türünden değişkenler bildirilebilir. 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Student s;
		SerialPort sp;
		Device d;
		
		//...
	}
}

class Student {
	//...
}

class SerialPort {
	//...
}

class Device {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Java'da türler kategoriye ikiye ayrılır: değer türleri (value types), referans türleri (reference types)
	T bir tür ismi olmak üzere T türden bir değişken içerisinde adres tutuluyorsa T bir referans türüdür, tutulmuyorsa
	değer türüdür. Java'da tüm temel türler değer türüdür. Yani temel türden bir değişken içerisinde adres tutulamaz.
	Sınıflar Java'da referans türleridir. Yani bir sınıf türünden değişken içerisinde adres tutulur. Aslında genel olarak
	temel türler dışında tüm türler (UDT'ler) Java'da referans türleridir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf türünden bir değişkene referans değişken ya da kısaca referans denir. Java seviyesinde referans terimi
	adres (address) terimi yerine de kullanılmaktadır. Bu anlamda referans dendiğinde ya bir adres kastedilmiş olur
	ya da adres tutabilen referans değişken kastedilmiş olur. Örneğin bir cümle içerisinde "reference of an object"
	dendiğinde nesnenin adresi kastedilir. Ya da örneğin, "address of an object is assigned to a reference" dendiğinde
	nesnenin adresini tutan referans kastedilmiş olur
	
	Peki bu referanslara nasıl değer atanacak?
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Student s; //s referans (değişkeni)
		SerialPort sp; //sp referans (değişkeni)
		Device d; //d referans (değişkeni)
	
		//...
	}
}

class Student {
	//...
}

class SerialPort {
	//...
}

class Device {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	- Sınıf türünden bellekte ayrılan bir alana nesne (object) denir.
	
	- Nesneler heap alanında yaratılırlar. Java'da stack'de nesne yaratılamaz.
	
	- Java'da nesnelerin kendileri tutulamaz, adresleri tutulabilir. Bu adresler de aynı türden referans değişkenlerde 
	tutulabilir
	
	- Bir nesne new operatörü ile yaratılabilir. new operatörünün genel biçimi şu şekildedir:
	
	 	new <sınıf ismi>([argümanlar]);
	 	
	 Bu operatör özel amaçlı, tek operandlı ve önek durumundadır. bu operatör bellekte ilgili türden nesnenin yaratılmasını
	 sağlar ve yarattığı nesnenin adresini (referansını) üretir. Bir nesne için bellekte ne kadar uzunlukta yer ayrıldığı
	 ileride ele alınacaktır. Aşağıdaki örnekte s, sp ve d birer nesne DEĞİLDİR. Nesnelerin adreslerini tutan değişkenlerdir.
	 Örnekte *, ** ve *** ilem belirtilen deyimlerde ilgili referanslara, yaratılmış olan nesnelerin adresleri atanmıştır.
	 Bu durumda artık ilgili referanslar nesneleri gösteriyor (reference to) duruma gelir. 
	 
	 - Bir nesne ilgili sınıf türünden bir örnektir. Buna ingilizce olarak "instance" terimi de kullanılır. Bu anlamda
	 nesne yaratma içinde "create" ile birlikte "instantiate" fiili de kullanılmaktadır.
	 
	 - Referans ve nesne birbirlerinden farklı kavramlardır. Referans bir nesneyi gösterir ya da adres anlamında 
	 kullanıldığında nesnenin adresidir
	 
	 - Her new işlemi yeni bir nesne yaratmak demektir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Student s; //s referans (değişkeni)
		SerialPort sp; //sp referans (değişkeni)
		Device d; //d referans (değişkeni)
		
		s = new Student(); //*
		sp = new SerialPort(); //**
		d = new Device(); //***

		//...
	}
}

class Student {
	//...
}

class SerialPort {
	//...
}

class Device {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static veri elemanları her nesne için ayrıca yaratılır. Yani sınıfın non-static bir veri elemanı o sınıf
	türünden bir nesnenin içerisinde bulunur. Yani o nesneye özeldir. Sınıfın non-static bir veri elemanına sınıf dışından 
	referans ve nokta operatörü ile erişilebilir. Nokta operatörü özel amaçlı iki operandlı ve araek durumundadır. Nokta
	operatörünün referans ile kullanımında ikinci operandı sınıfın veri elemanı ise o veri elemanına ilişkin değişkeni 
	üretir. Bu durumda referans ile erişim hangi nesneye ait olduğunu belirtmiş olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.x = 10;
		s.y = true;
		k.x = 20;
		k.y = false;
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
		System.out.printf("k.x = %d, k.y = %b%n", k.x, k.y);
	}
}

class Sample {
	public int x;
	public boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir nesne yaratıldığında o nesnenin non-static veri elemanlarına default değerler atanır. Default değer türe özgü
	mantıksal sıfır değeridir (zero value or default value). Örneğin, int türü için sıfır değeriyken boolean türü için 
	false değeridir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s;
		
		s = new Sample();
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
		
		s.x = 10;
		s.y = true;
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
	}
}

class Sample {
	public int x;
	public boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte içerisine değer atanmamış bir değişken kullanıldığından error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Sample s;
		
		s.x = 10;
		s.y = true;
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
	}
}

class Sample {
	public int x;
	public boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	04.11.2023	
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	İki tane aynı türden referansın birbirine atanması durumunda artık her iki referans da aynı nesneyi gösterir duruma
	gelir. Bu durumda hangi referans ile nesneye erişilmesinin önemi yoktur. Çünkü her iki referans ile de aynı nesneye
	erişilir. Aşağıdaki örnekte k = s atama işleminden sonra k ve s aynı nesneyi gösterir duruma gelmiştir. Bu durumda
	herhangi bir referans üzerinden yapılan bir değişiklik diğer referans ile erişilerek de görülebilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
		Sample k;
		
		s.x = 10;
		s.y = true;
		
		k = s;
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
		System.out.printf("k.x = %d, k.y = %b%n", k.x, k.y);
		
		++k.x;
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
		System.out.printf("k.x = %d, k.y = %b%n", k.x, k.y);
	}
}


class Sample {
	public int x;
	public boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	 Aşağıdaki örnekte adres ataması yapılmadığı için, yani atanan "ŞEY" bir adres olmadığı için b'nin değişmesi a'yı 
	 etkilemez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int a = 10;
		int b;
		
		b = a;
		
		System.out.printf("a = %d, b = %d%n", a, b);
		
		++b;
		
		System.out.printf("a = %d, b = %d%n", a, b);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir nesnenin uzunluğu en az non-static veri elemanlarının toplam uzunluğu kadarıdır. Aynı türden nesnelerin uzunlukları
	aynıdır. Yani başka bir deyişle aynı türden her nesne için bellekte aynı uzunlukta yer ayrılır. Ancak nesneler farklı
	türdense aynı uzunlukta olmaları gerekmez. Bir referansın uzunluğu sistemden sisteme farklılık gösterir. Örneğin 
	64 bit sistemlerde 8 byte iken, 32 bit sistemlerde 4 byte'dır. Türü ne olursa olsun tüm referansların uzunluğu o 
	sistem için aynıdır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Farklı türden referanslar birbirine explicit olarak bile atanamazlar
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
		Mample m;
		
		m = (Mample)s; //error
	}
}


class Sample {
	public int x;
	public boolean y;
	
	//...
}

class Mample {
	public int x;
	public boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Anımsanacağı gibi Java'da 3 yerde atama yapılabilir. İstisna bir takım kurallar dışında atama işlemlerine ilişkin
	kurallar hepsi için geçerlidir. Bir metodun parametre değişkeni bir referans olabilir. Bu durumda metot aynı türden
	bir referans ile çağrılabilir. Bu durumda metot içerisinde argüman olarak geçilen referansa ilişkin nesneye 
	erişilebilir. Bir metodun parametre geri dönüş değeri bir referans olabilir. Bu durumda return deyimine ilişkin
	ifadenin de aynı türden bir referans olması gerekir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Date d = DateUtil.createDate(11, 7, 1983);
		
		DateUtil.printDate(d);		
		DateUtil.changeDate(d, 6, 9, 2021);
		DateUtil.printDate(d);
	}
}

class DateUtil {
	public static Date createDate(int day, int month, int year)
	{
		//...
		Date date = new Date();
		
		date.day = day;
		date.month = month;
		date.year = year;
		
		return date;
	}
	
	public static void changeDate(Date date, int day, int month, int year)
	{
		//...
		date.day = day;
		date.month = month;
		date.year = year;
	}
	
	public static void printDate(Date date)
	{
		System.out.printf("%02d/%02d/%04d%n", date.day, date.month, date.year);
	}
}

class Date {
	public int day, month, year;
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	05.11.2023
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte adres ataması yapılmadığı için, yani atanan "ŞEY" bir adres olmadığı için a'nın değişmesi b'yi 
	etkilemez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		int b = 10;
		
		Sample.foo(b);
		
		System.out.printf("b = %d%n", b);
	}
}

class Sample {
	public static void foo(int a)
	{
		System.out.printf("foo:a = %d%n", a);
		++a;
		System.out.printf("foo:a = %d%n", a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ** ile belirtilen deyimden sonra s artık yeni nesneyi gösterir durumdadır. Her new işleminin yeni
	bir nesne yaratmak anlamına geldiğini anımsayınız
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
		Sample k;
		
		s.x = 10;
		s.y = true;
		
		k = s;
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
		System.out.printf("k.x = %d, k.y = %b%n", k.x, k.y);
		System.out.println("---------------------------------------------");
		
		++k.x;
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
		System.out.printf("k.x = %d, k.y = %b%n", k.x, k.y);
		System.out.println("---------------------------------------------");
		
		s = new Sample(); //**
		
		System.out.printf("s.x = %d, s.y = %b%n", s.x, s.y);
		System.out.printf("k.x = %d, k.y = %b%n", k.x, k.y);
		System.out.println("---------------------------------------------");
	}
}

class Sample {
	public int x;
	public boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static veri elemanları nesneye ait değildir. Yani static veri elemanlarına erişim için nesne yaratılması
	gerekmez. Sınıfın static veri elemanı sınıfın bir elemanı (member) ilk kez kullanıldığında yaratılır ve program
	sonuna kadar yaşar. Sınıfın bir elemanı ilk kez kullanıldığından tüm static veri elemanları yaratılırlar. Bu durumda
	sınıfın static bir veri elemanı toplamda bir tanedir. Sınıfın static bir veri elemanına sınıf dışından sınıf ismi ve
	nokta operatörü ile erişilir. Sınıfın static bir veri elemanı yaratıldığında default değer verilir. Sınıfın static
	bir veri elemanı stack'de yaratılamaz. Aşağı seviyede değişebilse de Java programcısı açısından "dolaylı olarak 
	heap'de yaratılır" olarak düşünülebilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.printf("Sample.x = %d, Sample.y = %b%n", Sample.x, Sample.y);
		Sample.x = 10;
		Sample.y = true;
		System.out.printf("Sample.x = %d, Sample.y = %b%n", Sample.x, Sample.y);
	}
}

class Sample {
	public static int x;
	public static boolean y;
	
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static bir veri elemanına sınıf dışından sınıf ismi ve nokta operatörü ile erişilemez. Çünkü non-static
	veri elemanları nesneye aittir ve referans olmadan hangi nesneye ait olduğu bilinemez
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.x = 10; //error
		Sample.y = true; //error
	}
}

class Sample {
	public int x;
	public boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static bir veri elemanına sınıf dışından referans ve nokta operatörü ile de erişilebilir. Ancak bunun sınıf
	ismi ile erişmekten hiç bir farkı yoktur. Bu dilin garamerinin bir sonucudur. Ancak programcı açısından bu tercih
	edilmemesi gereken bir kullanımdır. Çünkü okunabililirliği/algılanabilirliği olumsuz etkiler. Bu anlamda programcı
	açısından bu adeta geçersiz gibi düşünülmelidir (gönlümüzün error'u).
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
	
		s.x = 10;
		s.y = true;
		System.out.printf("Sample.x = %d, Sample.y = %b%n", Sample.x, Sample.y);
	}
}

class Sample {
	public static int x;
	public static boolean y;
	
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örnekte yaratıkların sayısı ve askerlerin sayısı sınıfları kullanan programcı tarafından tutulmaktadır
	Bu durumda diğer türler için de sayaçlar tutulacaksa programcı açısından iki temel sorun oluşabilecektir:
	1. İlgili değişkenlere isim bulma zahmeti oluşacaktır
	2. Programcı sayaçları artırma ve azaltma işlemlerinde hata yapabilir
	
	Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		DemoGameApp.run();
	}
}

class DemoGameApp {
	public static void run()
	{
		int soldierCount = 0;
		int alienCount = 0;
		
		for (int i = 0; i < 10; ++i) {
			Alien a = new Alien();
			
			++alienCount;
			
			//...
		}
		
		for (int i = 0; i < 20; ++i) {
			Soldier s = new Soldier();
			
			++soldierCount;
			
			//...
		}
		
		System.out.printf("Number of aliens:%d%n", alienCount);
		System.out.printf("Number of soldiers:%d%n", soldierCount);
		//...
	}
}

class Alien {
	public int armCount;
	public int color;
	//...
}

class Soldier {
	public int title;
	public int gunCount;
	//...
}

class Building {
	//...
}

class Animal {
	//...
}

class Citizen {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki problemler, sayaç sınıf içerisinde static bir veri elemanı olarak bildirilirse çözülebilir. Aşağıdaki
	örnekte sayacın artırılması noktası şu an için önemsizdir. Static ve non-static veri elemanının kullanımına 
	odaklanınız. Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		DemoGameApp.run();
	}
}

class DemoGameApp {
	public static void run()
	{
		for (int i = 0; i < 10; ++i) {
			Alien a = new Alien();
	
			//...
		}
		
		for (int i = 0; i < 20; ++i) {
			Soldier s = new Soldier();
			
			//...
		}
		
		System.out.printf("Number of aliens:%d%n", Alien.count);
		System.out.printf("Number of soldiers:%d%n", Soldier.count);
		//...
	}
}

class Alien {
	public static int count;
	public int armCount;
	public int color;
	//...
	
	public Alien()
	{
		++count;
	}
	//...
}

class Soldier {
	public static int count;
	public int title;
	public int gunCount;
	//...
	
	public Soldier()
	{
		++count;
	}
	//...
}

class Building {
	public static int count;
	//...
}

class Animal {
	public static int count;
	//...
}

class Citizen {
	public static int count;
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static bir metodu sınıf dışından referans ve nokta operatörü ile çağrılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
		Sample k = new Sample();
		
		s.foo();
		k.foo();
	}
}

class Sample {
	public void foo()
	{
		System.out.println("foo");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static bir metodu sınıf dışından sınıf ismi ile çağrılamaz  
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo(); //error
	}
}

class Sample {
	public void foo()
	{
		System.out.println("foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static bir metodu sınıf dışından sınıf ismi ve nokta operatörü ile çağrılabilir. Bunu zaten kursun ilk 
	günlerinden beri kullanıyoruz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample.foo();
	}
}

class Sample {
	public static void foo()
	{
		System.out.println("foo");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static bir metodu sınıf dışından referans ve nokta operatörü ile de çağrılabilir. Ancak sınıf ismi ile 
	çağırmaktan farkı yoktur. Programcı static metotları her zaman sınıf ismi ile çağırmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
		
		s.foo(); //gönlümüzün error'u
	}
}

class Sample {
	//...
	public static void foo()
	{
		System.out.println("foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Static ve non-static metotların çağrılma biçimine bakıldığında non-static metotların nesne ile
	ilişkili olduğu, static metotların ise nesne ile ilişkili olmadığı anlaşılmaktadır. Bu ilişki ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki erişimlerin hepsinin ilgili sınıfın dışından yapılan erişimler olduğuna dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static bir metodu içerisinde, aynı sınıfın non-static bir veri elemanına doğrudan (nokta operatörü kullanmadan)
	erişilebilir. Bu durumda erişilen non-static veri elemanı non-static metodun çağrısında kullanılan referansın 
	gösterdiği nesneye ait olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
		Sample k = new Sample();
		
		s.set(10);
		k.set(20);
		s.print();
		k.print();
	}
}

class Sample {
	public int x;
	 
	public void set(int a)
	{
		x = a;
	}
	
	public void print()
	{
		System.out.printf("x = %d%n", x);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static bir metodu içerisinde, aynı sınıfın non-static bir metodu doğrudan çağrılabilir. Bu durumda
	çağrılan non-static metot, onu çağıran non-static metodun çağrılmasında kullanılan referans ile çağrılmış olur
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample();
		Sample k = new Sample();
		
		s.setAndPrint(10);
		k.setAndPrint(20);
	}
}

class Sample {
	public int x;
	 
	public void set(int a)
	{
		x = a;
	}
	
	public void setAndPrint(int a)
	{
		set(a);
		System.out.printf("x = %d%n", x);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki kurala göre sınıfın non-static bir metodu içerisinde aynı sınıfın non-static elemanlarına doğrudan
	erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	11.11.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static bir metodu içerisinde aynı sınıfın static bir veri elemanına doğrudan erişilebilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.printf("Sample.y = %d%n", Sample.y);
		Sample s = new Sample();
		
		s.set(20);
		System.out.printf("Sample.y = %d%n", Sample.y);
	}
}

class Sample {
	public int x;
	public static int y;
	 
	public void set(int a)
	{
		x = a;
		y = ++a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın non-static bir metodu içerisinde aynı sınıfın static bir metodu doğrudan çağrılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.printf("Sample.y = %d%n", Sample.y);
		Sample s = new Sample();
		
		s.set(20);
		System.out.printf("Sample.y = %d%n", Sample.y);
	}
}

class Sample {
	public int x;
	public static int y;
	 
	public void set(int a)
	{
		x = a;
		setY(++x);
	}
	
	public static void setY(int b)
	{
		y = b;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki kurala göre sınıfın non-static bir metodu içerisinde aynı sınıfın static elemanlarına doğrudan
	erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki dört kurala göre sınıfın non-static bir metodu içerisinde aynı sınıfın tüm elemanlarına doğrudan
	erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static bir metodu içerisinde aynı sınıfın non-static bir veri elemanına doğrudan erişilemez 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public int x;
	 
	public static void set(int a)
	{
		x = a; //error
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static bir metodu içerisinde aynı sınıfın non-static bir metodu doğrudan çağrılamaz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public int x;
	 
	public void set(int a)
	{
		x = a;
	}
	
	public static void setAndPrint(int a)
	{
		set(a); //error
		System.out.printf("x = %d%n", x);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki kurala göre sınıfın static bir metodu içerisinde aynı sınıfın non-static elemanlarına doğrudan
	erişilemez
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static bir metodu içerisinde aynı sınıfın static bir veri elemanına doğrudan erişilebilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.printf("Sample.x = %d%n", Sample.x);
		Sample.set(20);
		System.out.printf("Sample.x = %d%n", Sample.x);
	}
}

class Sample {
	public static int x;
	 
	public static void set(int a)
	{
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıfın static bir metodu içerisinde aynı sınıfın static bir metodu doğrudan çağrılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		System.out.printf("Sample.x = %d%n", Sample.x);
		Sample.setAndPrint(20);
		System.out.printf("Sample.x = %d%n", Sample.x);
	}
}

class Sample {
	public static int x;
	 
	public static void set(int a)
	{
		x = a;
	}
	
	public static void setAndPrint(int a)
	{
		set(a);
		System.out.printf("x = %d%n", x);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki kurala göre sınıfın static bir metodu içerisinde aynı sınıfın static elemanlarına doğrudan
	erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki dört kurala göre sınıfın static bir metodu içerisinde aynı sınıfın yalnızca static elemanlarına doğrudan
	erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki sekiz kurala göre sınıfın non-static bir metodu içerisinde aynı sınıfın tüm elemanlarına doğrudan
	erişilebilirken, static bir metodu içerisinde yalnızca static elemanlarına doğrudan erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Programcı bir metodu static mi non-static mi yazacağına nasıl karar verecektir? Bir metot non-static bir elemana
	doğrudan erişmeyecekse static yapılmalıdır. Yani bir metodun çağrılması için ortada bir nesnenin olması gerekmiyorsa
	metot static yapılmalıdır. Böylelikle, bir metodun static yapılması, non-static bir metodun okunabilirliğini 
	artırır. Çünkü, bu convention ile kodu okuyan kişi non-static bir metot gördüğünde metodun sınıfın non-static bir
	elemanına erişitiğini yani ortada bir nesnenin olması gerektiğini anlar 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte dorğudan erişim yapılmadığına dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class Sample {
	public int x;
	 
	public static void set(int a)
	{
		Sample s = new Sample();
		
		s.x = 10;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p1 = new Point();
		Point p2 = new Point();
		
		p1.print();
		p2.print();
		
		p1.x = 3.456;
		p1.y = 567.89;
		p2.x = 400;
		p2.y = -345;
		
		p1.print();
		p2.print();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p1 = new Point();
		Point p2 = new Point();
		
		p1.x = 10;
		p1.y = 20;
		p2.x = -345;
		p2.y = 400;
		
		p1.print();
		p2.print();
		
		p1.offset(-10, 20);
		p2.offset(-20);
		
		p1.print();
		p2.print();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p1 = new Point();
		Point p2 = new Point();
		
		p1.x = 100;
		p1.y = 200;
		p2.x = 103;
		p2.y = 196;
		
		p1.print();
		p2.print();
		
		double dist = p1.distance(p2);
		
		System.out.printf("Distance:%f%n", dist);
		
		dist = p1.distance(103, 196);
		
		System.out.printf("Distance:%f%n", dist);
		
		dist = p1.distance();
		
		System.out.printf("Distance:%f%n", dist);
	}
}

class Point {
	public double x, y;
	
	//...
	
	public double distance()
	{
		return distance(0, 0);
	}
	
	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}
	
	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}
	
	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%f, %f)%n", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	12.11.2023	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Nesne Yaratılması Adımları: Nesne yaratılması 3 tane adımın sonunda tamamlanmaktadır. Yani akış new operatörüne 
	geldiğinde aşağıdaki 3 adım tamamlanınca nesne yaratılmış olur yani başka bir deyişle nesnenin adresi elde edilmiş
	olur. Adımlar şunlardır:
	1. Bellekte yer ayrılır.
	2. non-static olan ve final olmayan veri elemanlarına default değerler verilir.
	3. Constructor (ctor) çağrılır.
	
	Bu 3 adımdan herhangi bir tanesinde bir problem olursa örneğin ctor içerisinde exception oluşursa nesnenin
	yaratılması tamamlanmamış olur ve adres elde edilemez. Yine örneğn heap de yer kalmaması durumunda 1. adımda yer 
	ayrılamayacağından nesne yaratılamaz. Yani nesnenin yaratılması için kesinlikle bu 3 adımın da tamamlanmış olması 
	gerekir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Ctor aşağıdaki özelliklere sahip bir metottur:
	- Sınıfı yazan programcı herhangi bir ctor yazmazsa derleyici tarafından parametresiz ctor public ve içi boş olarak
	yazılır. Parametresiz ctor'a default ctor denilmektedir. Programcı sınıfa herhangi ctor yazarsa derleyici artık
	default ctor'u yazmaz. Artık default ctor gerekirse sınıfı yazan programcı tarafından yazılmalıdır. 

	- Ctor sınıf ismi ile aynı isimde olan ve geri dönüş değeri kavramı olmayan (void da yazılmayan) bir metottur. 
	Sınıf ismi ile aynı isimde olan bir metoda geri dönüş değeri bilgisi yazıldığında error oluşmaz ancak bu artık ctor 
	değildir. Şüphesiz sınıf ismi ile aynı isimde olan ancak ctor olmayan bir metot yazılmamalıdır.
	
	- Ctor'un da metotlarda olduğu gibi erişim belirleyicisi olabilir.
	
	- Ctor overload edilebilir.
	
	- Hangi ctor'un çağrılacağı ne operatöründe geçilen argümanlara göre method overload resolution kurallarına göre
	belirlenir. 
	
	- Ctor non-static bir metottur. Bu anlamda sınıfın non-static elemanlarına (tabii ki static elemanları da)
	doğrudan erişilebilir.
	
	- Ctor'dan önce non-static olan ve final olmayan veri elemanlarına default değerler verilir.
	
	- Ctor içerisinde istenirse sonlandırmak için void bir metot gibi return deyimi tek başına kullanılabilir. Bu sonlandırma
	normal bir sonlandırmadır yani nesnenin yaratılması tamamlanmış olur.
	
	- Programcı ctor'u çağıramaz. Programcı ctor'un çağrılmasına yol açan kodu yazar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s1 = new Sample(); //default ctor
		
		System.out.println("------------------------------------------");
		Sample s2 = new Sample(10); //Sample, int
		
		System.out.println("------------------------------------------");
		Sample s3 = new Sample('a'); //Sample, int
		
		System.out.println("------------------------------------------");
		
		Sample s4 = new Sample(10, 2.3); //Sample, int, double
		
		System.out.println("------------------------------------------");
		Sample s5 = new Sample(10, 20); //Sample, int, double
	}
}

class Sample {
	public Sample()
	{
		System.out.println("I am a default ctor of Sample");
	}
	
	public Sample(int a)
	{
		System.out.println("I am a ctor of Sample with parameter type int");
	}
	
	public Sample(int a, double b)
	{
		System.out.println("I am a ctor of Sample with parameters type int and double");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte programcı Sample sınıfına int parametreli bir ctor eklediği için derleyici artık default ctor'u
	yazmaz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s = new Sample(); //error
	}
}

class Sample {
	public Sample(int a)
	{
		System.out.println("I am a ctor of Sample with parameter type int");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bir metodun gövdesinin boş olması genel olarak anlamsızdır. Yani çağrılsa da çağrılmasa da aynı 
	etkidedir. Şüphesiz programcı metodu bildirip daha sonra kodlarını yazmak üzere gövdesini boş bırakabilir. Bu başka
	bir durumdur. Ancak ctor'un gövdesinin boş olması anlamlıdır. Çünkü bu durumda nesne, non-static veri elemanlarınde
	default değerleri olacak şekilde yaratılmış olur. Eğer ilgili ctor yazılmazsa nesne o şekilde yaratılamaz. Yani 
	ctor'un gövdesinin boş olması ile bir metodun gövdesinin boş olması aynı şey değildir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz. Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s1 = new Sample(10, true);
		Sample s2 = new Sample(-10, true);
		
		System.out.printf("s1.x = %d, s1.y = %b%n", s1.x, s1.y);
		System.out.printf("s2.x = %d, s2.y = %b%n", s2.x, s2.y);
	}
}

class Sample {
	public int x;
	public boolean y;
	
	public Sample(int a, boolean b)
	{
		if (a < 0)
			return;
		
		x = a;
		y = b;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Ctor içerisinde, adından ve yapısından da anlaşılabileceği gibi bir nesnenin yaratılma adımlarında ilk işlemler 
	yapılır. Tipik olarak non-static veri elemanlarına değerler verilebilir. Ayrıca, örneğin bir nesnenin yaratılması
	işleminde bir bağlantının sağlanması (connect) gerekiyorsa bu işlem tipik olarak ctor içerisinde yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Sample s1 = new Sample(10, true);
		Sample s2 = new Sample();
		
		System.out.printf("s1.x = %d, s1.y = %b%n", s1.x, s1.y);
		System.out.printf("s2.x = %d, s2.y = %b%n", s2.x, s2.y);
	}
}

class Sample {
	public int x;
	public boolean y;
	
	public Sample()
	{
		
	}
	
	public Sample(int a, boolean b)
	{
		x = a;
		y = b;
	}
	
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		Point p1 = new Point(100, 200);
		Point p2 = new Point();
		Point p3 = new Point(2.345);
		
		p1.print();
		p2.print();
		p3.print();
	}
}

class Point {
	public double x, y;
	
	public Point()
	{
		
	}
	
	public Point(double a)
	{
		x = a;
	}
	
	public Point(double a, double b)
	{
		x = a;
		y = b;
	}
	
	public double distance()
	{
		return distance(0, 0);
	}
	
	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}
	
	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}
	
	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%f, %f)%n", x, y);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Rassal (Random) Sayı Üretimi: Bilgisayarlar ile gerçek hayattaki rassallık sağlanamaz. Çünkü gerçek hayatta rassallığı
	etkileyen pek çok durum vardır ve bunların bazıları henüz öngörülememektedir. Dolayısıyla bilgisayar programlarıyla
	belirlenemez. Bilgisayarlarda kullanılan rassallığa "pseudo random" denilmektedir. Java'da özellike Java 17'den 
	itibaren rassal sayı üretimine ilişkin pek çok algoritma kullanılabilmektedir. java.util.Random isimli bir sınıf 
	genek olarak eskiden beri kullanılmaktadır. Bu sınıfın rassal sayı üretimi orta kalitededir. Random sayı üretimine
	ilişkin diğer algoritmalar burada kullanılmayacaktır. Java 17'den itibaren Random sınıfına ilişkin rassal sayı 
	üretimine "legacy random" denilmektedir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının default ctor'u ile her nesne yaratıldığında auynı koddan farklı dizilim elde edilir. Bunun detayı 
	ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	Ranom sınıfının parametresiz nextInt metodu her çağrıda int türü sınırları içerisinde üretilmiş rassal sayıya
	geri döner 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.println(r.nextInt());
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının parametresiz nextInt metodu her çağrıda int türü sınırları içerisinde üretilmiş rassal sayıya
	geri döner 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.println(r.nextInt());	
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının int türden bound parametreli overload'u [0, bound) aralığında üretilmiş rassal sayıya geri döner
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.printf("%d ", r.nextInt(100)); //[0, 100)
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Java 17 ile birlikte Random sınıfının nextInt metodunun int türden origin ve bound parametreli bir overload'u vardır
	
	Anahtar Notlar: İki parametreli nextInt metodu Java 17 ile birlikte doğrudan sınıfına eklenmemiştir. Bu işlemin
	nasıl yapıldığı arayüzler (interfaces) konusuyla birlikte ele alınacaktır. Bu sebeple şu an için Random sınıfına
	eklenmiştir denebilir.
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.printf("%d ", r.nextInt(1, 100)); //[1, 100)
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının nextDouble metodu [0, 1) aralığında double türden rassal olarak üretilmiş sayıya geri döner
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.printf("%f%n", r.nextDouble()); //[1, 100)

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Java 17 ile birlikte Random sınıfının nextDouble metodunun double türden origin ve bound parametreli bir overload'u 
	vardır
	
	Anahtar Notlar: İki parametreli nextDouble metodu Java 17 ile birlikte doğrudan sınıfına eklenmemiştir. Bu işlemin
	nasıl yapıldığı arayüzler (interfaces) konusuyla birlikte ele alınacaktır. Bu sebeple şu an için Random sınıfına
	eklenmiştir denebilir.
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.printf("%f%n", r.nextDouble(2.345, 2.346));

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Java 17 ile birlikte Random sınıfının nextDouble metodunun double türden bound parametreli bir overload'u 
	vardır
	
	Anahtar Notlar: İki parametreli nextDouble metodu Java 17 ile birlikte doğrudan sınıfına eklenmemiştir. Bu işlemin
	nasıl yapıldığı arayüzler (interfaces) konusuyla birlikte ele alınacaktır. Bu sebeple şu an için Random sınıfına
	eklenmiştir denebilir.
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.printf("%f%n", r.nextDouble(0.0001)); //[0, 0.0001)

	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Benzer şekilde nextLong metotları da long türden sayı üretmek için kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i)
			System.out.printf("%d%n", r.nextLong());
		
		System.out.println("-----------------------------------------------------------");
		for (int i = 0; i < count; ++i)
			System.out.printf("%d%n", r.nextLong(-40_000_000_000L, 40_000_000_001L));
		
		System.out.println("-----------------------------------------------------------");
		
		for (int i = 0; i < count; ++i)
			System.out.printf("%d%n", r.nextLong(40_000_000_001L));
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Random sınıfının nextBoolean metodu
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		System.out.print("Bir sayı giriniz:");
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i) 
			System.out.printf("%b%n", r.nextBoolean());
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 17 öncesinde [min, bound) aralığında int türden rassal sayı üretimi aşağıdaki gibi yapılabilir. Şüphesiz
	pek çok yöntem olabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		while (true) {
			System.out.print("Kaç tane sayı üretmek istersiniz?");
			int count = Integer.parseInt(kb.nextLine());
			
			if (count <= 0)
				break;
			
			System.out.print("Minimum değeri giriniz:");
			int min = Integer.parseInt(kb.nextLine());
			
			System.out.print("Sınır değerini giriniz:");
			int bound = Integer.parseInt(kb.nextLine());
			
			for (int i = 0; i < count; ++i)
				System.out.printf("%d ", r.nextInt(bound - min) + min); //r.nextInt(min, bound); -> Since Java 17
			
			System.out.println();
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 17 öncesinde [min, bound) aralığında double türden rassal sayı üretimi aşağıdaki gibi yapılabilir. Şüphesiz
	pek çok yöntem olabilir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		java.util.Random r = new java.util.Random();
		
		while (true) {
			System.out.print("Kaç tane sayı üretmek istersiniz?");
			int count = Integer.parseInt(kb.nextLine());
			
			if (count <= 0)
				break;
			
			System.out.print("Minimum değeri giriniz:");
			double min = Double.parseDouble(kb.nextLine());
			
			System.out.print("Sınır değerini giriniz:");
			double bound = Double.parseDouble(kb.nextLine());
			
			for (int i = 0; i < count; ++i)
				System.out.printf("%f%n", r.nextDouble() * (bound - min) + min); //r.nextDouble(min, bound); -> Since Java 17
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Hilesiz bir paranın atılması deneyinde yazı gelme olasılığını yaklaşık olarak hesaplayan basit bir 
	simülasyon programı yazınız
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		CoinTailProbabilitySimulationApp.run();
	}
}


class CoinTailProbabilitySimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());
			
			if (count <= 0)
				break;
			
			CoinTailProbabilitySimulation simulation = new CoinTailProbabilitySimulation();
			
			simulation.run(count);
			
			System.out.printf("p = %f%n", simulation.p);
		}
		
	}
}

class CoinTailProbabilitySimulation {
	public double p;
	
	public void run(int n)
	{
		int count = 0;
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < n; ++i)
			count += r.nextInt(2);
		
		p = (double)count / n;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: Hilesiz bir paranın atılması deneyinde yazı gelme olasılığını yaklaşık olarak hesaplayan basit bir 
	simülasyon programı yazınız
	
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		CoinTailProbabilitySimulationApp.run();
	}
}


class CoinTailProbabilitySimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());
			
			if (count <= 0)
				break;
			
			CoinTailProbabilitySimulation simulation = new CoinTailProbabilitySimulation();
			
			simulation.run(count);
			
			System.out.printf("p = %f%n", simulation.p);
		}
		
	}
}

class CoinTailProbabilitySimulation {
	public double p;
	
	public void run(int n)
	{
		int count = 0;
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < n; ++i)
			if (r.nextBoolean())
				++count;
		
		p = (double)count / n;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	18.11.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Sınıf Çalışması: İki zar atıldığında zarların çift (ikisinin de aynı) gelme olasılığını yaklaşık olarak hesaplayan
	basit bir simülasyon programını yazınız
	
	Not: İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		DiceProbabilitySimulationApp.run();
	}
}


class DiceProbabilitySimulationApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Bir sayı giriniz:");
			int count = Integer.parseInt(kb.nextLine());
			
			if (count <= 0)
				break;
			
			DiceProbabilitySimulation simulation = new DiceProbabilitySimulation();
			
			simulation.run(count);
			
			System.out.printf("p = %f%n", simulation.p);
		}
		
	}
}

class DiceProbabilitySimulation {
	public double p;
	
	public static boolean areSame(java.util.Random r)
	{
		return r.nextInt(1, 7) == r.nextInt(1, 7);
	}
	
	public void run(int n)
	{
		int count = 0;
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < n; ++i)
			if (areSame(r))
				++count;
		
		p = (double)count / n;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Algoritması ne olursa olsun "pseudo random" sayı üretimi genel olarak bir tohum (seed) değerinden başlar. Bu anlamda
	aslında her sayı üretiminde tohum değeri ilgili yömteme göre güncellenir. Bu durumda tohum değeri bir nesne için
	hep aynı verildiğinde aynı çağrılarda aynı dizilim elde edilir.  Bu durumda tohum değeri her yaratılan Random
	nesnesi için mümkün olduğunca farklı verilirse bu durumda örneğin program her çalıştırıldığında farklı dizilim
	elde edilir. İşte Random sınıfının default ctor'u ile nesne yartıldığında ilgili tohum değeri önceki nesnelerden 
	mümkün olduğunca farklı verilir. Random sınıfının long türden seed parametreli ctor'u ile nesne tohum değeri
	verilerek de yaratılabilmektedir. Ayrıca setSeed metodu ile de yaratılmış olan bir Random nesnesi için o anki
	tohum değeri değiştirilebilmektedir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek her çalıştırıldığında farklı bir dizilim elde edilecektir.
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 11; ++i)
			System.out.printf("%d ", r.nextInt(1, 11));
		
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek her çalıştırıldığında aynı dizilim elde edilecektir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random(1000);
		
		for (int i = 0; i < 11; ++i)
			System.out.printf("%d ", r.nextInt(1, 11));
		
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte üretilen ilk 10 sayının dizilimi her çalıştırmada farklı olacaktır. Üretilen ikinci 10 sayının
	dizilimi her çalıştırmada girilen tohum değerine bağlı olacağından aynı tohum değerleri için aynı olacaktır 
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Tohum değerini giriniz:");
		long seed = kb.nextLong();
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
		
		r.setSeed(seed);
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Her ne kadar nasıl yaptığını söylemese de tohum değerinin farklı verilebilmesi için zamana bağlı değerler kullanılır.
	System sınıfının currentMillis metodu 01.01.1970 gece yarısından (00:00:00.000) çağrılan zamana kadar geçen milisaniye
	sayısına geri döner. Bu durumda programcı tohum değeri olarak bu değeri verirse yine her defasında farklı tohum
	değeri elde edilmiş olur. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random(System.currentTimeMillis());
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Tohum değerini giriniz:");
		long seed = kb.nextLong();
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
		
		r.setSeed(seed);
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Benzer şekilde JVM'in yüksek çözünürlüklü zaman kaynağına (high resolution time source) ilişkin milisaniye değerine
	geri döner. Genel olarak bu değer surrentMillis metodundan elde edilen değerden daha hassastır. Bu detayların
	önemi yoktur. Ancak bu metot da her defasında farklı tohum değeri belirlemede kullanılabilir. Hatta Random sınıfının
	pek çok implementasyonunda default ctor'da bu metot çağrılarak tohım değeri belirlenir. Şüphesiz böyle olmak zorunda
	değildir
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random(System.nanoTime());
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Tohum değerini giriniz:");
		long seed = kb.nextLong();
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
		
		r.setSeed(seed);
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	System.currentMillis ve System.nanoTime metotlarının detaylarının şu an için önemi yoktur. Aslında bu metotların 
	programcı tarafından kullanım amacı çoğu zaman tohumm değeri belirlemek değildir. Zaten default ctor tohum değerini 
	her çağrıldığında farklı olacak şekilde belirlediğinden yukarıdaki örnekte bu metotların çağrılması gerekmez. Ancak 
	şöyle spesifik bir örnekte gerekebilir: Tohum değeri bir nesne için o an akış her oraya geldiğinde farklı dizilim 
	elde edilmek istenirse kullanılabilir. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Tohum değerini giriniz:");
		long seed = kb.nextLong();
		
		java.util.Random r = new java.util.Random(seed);
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
		
		r.setSeed(System.nanoTime());
		
		for (int i = 0; i < 10; ++i)
			System.out.printf("%02d ", r.nextInt(100));
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.print("Tohum değerini giriniz:");
			long seed = kb.nextLong();
			
			java.util.Random r = new java.util.Random(seed);
			
	 		
			for (int i = 0; i < 10; ++i)
				System.out.printf("%02d ", r.nextInt(100));
			
			System.out.println();
			
			r.setSeed(System.nanoTime());
			
			for (int i = 0; i < 10; ++i)
				System.out.printf("%02d ", r.nextInt(100));
			
			System.out.println();
		
			if (seed == 0)
				break;
		}	
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		
		System.out.print("Tohum değerini giriniz:");
		long seed = kb.nextLong();
		
		java.util.Random r = new java.util.Random(seed);
			
		for (int i = 0; i < 10; ++i) {
			System.out.println("---------------------------------");
			for (int k = 0; k < 10; ++k)
				System.out.printf("%02d ", r.nextInt(100));
			
			System.out.println();
			
			r.setSeed(System.nanoTime());
			
			for (int k = 0; k < 10; ++k)
				System.out.printf("%02d ", r.nextInt(100));
			
			System.out.println();
			
			System.out.println("---------------------------------");
	
		}	
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki demo örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		GenerateRandomPointsApp.run();	
	}
}

class GenerateRandomPointsApp {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Input width, height, code and count:");
		int width = kb.nextInt();
		int height = kb.nextInt();
		long code = kb.nextLong();
		int count = kb.nextInt();
		java.util.Random r = new java.util.Random(code);
		
		for (int i = 0; i < count; ++i) {
			Point pixel = PointUtil.createRandomnPoint(r, 0, width, 0, height);
			
			//...
			
			pixel.print();
		}
	}
}


class PointUtil {
	public static Point createRandomnPoint(java.util.Random r, int minX, int boundX, int minY, int boundY)
	{
		return new Point(r.nextInt(minX, boundX), r.nextInt(minY, boundY));
	}
}

class Point {
	public double x, y;
	
	public Point()
	{
		
	}
	
	public Point(double a)
	{
		x = a;
	}
	
	public Point(double a, double b)
	{
		x = a;
		y = b;
	}
	
	public double distance()
	{
		return distance(0, 0);
	}
	
	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}
	
	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}
	
	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%f, %f)%n", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Complex z1 = new Complex(3.4, 7.8);
		Complex z2 = new Complex();
		Complex z3 = new Complex(5.6);
		
		z1.print();
		z2.print();
		z3.print();
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıfını ve örnek kodlarını inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package csd;

class App {
	public static void main(String [] args)
	{	
		Complex z1 = new Complex(3.4, 7.8);
		Complex z2 = new Complex(9.8, 5.6);
		Complex z;
		
		z1.print();
		z2.print();
		
		z = z1.add(z2); //Mantıksal: z1 + z2
		z.print();
		
		z = z1.add(3.6); // Mantıksal: z1 + 3.6
		z.print();
		
		z = Complex.add(3.6, z1); //Mantıksal: 3.6 + z1
		z.print();
		
		z = z1.subtract(z2); //Mantıksal: z1 - z2
		z.print();
		
		z = z1.subtract(3.6); // Mantıksal: z1 - 3.6
		z.print();
		
		z = Complex.subtract(3.6, z1); //Mantıksal: 3.6 - z1
		z.print();
	}
}


package csd;

class App {
	public static void main(String [] args)
	{	
		Complex z1 = new Complex(3.4, 7.8);
		Complex z2 = new Complex(9.8, 5.6);
		Complex z;
		
		z1.print();
		z2.print();
		
		z = z1.add(z2); //Mantıksal: z1 + z2
		z.print();
		
		z = z1.add(3.6); // Mantıksal: z1 + 3.6
		z.print();
		
		z = Complex.add(3.6, z1); //Mantıksal: 3.6 + z1
		z.print();
		
		z = z1.subtract(z2); //Mantıksal: z1 - z2
		z.print();
		
		z = z1.subtract(3.6); // Mantıksal: z1 - 3.6
		z.print();
		
		z = Complex.subtract(3.6, z1); //Mantıksal: 3.6 - z1
		z.print();
	}
}

package csd;

class App {
	public static void main(String [] args)
	{	
		Complex z1 = new Complex(3.4, 7.8);
		Complex z2 = new Complex(9.8, 5.6);
		Complex z;
		
		z1.print();
		z2.print();
		
		z = z1.multiply(z2); //Mantıksal: z1 * z2
		z.print();
		
		z = z1.multiply(3.6); // Mantıksal: z1 * 3.6
		z.print();
		
		z = Complex.multiply(3.6, z1); //Mantıksal: 3.6 * z1
		z.print();
	}
}

package csd;

class App {
	public static void main(String [] args)
	{	
		Complex z = new Complex(3.4, 7.8);
		
		z.print();
		z.inc();
		z.print();
		z.dec();
		z.print();
	}
}

class Complex {
	public double real, imag;
	
	public static Complex add(double re1, double im1, double re2, double im2) //İleride gizleyeceğiz
	{
		return new Complex(re1 + re2, im1 + im2);
	}
	
	public static Complex subtract(double re1, double im1, double re2, double im2) //İleride gizleyeceğiz
	{
		return add(re1, im1, -re2, -im2);
	}
	
	public static Complex multiply(double re1, double im1, double re2, double im2) //İleride gizleyeceğiz
	{
		return new Complex(re1 * re2 - im1 * im2, re1 * im2 + re2 * im1);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.real, z.imag);
	}
	
	public Complex add(double val)
	{
		return add(real, imag, val, 0);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.real, z.imag);
	}
	
	public Complex subtract(double val)
	{
		return subtract(real, imag, val, 0);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public static Complex multiply(double val, Complex z)
	{
		return multiply(val, 0, z.real, z.imag);
	}
	
	public Complex multiply(double val)
	{
		return multiply(real, imag, val, 0);
	}
	
	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}
	
	public Complex conjugate()
	{
		return new Complex(real, -imag);
	}
	
	public Complex negate()
	{
		return new Complex(-real, -imag);
	}
	
	public void inc()
	{
		++real;
	}
	
	public void dec()
	{
		--real;
	}
	
	public void print()
	{
		System.out.printf("%f + %f * i%n", real, imag);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	19.11.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Paketler (Packages) ve İsim Arama (Name Lookup):
	Anımsanacağı gibi bir Java programı genel olarak paketlerden oluşur demiştik.  
	Aşağıdaki maddelerde "user defined type (UDT)" olarak belirtilen kavram için şu ana kadar ki bilgilerimizle sınıf 
	düşünülebilir. Ancak ileride başka UDT'ler de göreceğiz.
	
	Java kodlarını içeren ve genellikle ".java" uzantılı dosyalara yani derlenen dosyalara "derleme birimi (compilation/translation unit)"
	denir. Java'da eğer birden fazla UDT varsa, her bir UDT ayrı bir derleme birimi olarak düşünülebilir.
	
	Paketlere ilişkin detaylar:
	- javac her bir UDT için ayrı bir ".class" uzantılı dosya üretir. Bu dosyalara "byte code" dendiğini anımsayınız. UDT'ler
	aynı derleme biriminde bile olsalar her biri için ayrı byte code üretilir.
	
	- Bir UDT herhangi bir pakette olabilir. Bir proje içerisindeki UDT'lerin aynı paket altında olması zorunluluğu yoktur.
	
	- Bir ".class" uzantılı dosyanın, byte code'a ilişkin UDT'nin ait olduğu paketle aynı isimde bir dizinde (directory) olması
	gerekir. Bunu IDE programlar otomatik olarak uygun dizinlerde üretirler. Derleme birimleri için böyle bir zorunluluk
	yoktur. Yani bir .java uzantılı dosya herhangi bir yerde derlenebilir. Ancak Java'da kullanılan IDE'lerin neredeyse hepsi
	derleme birimleri için de pakete ilişkin directory'yi zorunlu tutar.
	
	- Bir UDT'nin ismine bulunduğu paket dışından paket ismi ve nokta operatörü ile erişilebilir. Bir UDT'ye bulunduğu
	paket dışında erişilebilmesi için o UDT'nin public olarak bildirilmesi gerekir. public olarak bildirilmeyen yani yalnızca
	kendi paketi içerisindeki diğer UDT'ler erişilebilen UDT'lere "friendly" terimi kullanılır. Bazı kaynaklar friendly
	terimi yerine "internal" terimini de kullanırlar.
	
	- Farklı paketlerde bulunan UDT'lerin byte code'larının bulunduğu pakete ilişkin dizinlerin yani aslında paketi belirten 
	dizinin uygulamanın çalışmaya başladığı yerde olması gerekir. Bu durumda tüm paketler burada konuşlandırılmalıdır.
	
	- Uygulamada kullanılan sınıflar içerisinde bir tane main metodu olmak zorunda değildir. java programına verilen sınıfın
	uygun main metodu çalıştırılır. main metodunun yapısı aşağıdaki gibi olmalıdır:
	
		public static void main(String [] args)
	
	Bu yapıda değişebilecek tek şey args ismidir. java programına verilen sınıfın main metoduna yani akışın başladığı metoda
	"entry point" denir. Entry point olarak kullanılan main'in ait olduğu UDT'nin kesinlikle bir sınıf olması gerekir.
	
	- public olarak bildirilen bir UDT, ismi ile aynı isimde bir .java dosyasında bildirilmesi gerekir. Aksi durumda error 
	oluşur. Bu durumda bir java dosyası içerisinde, dosya ile aynı isimde olan bir sınıf public olabilir.
	
	- Bir java dosyasında public bir sınıf olmak zorunda değildir. Bu durumda bildirilen sınıfların friendly olması gerekir.
	
	- Bir java dosyasında dosya ismi ile aynı isimde bir sınıfa da olmak zorunda değildir. Ancak bu durum pratikte pek
	tercih edilmez.
	
	- Bir java dosyasında public olmayan istenildiği kadar sınıf bildirilebilir. Bu UDT'lerin hepsi aynı pakette bildirilmiş olur.xx
	
	- Bir java dosyasında yalnızca bir paket bildirimi yapılabilir. Paket bildirimi tüm diğer kodlardan önce yazılmalıdır.
	
	- Birden fazla java dosyasında aynı paket bildirimi yapılabilir. Bu durumda bu dosyalardaki tüm UDT'ler aynı pakette
	bildirilmiş olur. 
	
	- Aynı paket içerisinde aynı isimde birden fazka UDT bildirimi geçersizdir.
	
	- Farklı paketler içerisinde aynı isimde UDT'lerin bildirimi yapılabilir.  
	
	- Bir paketin alt paketleri olabilir. Alt paket bildiriminin genel biçimi şu şekildedir:
		package <paket ismi>[.<alt paket ismi>.<alt paket ismi> ...]
	Alt paket içerisindeki UDT'lerin byte code'ları paket hiyerarşisi içerisinde uygun alt dizinde bulunmak zorundadır.
	Yine IDE programlar bunu otomatik olarak yaparlar.
	
	- Paketler içiçe bile olsa farklı paketlerdir. Yani örneğin csd.util paketi içerisinde Point isimli bir sınıf varsa
	csd içerisinde de Point isimli bir sınıf olabilir. Çünkü paketler farklıdır, isim çakışması oluşmaz
	
	- Paketler isim çakışmasını engellemek için düşünülmüştür. Paketler ile farklı firmalar kendi paket isimleriyle UDT'leri 
	yazdıklarında UDT'lerin isimleri aynı olsa bile diğerleriyle birlikte aynı uygulamada kullanılabilirler.
	
	- Paket isimleri genelde firmaya özgü tekil (unique) olan domain isminden üretilir. Örneğin CSD'nin paketleri, 
	domain'i "csystem.org" olduğundan "org.csystem" paketi altında yazılabilir. Bu bir convention'dır ve firmalar özellikle
	genel UDT'ler için buna mutlaka uyarlar. Pratikte domain ismi altında doğrudan UDT bildirilmez, en az bir tane paket 
	altında bildirilir. Yani bu convention'da domain ismi paket hiyerarşisinin taban paketini temsil eder. Programcı
	sınıfları koyacağı paketleri okunabilir ve isim çakışması olasılığının çok çok aza indirecek şekilde bildirmelidir. Bu 
	anlamda alt paketlerin fazla olması sorun oluşturmaz. Paket isimlendirmede programcının anlamlı olacak şekilde cömert
	olması gerekir. Paketler, yine bir convention olarak tamamı küük harf olacak şekilde isimlendirilir. Birden fazla 
	kelimeden oluşan paket isimleri bitişik yazılır.
	
	- Java'nın standart tüm paketleri ve UDT'leri java isimli bir paketin altında bildirilmiştir. Bu anlamda programcının
	java paketi altında bir bildirim yapması tavsiye edilmez. Zaten yukarıdaki convention'a uyan programcı böyle bir bildirim
	yapmaz. 
	
	- java.lang paketi altındaki tüm UDT'ler her yerden görülebilirdir. Yani bu paket altındaki tüm UDT isimlerine doğrudan
	erişilebilir. Ayrıca belirtilmesi gerekmez. İleride göreceğimiz "import bildirimi" yapılmasına da gerek olmaz. Örneğin
	String sınıfı, System sınıfı, Integer sınıfı, Character sınıfı gibi sınıflar java.lang paketi altında bildirilmiştir.   
	
	- Hiç bir paket altında bildirilmeyen UDT'ler "isimsiz paket (unnamed package)" içerisinde bildirilmiş olur. Pratikte
	bir uygulama içerisinde isimsiz paket altında UDT bildirimi yapılmaz. Bunun nedeni ileride anlaşılacaktır  
-----------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------
	FILE NAME	: Complex.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 19th November 2023
	
	Complex class that represents a complex number
	
	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math;

public class Complex {
	public double real, imag;
	
	public static Complex add(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 + re2, im1 + im2);
	}
	
	public static Complex subtract(double re1, double im1, double re2, double im2)
	{
		return add(re1, im1, -re2, -im2);
	}
	
	public static Complex multiply(double re1, double im1, double re2, double im2)
	{
		return new Complex(re1 * re2 - im1 * im2, re1 * im2 + re2 * im1);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public static Complex add(double val, Complex z)
	{
		return add(val, 0, z.real, z.imag);
	}
	
	public Complex add(double val)
	{
		return add(real, imag, val, 0);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public static Complex subtract(double val, Complex z)
	{
		return subtract(val, 0, z.real, z.imag);
	}
	
	public Complex subtract(double val)
	{
		return subtract(real, imag, val, 0);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public static Complex multiply(double val, Complex z)
	{
		return multiply(val, 0, z.real, z.imag);
	}
	
	public Complex multiply(double val)
	{
		return multiply(real, imag, val, 0);
	}
	
	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}
	
	public Complex conjugate()
	{
		return new Complex(real, -imag);
	}
	
	public Complex negate()
	{
		return new Complex(-real, -imag);
	}
	
	public void inc()
	{
		++real;
	}
	
	public void dec()
	{
		--real;
	}
	
	public void print()
	{
		System.out.printf("%f + %f * i%n", real, imag);
	}
}


/*--------------------------------------------------------
	FILE NAME	: Point.java
	AUTHOR		: Java-Aug-2023 Group
	LAST UPDATE	: 19th November 2023
	
	Point class that represents a 2 dimensional point
	
	Copyleft C and System Programmers Association (CSD)
	All Rights Free
---------------------------------------------------------*/
package org.csystem.math.geometry;

public class Point {
	public double x, y;
	
	public Point()
	{
		
	}
	
	public Point(double a)
	{
		x = a;
	}
	
	public Point(double a, double b)
	{
		x = a;
		y = b;
	}
	
	public double distance()
	{
		return distance(0, 0);
	}
	
	public double distance(Point other)
	{
		return distance(other.x, other.y);
	}
	
	public double distance(double a, double b)
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(double dxy)
	{
		offset(dxy, dxy);
	}
	
	public void offset(double dx, double dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%f, %f)%n", x, y);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir isim iki biçimde kullanılabilir: nitelikli (qualified), niteliksiz (unqualified)
	
	Bir isim nokta operatörünün sağında kalıyorsa nitelikli kullanılmış olur. Kalmıyorsa niteliksiz kullanılmış olur.
	
	Anahtar Notlar: Burada nitelikli (qualified) ve niteliksiz (unqualified) terimleri olumlu ya da olumsuz anlamda 
	değildir. Burada kullanım biçimini belirtir.
	
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{	
		Sample s; //Sample niteliksiz kullanılmıştır
		
		s = new Sample(); //s ve Sample niteliksiz kullanılmıştır
		s.foo(10); //s niteliksiz, foo nitelikli kullanılmıştır
		
		System.out.printf("s.x = %d%n", s.x); //System niteliksiz, out nitelikli, printf nitelikli, s niteliksiz ve x niteklikli kullanılmıştır		
	}
}

class Sample {
	public int x;
	
	public void foo(int a)
	{
		x = a; //x ve a niteliksiz kullanılmıştır
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Derleyici kullanılan bir ismi önce arar, bulursa doğru kullanılıp kullanılmadığına bakar. Eğer bulamazsa veya bulur
	ancak yanlış kullanıldığını anlarsa error oluşur. Derleyici bildirilen isimleri doğal olarak aramaz. Derleyici
	ismin kullanımına göre ismi nitelikli veya niteliksiz olarak arar. İşte nitelikli ve niteliksiz isim arama (name lookup)
	kuralları burada ele alınacaktır
	
	Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { //App aranmaz
	public static void main(String [] args) //main aranmaz, String niteliksiz aaranır, args aranmaz
	{	
		Sample s; //Sample niteliksiz aranız, s aranmaz
		
		s = new Sample(); //s ve Sample niteliksiz aranır
		s.foo(10); //s niteliksiz, foo nitelikli aranız
		
		System.out.printf("s.x = %d%n", s.x); //System niteliksiz, out nitelikli, printf nitelikli, s niteliksiz ve x niteklikli aranır		
	}
}

class Sample { //Sample aranmaz
	public int x; //x aranmaz
	
	public void foo(int a) //foo ve a aranmaz
	{
		x = a; //x ve a niteliksiz aranır
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Anahtar Notlar: Bu bölümde nitelikli ve niteliksiz isim arama kuralları anlatılacaktır. Bu kuralların her birisinin
	genel ve özel durumları vardır. Özel durumlar ayrıca ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	25.11.2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Derleyici kullanılan bir ismi önce arar, bulursa ismin doğru olarak kullanılıp kullanılmadığına bakar. Eğer doğru
	kullanılmıyorsa error oluşur. Bu durumda ismin bulunanamasından dolayı oluşan error ile ismin doğru kullanılmamasından
	dolayı oluşan error aynı değildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
	public static void foo(double a)
	{
		int x;
		
		x = a; //error: İsim bulunda ancak geçersiz olarak kullanıldı
		x = y; //error: isim bulunamadı
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	1. İsim bir metot içerisinde kullanılmışsa kullanıldığı yerden yukarıya doğru aranır. Bu aramaya yerel değişkenler 
	ve metot parametre değişkenleri de dahildir.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
	public void foo(int a)
	{
		int x;
		
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	2. İsim kullanıldığı metodun ait olduğu sınıf içerisinde tüm metotların dışında her yerde aranır. Eğer sınıf
	içerisinde bulunamazsa doğrudan ve dolaylı taban sınıflara (direct and indirect super classes) da sırasıyla bakılır
	ve ilk bulduğu seçilir. Taban sınıf kavramı ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		Sample s = new Sample();
		
		s.foo(20);
		
		System.out.printf("s.x = %d%n", s.x);				
				
	}
}


class Sample {
	public int x;
	public void foo(int a)
	{	
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki kurala göre bir sınıfın bir metodunun parametre değişken ismi veya bir yerel değişken ismi ait olduğu
	sınıfın bir veri elemanı ile aynı olabilir. Bu durumda yerel değişken (veya parametre değişkeni) ismi veri elemanı
	ismini maskeler (shadowing/masking).  
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		Sample s = new Sample();
		
		s.foo(20);
		
		System.out.printf("s.x = %d%n", s.x);	
		s.bar(30);
		System.out.printf("s.x = %d%n", s.x);
		s.tar(45);
		System.out.printf("s.x = %d%n", s.x);
	}
}


class Sample {
	public int x;
	
	public void foo(int a)
	{	
		int x;
		
		x = a;
	}
	
	public void bar(int x)
	{
		x = x; //self assignment
	}
	
	public void tar(int a)
	{
		x = a;
	}
	
}


/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	3. İsim kullanıldığı sınıfın ait olduğu paket içerisinde aranır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Mample {
	//...
}

class Sample {
	public int x;
	public void foo(int a)
	{	
		Mample m;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	3. İsim kullanıldığı sınıfın ait olduğu paket içerisinde aranır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Mample {
	//...
}

class Sample {
	public int x;
	public void foo(int a)
	{	
		Mample m;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	3. İsim kullanıldığı sınıfın ait olduğu paket içerisinde aranır. Eğer bulunamazsa üst paketlere bakılmaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class Sample {
	public int x;
	public void foo(int a)
	{	
		Mample m; //error
	}
}

package org.csystem;

public class Mample {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	3. İsim kullanıldığı sınıfın ait olduğu paket içerisinde aranır. Eğer bulunamazsa alt paketlere bakılmaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;


class Sample {
	public int x;
	public void foo(int a)
	{	
		Mample m; //error
	}
}


package org.csystem.app.mest;

public class Mample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki kural gereği isimsiz bir paket altında bulunan sınıfa başka bir paketten erişmenin bir yolu yoktur. İşte
	bu sebeple bir proje içerisinde isimsiz paket altında UDT bildirimi yapılmaz. Ancak küçük bazı denemeler için
	kullanılabilir 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;


class Sample {
	public int x;
	public void foo(int a)
	{	
		Mample m; //error
	}
}


public class Mample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	4. İsim "import on demand" olarak bildirilmiş "import bildirimlerine" ilişkin paketler içerisinde aranır. Bu durum 
	ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Niteliksiz isim arama genel kurallarına göre aranan bir isim yukarıdaki maddelerin hiç birisinde bulunamazsa error 
	oluşur
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	1. İsmin solunda bir sınıf ismi varsa isim o sınıf içerisinde aranır. Bulunamazsa yine doğrudan ya da dolaylı
	sınıflara da sırasıyla bakılır 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		Sample.foo(20);
		
		System.out.printf("Sample.x = %d%n", Sample.x);
	}
}


class Sample {
	public static int x;
	public static void foo(int a)
	{	
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	2. İsmin solunda bir referans ismi varsa isim referansın türüne ilişkin sınıf içerisinde aranır. Bulunamazsa yine
	doğrudan ya da dolaylı taban sınıflara da sırasıyla bakılır 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		Sample s = new Sample();
		
		s.foo(20);
		
		System.out.printf("s.x = %d%n", s.x);
	}
}


class Sample {
	public int x;
	public void foo(int a)
	{	
		x = a;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Nitelikli isim arama genel kuralları (else-if biçiminde değerlendiriniz):
	3. İsmin solunda bir paket ismi varsa bu durumda ilgili paket içerisinde aranır. Bulunamazsa alt ya da üst paketlere
	bakılmaz 
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		csd.Sample s;
		
		
	}
}


package csd;

public class Sample {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Alt paket isimleri niteliksiz isim aramaya dahil edilmez. Başka bir deyişle, bir paket ismi niteliksiz isim aramada
	görmezden gelinir. Bir paket isminin niteliksiz olarak kullanılabilmesi için onun paket hiyerarşisinde en üstte 
	olması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App { 
	public static void main(String [] args) 
	{	
		company.hr.Staff s; //error
	}
}



package org.csystem.app.company.hr;

public class Staff {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	import bildirimleri (import declarations): import bildirimleri niteliklendirmeyi azaltmak ve dolaysıyla kodu daha
	yalın yazmak amacıyla kullanılır. import bildirimlerinin UDT ismi bakımından iki kullanım biçimi vardır:
	1. Yıldızlı import bildirimi (import on demand declaration):
	2. Yıldızsız import bildirimi (import single type declaration):
	
	import bildirimleri paket bildiriminden sonra tüm diğer bildirimlerden önce olmalıdır. Birden fazla import bildirimi
	geçerlidir ve bildirim sırasının önemi yoktur. import bildirimleri niteliksiz aramalar için geçerlidir. import
	bildirimleri yalnızca bildirildikleri derleme biriminde geçerlidir.
	
	Anahtar Notlar: import bildirimleri bir kütüphaneyi projeye dahil etmek demek DEĞİLDİR. Bir kütüphaneyi projeye dahil
	etmek için başka yöntemler kullanılmaktadır. 
	
	Anahtar Notlar: Yukarıdaki yıldızlı ve yıldızsız terimleri tamamen Oğuz Karan tarafından uydurulmuştur. Bunlar
	gerçek terimlerin gerçek tercümeleri değildir. Kolay algılanması açısında bu şekilde Türkçeleştirilmiştir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	Yıldızlı import bildirimi (import on demand declaration): Yıldızlı import bildiriminin genel biçimi şu şekildedir:
		import <paket ismi>[.<alt paket ismi>].*;
	Niteliksiz arama genel kurallarına göre paket içerisnde bulunamayan bir isim yıldızlı import bildirimlerine ilişkin
	paketlerde aranır. Burada tüm yıldızlı import bildirimlerine bakılır ancak alt ve üst paketlere yine bakılmaz. Yani 
	bu bildirim isim arama genel kurallarına göre, paket içerisine isim aarama anlamında başka bir paketi adeta enjekte 
	etmektir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.*;
import org.csystem.math.geometry.*;
import org.csystem.math.*;

class App { 
	public static void main(String [] args) 
	{	
		Scanner kb = new Scanner(System.in);
		Random r = new Random();
		
		System.out.print("Bir sayı giriniz:");
		
		int count = kb.nextInt();
		
		for (int i = 0; i < count; ++i) {
			Complex z = new Complex(r.nextDouble(3.4, 5.6), r.nextDouble(3.4, 5.6));
			Point p = new Point(r.nextDouble(3.4, 5.6), r.nextDouble(3.4, 5.6));
			
			System.out.println("------------------------");
			z.print();
			p.print();
			System.out.println("------------------------");
		}
	}
}




/*----------------------------------------------------------------------------------------------------------------------
	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/
